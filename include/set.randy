#include memory
#include vector


proc _default_set_compare a, b in
    return a == b;
end

proc _default_set_hash e in
    return e;
end

const TSET_length   =  0; // int
const TSET_capacity =  8; // int
const TSET_buffer   = 16; // ptr
const TSET_comparer = 24; // compare_fn
const TSET_hasher   = 32; // hash_fn
const sizeof_TSET   = 40; 
const sizeof_TSET_ELEM = sizeof_PTR;

const SET_Load_Factor = 2; // resize & rehash when size >= capacity/2
const SET_Default_Cap = 16;

proc make_set capacity, comparer, hasher in
    var self = malloc(sizeof_TSET);
    if capacity <= 0 then
        capacity = SET_Default_Cap;
    end
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, capacity);
    u64!(self + TSET_buffer, calloc(capacity, sizeof_TSET_ELEM));
    if not comparer then
        comparer = _default_set_compare;
    end
    if not hasher then
        hasher = _default_set_hash;
    end
    u64!(self + TSET_comparer, comparer);
    u64!(self + TSET_hasher, hasher);
    return self;
end

proc make_set_default in
    return make_set(0, NULL, NULL);
end

proc set_length self in return u64@(self + TSET_length); end
proc set_capacity self in return u64@(self + TSET_capacity); end
proc set_buffer self in return u64@(self + TSET_buffer); end
proc set_comparer self in return u64@(self + TSET_comparer); end
proc set_hasher self in return u64@(self + TSET_hasher); end

proc free_set self in
    if self then
        free(set_buffer(self));
        free(self);
    end
end

proc _set_expand self in
    var old_cap = set_capacity(self);
    var old_buf = set_buffer(self);
    var new_cap = old_cap * 2;
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, new_cap);
    var new_buf = calloc(new_cap, sizeof_TSET_ELEM);
    u64!(self + TSET_buffer, new_buf);
    var i = 0; var elt;
    while i < old_cap do
        elt = u64@(old_buf + i * sizeof_TSET_ELEM);
        if elt then
            set_add(self, elt);
        end
        i = i + 1;
    done
    free(old_buf);
end

proc _set_at self, idx in
    var buf = set_buffer(self);
    return buf + idx * sizeof_TSET_ELEM;
end

proc set_contains self, elem in
    var cap = set_capacity(self);
    var hasher = set_hasher(self); 
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while u64@(cur) do
        if comparer(u64@(cur), elem) then
            return true;
        end
        idx = (idx + 1) % cap;
        cur = _set_at(self, idx);
    done
    return false;
end

proc set_add self, elem in
    var cap = set_capacity(self);
    if set_length(self) >= cap / SET_Load_Factor then
        _set_expand(self);
        cap = set_capacity(self);
    end
    
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    done
    cur = _set_at(self, idx);
    if not u64@(cur) then
        // increment length
        u64!(self + TSET_length, u64@(self + TSET_length) + 1);
    end
    u64!(cur, elem);
end

proc set_remove self, elem in
    var cap = set_capacity(self);
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    done
    cur = _set_at(self, idx);
    if u64@(cur) then
        // decrement length
        u64!(self + TSET_length, u64@(self + TSET_length) - 1);
    end
    u64!(cur, NULL);
end
