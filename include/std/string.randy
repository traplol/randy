
#include core
#include memory

struct String in
    buffer: char&;
    length: int;
    capacity: int;
end

proc make_string init: int -> String& in
    var self = cast(malloc(__sizeof(String)), String&);
    var buf = malloc(init);

    self.buffer = buf;
    self.length = 0;
    self.capacity = init;
    
    return self;
end

proc free_string self: String& in
    free(cast(u64@(self), ptr));
    free(self);
end

proc string_buf self: String& -> char& in
    return self.buffer;
end

proc string_len self: String& -> int in
    return self.length;
end

proc string_set_len self: String&, n: int in
    if n >= 0 and n <= self.capacity then
        self.length = n;
    end
end

proc string_reset self: String& in
    self.length = 0;
end

proc string_cap self: String& -> int in
    return self.capacity;
end

proc string_get self: String&, idx: int -> char in
    return cast(u8@(self.buffer + idx), char);
end

proc string_set self: String&, idx: int, val: char in
    u8!(self.buffer + idx, val);
end

proc string_resize self: String&, new_cap: int in
    var new = malloc(new_cap);
    var old = self.buffer;
    var len = self.length;
    if new_cap < len then
        len = new_cap;
    end
    memcpy(new, old, len);
    free(old);
    self.buffer = new;
    self.length = len;
    self.capacity = new_cap;
end

proc string_push self: String&, val: char in
    var len = self.length;
    var cap = self.capacity;
    if len == cap then
        string_resize(self, 2 * cap + 1);
    end
    string_set(self, len, val);
    self.length = len + 1;
end

proc string_pop self: String& in
    var len = self.length;
    if len > 0 then
        self.length = len - 1;
    else
        printf("ERROR: string_pop out of bounds.\n");
        abort();
    end
end

proc string_back self: String& -> char in
    var len = self.length;
    if len > 0 then
        return string_get(self, len-1);
    end
    printf("ERROR: string_back out of bounds.\n");
    abort();
end

proc string_append_string self: String&, string: String& in
    var i = 0; var len = string.length;
    while i < len do
        string_push(self, string_get(string, i));
        i += 1;
    end
end

proc string_append_cstr self: String&, cstr: cstr in
    var i = 0;
    while u8@(cstr) do
        string_push(self, u8@(cstr));
        cstr += 1;
        i += 1;
    end
end

proc string_from_cstr cstr: cstr -> String& in
    var string = make_string(2);
    while u8@(cstr) do
        string_push(string, u8@(cstr));
        cstr += 1;
    end
    return string;
end

proc string_eq string_a: String&, string_b: String& -> bool in
    if string_a == string_b then
        return true;
    end
    if not string_a or not string_b then
        return false;
    end

    var a_len = string_a.length;
    var b_len = string_b.length;
    if a_len != b_len then
        return false;
    end

    var i = 0;
    while i < a_len do
        if string_get(string_a, i) != string_get(string_b, i) then
            return false;
        end
        i += 1;
    end
    return true;
end

proc string_cstr self: String& -> cstr in
    var len = self.length;
    if len == self.capacity then
        string_resize(self, len + 1);
    end
    string_set(self, len, 0);
    return self.buffer;
end

proc cstr_eq cstr_a: cstr, cstr_b: cstr -> bool in
    if cstr_a == cstr_b then
        return true;
    end
    if not cstr_a or not cstr_b then
        return false;
    end

    var a = u8@(cstr_a);
    var b = u8@(cstr_b);
    while a == b and a do
        a = u8@(cstr_a);
        b = u8@(cstr_b);
        cstr_a += 1;
        cstr_b += 1;
    end
    return a == b;
end

proc cstr_len cstr: cstr -> int in
    var i = 0;
    while u8@(cstr) do
        i += 1;
        cstr += 1;
    end
    return i;
end

proc string_duplicate self: String& -> String& in
    var copy = make_string(self.capacity);
    memcpy(copy.buffer, self.buffer, self.length);
    copy.length = self.length;
    return copy;
end
