
#include core
#include memory

const TSTRING_buffer = 0;
const TSTRING_length = 8;
const TSTRING_capacity = 16;
const sizeof_TSTRING = 24;

proc make_string init in
    var self = malloc(sizeof_TSTRING);
    var buf = malloc(init);

    u64!(self + TSTRING_buffer, buf);
    u64!(self + TSTRING_length, 0);
    u64!(self + TSTRING_capacity, init);
    
    return self;
end

proc free_string self in
    free(u64@(self));
    free(self);
end

proc string_buf self in
    return u64@(self);
end

proc string_len self in
    return u64@(self + TSTRING_length);
end

proc string_set_len self, n in
    if n >= 0 and n <= string_cap(self) then
        u64!(self + TSTRING_length, n);
        return true;
    else
        return false;
    end
end

proc string_reset self in
    string_set_len(self, 0);
end

proc string_cap self in
    return u64@(self + TSTRING_capacity);
end

proc string_get self, idx in
    return u8@(u64@(self) + idx);
end

proc string_set self, idx, val in
    u8!(u64@(self) + idx, val);
end

proc string_resize self, new_cap in
    var new = malloc(new_cap);
    var old = u64@(self);
    var len = string_len(self);
    if new_cap < len then
        len = new_cap;
    end
    memcpy(new, old, len);
    free(old);
    u64!(self, new);
    u64!(self + TSTRING_length, len);
    u64!(self + TSTRING_capacity, new_cap);
end

proc string_push self, val in
    var len = string_len(self);
    var cap = string_cap(self);
    if len == cap then
        string_resize(self, 2 * cap + 1);
    end
    string_set(self, len, val);
    u64!(self + TSTRING_length, len+1);
end

proc string_pop self in
    var len = string_len(self);
    if len > 0 then
        u64!(self + TSTRING_length, len - 1);
    else
        printf("ERROR: string_pop out of bounds.\n");
        abort();
    end
end

proc string_back self in
    var len = string_len(self);
    if len > 0 then
        return string_get(self, len-1);
    end
    printf("ERROR: string_back out of bounds.\n");
    abort();
end

proc string_append_string self, string in
    var len = string_len(string);
    var i = 0;
    while i < len do
        string_push(self, string_get(string, i));
        i = i + 1;
    done
end

proc string_append_cstr self, cstr in
    var i = 0;
    while u8@(cstr) do
        string_push(self, u8@(cstr));
        cstr = cstr + 1;
        i = i + 1;
    done
end

proc string_from_cstr cstr in
    var string = make_string(2);
    while u8@(cstr) do
        string_push(string, u8@(cstr));
        cstr = cstr + 1;
    done
    return string;
end

proc string_eq string_a, string_b in
    if string_a == string_b then
        return true;
    end
    if not string_a or not string_b then
        return false;
    end

    var a_len = string_len(string_a);
    var b_len = string_len(string_b);
    if a_len != b_len then
        return false;
    end

    var i = 0;
    while i < a_len do
        if string_get(string_a, i) != string_get(string_b, i) then
            return false;
        end
        i = i + 1;
    done
    return true;
end

proc string_cstr string in
    var len = string_len(string);
    if len == string_cap(string) then
        string_resize(string, len+1);
    end
    string_set(string, len, 0);
    return string_buf(string);
end

proc cstr_eq cstr_a, cstr_b in
    if cstr_a == cstr_b then
        return true;
    end
    if not cstr_a or not cstr_b then
        return false;
    end

    var a = u8@(cstr_a);
    var b = u8@(cstr_b);
    while a == b and a do
        a = u8@(cstr_a);
        b = u8@(cstr_b);
        cstr_a = cstr_a + 1;
        cstr_b = cstr_b + 1;
    done
    return a == b;
end

proc cstr_len cstr in
    var i = 0;
    while u8@(cstr) do
        i = i + 1;
        cstr = cstr + 1;
    done
    return i;
end

proc string_duplicate self in
    var copy = make_string(string_cap(self));
    memcpy(string_buf(copy), string_buf(self), string_len(self));
    string_set_len(copy, string_len(self));
    return copy;
end