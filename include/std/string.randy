
#include core
#include memory

// const TSTRING_buffer = 0;
// const TSTRING_length = 8;
// const TSTRING_capacity = 16;
// const sizeof_TSTRING = 24;
struct string in
    buffer: char&;
    length: int;
    capacity: int;
end

proc make_string init: int -> string& in
    var self = cast(malloc(__sizeof(string)), string&);
    var buf = malloc(init);

    self.buffer = buf;
    self.length = 0;
    self.capacity = init;
    
    return self;
end

proc free_string self: string& in
    free(cast(u64@(self), ptr));
    free(self);
end

proc string_buf self: string& -> char& in
    return self.buffer;
end

proc string_len self: string& -> int in
    return self.length;
end

proc string_set_len self: string&, n: int in
    if n >= 0 and n <= self.capacity then
        self.length = n;
    end
end

proc string_reset self: string& in
    self.length = 0;
end

proc string_cap self: string& -> int in
    return self.capacity;
end

proc string_get self: string&, idx: int -> char in
    return cast(u8@(self.buffer + idx), char);
end

proc string_set self: string&, idx: int, val: char in
    u8!(self.buffer + idx, val);
end

proc string_resize self: string&, new_cap: int in
    var new = malloc(new_cap);
    var old = self.buffer;
    var len = string_len(self);
    if new_cap < len then
        len = new_cap;
    end
    memcpy(new, old, len);
    free(old);
    self.buffer = new;
    self.length = len;
    self.capacity = new_cap;
end

proc string_push self: string&, val: char in
    var len = string_len(self);
    var cap = string_cap(self);
    if len == cap then
        string_resize(self, 2 * cap + 1);
    end
    string_set(self, len, val);
    self.length = len + 1;
end

proc string_pop self: string& in
    var len = string_len(self);
    if len > 0 then
        self.length = len - 1;
    else
        printf("ERROR: string_pop out of bounds.\n");
        abort();
    end
end

proc string_back self: string& -> char in
    var len = string_len(self);
    if len > 0 then
        return string_get(self, len-1);
    end
    printf("ERROR: string_back out of bounds.\n");
    abort();
end

proc string_append_string self: string&, string: string& in
    var len = string_len(string);
    var i = 0;
    while i < len do
        string_push(self, string_get(string, i));
        i += 1;
    end
end

proc string_append_cstr self: string&, cstr: cstr in
    var i = 0;
    while u8@(cstr) do
        string_push(self, u8@(cstr));
        cstr += 1;
        i += 1;
    end
end

proc string_from_cstr cstr: cstr -> string& in
    var string = make_string(2);
    while u8@(cstr) do
        string_push(string, u8@(cstr));
        cstr += 1;
    end
    return string;
end

proc string_eq string_a: string&, string_b: string& -> bool in
    if string_a == string_b then
        return true;
    end
    if not string_a or not string_b then
        return false;
    end

    var a_len = string_len(string_a);
    var b_len = string_len(string_b);
    if a_len != b_len then
        return false;
    end

    var i = 0;
    while i < a_len do
        if string_get(string_a, i) != string_get(string_b, i) then
            return false;
        end
        i += 1;
    end
    return true;
end

proc string_cstr string: string& -> cstr in
    var len = string_len(string);
    if len == string_cap(string) then
        string_resize(string, len+1);
    end
    string_set(string, len, 0);
    return string_buf(string);
end

proc cstr_eq cstr_a: cstr, cstr_b: cstr -> bool in
    if cstr_a == cstr_b then
        return true;
    end
    if not cstr_a or not cstr_b then
        return false;
    end

    var a = u8@(cstr_a);
    var b = u8@(cstr_b);
    while a == b and a do
        a = u8@(cstr_a);
        b = u8@(cstr_b);
        cstr_a += 1;
        cstr_b += 1;
    end
    return a == b;
end

proc cstr_len cstr: cstr -> int in
    var i = 0;
    while u8@(cstr) do
        i += 1;
        cstr += 1;
    end
    return i;
end

proc string_duplicate self: string& -> string& in
    var copy = make_string(string_cap(self));
    memcpy(string_buf(copy), string_buf(self), string_len(self));
    string_set_len(copy, string_len(self));
    return copy;
end
