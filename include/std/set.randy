#include memory

def _default_set_compare a: ptr, b: ptr -> bool in
    return a == b;
end

def _default_set_hash e: ptr -> int in
    return cast(e, int);
end

struct SetIterator[K] in
    _cur: K&;
    _end: K&;

    def new begin: K&, end_: K& in
        var self = cast(malloc(__sizeof(SetIterator[K])), SetIterator[K]&);
        self._cur = begin;
        self._end = end_;
        return self;
    end

    def next self in
        if self._cur == self._end then
            return NULL;
        else
            var cur = self._cur;
            cur += __sizeof(K);
            var end_ = self._end;
            while cur != end_ and not u@(cur, K) do
                cur += __sizeof(K);
            end
            self._cur = cur;
            if cur == end_ then
                return NULL;
            end
            return self;
        end
    end

    def key self in
        return u@(self._cur, K);
    end
end

const Set_Load_Factor = 2;
struct Set[K, KHash, KCompare] in
    length: int;
    _capacity: int;
    _buffer: K&;

    def new starting_capacity: int in
        if starting_capacity == 0 then
            starting_capacity = 17;
        end

        var self = cast(malloc(__sizeof(Set[K, KHash, KCompare])),
                        Set[K, KHash, KCompare]&);
        self.length = 0;
        self._capacity = starting_capacity;
        self._buffer = calloc(starting_capacity, __sizeof(K));
        return self;
    end

    def delete self in
        if self then
            free(self._buffer);
            free(self);
        end
    end

    def _expand self in
        var old_cap = self._capacity;
        var old_buf = self._buffer;
        var new_cap = (old_cap * 2) + 1;
        self.length = 0;
        self._capacity = new_cap;
        var new_buf = calloc(new_cap, __sizeof(K));
        self._buffer = new_buf;
        var i = 0; var elt;
        while i < old_cap do
            elt = cast(old_buf + i * __sizeof(K), K&);
            if u@(elt, K) then
                self.insert(u@(elt, K));
            end
            i += 1;
        end
        free(old_buf);
    end

    def _at self, idx: int in
        return cast(self._buffer + idx * __sizeof(K), K&);
    end

    def insert self, key: K in
        if self.length >= self._capacity / Set_Load_Factor then
            self._expand();
        end
        var idx = KHash::hash(key) % self._capacity;
        if idx < 0 then
            idx = -idx;
        end
        var cur = self._at(idx);
        while cur and u@(cur, K) do
            if KCompare::equal(u@(cur, K), key) then
                return;
            else
                idx = (idx + 1) % self._capacity;
                cur = self._at(idx);
            end
        end
        if not u@(cur, K) then
            self.length += 1;
        end
        u!(cur, key, K);
    end

    def remove self, key: K in
        var idx = KHash::hash(key) % self._capacity;
        if idx < 0 then
            idx = -idx;
        end
        var cur = self._at(idx);
        while cur and u@(cur, K) do
            if KCompare::equal(u@(cur, K), key) then
                u!(cur, 0, K);
                self.length -= 1;
                return;
            else
                idx = (idx + 1) % self._capacity;
                cur = self._at(idx);
            end
        end
    end

    def contains self, key: K in
        var idx = KHash::hash(key) % self._capacity;
        if idx < 0 then
            idx = -idx;
        end
        var cur = self._at(idx);
        while cur and u@(cur, K) do
            if KCompare::equal(u@(cur, K), key) then
                return true;
            else
                idx = (idx + 1) % self._capacity;
                cur = self._at(idx);
            end
        end
        return false;
    end

    def _begin self in
        var end_ = self._end();
        if self.length == 0 then
            return end_;
        end
        var cur = self._buffer;
        while cur != end_ do
            if u@(cur, K) then
                return cur;
            end
            cur += __sizeof(K);
        end
        return end_;
    end

    def _end self in
        return self._at(self._capacity);
    end

    def iter self in
        return SetIterator[K]::new(self._begin(), self._end());
    end
end

const TSET_length   =  0; // int
const TSET_capacity =  8; // int
const TSET_buffer   = 16; // ptr
const TSET_comparer = 24; // compare_fn
const TSET_hasher   = 32; // hash_fn
const sizeof_TSET   = 40;
const sizeof_TSET_ELEM = sizeof_PTR;

const SET_Load_Factor = 2; // resize & rehash when size >= capacity/2
const SET_Default_Cap = 16;

def make_set capacity: int, comparer: (ptr, ptr -> bool), hasher: (ptr -> int) -> set in
    var self = malloc(sizeof_TSET);
    if capacity <= 0 then
        capacity = SET_Default_Cap;
    end
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, capacity);
    u64!(self + TSET_buffer, calloc(capacity, sizeof_TSET_ELEM));
    if not comparer then
        comparer = _default_set_compare;
    end
    if not hasher then
        hasher = _default_set_hash;
    end
    u64!(self + TSET_comparer, comparer);
    u64!(self + TSET_hasher, hasher);
    return cast(self, set);
end

def make_set_default in
    return make_set(0, NULL, NULL);
end

def set_len self: set in return cast(u64@(self + TSET_length), int); end
def set_cap self: set in return cast(u64@(self + TSET_capacity), int); end
def set_buffer self: set in return cast(u64@(self + TSET_buffer), ptr); end
def set_comparer self: set in
    return cast(u64@(self + TSET_comparer), (ptr, ptr -> bool));
end
def set_hasher self: set in
    return cast(u64@(self + TSET_hasher), (ptr -> int));
end

def free_set self: set in
    if self then
        free(set_buffer(self));
        free(self);
    end
end

def _set_expand self: set in
    var old_cap = set_cap(self);
    var old_buf = set_buffer(self);
    var new_cap = old_cap * 2;
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, new_cap);
    var new_buf = calloc(new_cap, sizeof_TSET_ELEM);
    u64!(self + TSET_buffer, new_buf);
    var i = 0; var elt;
    while i < old_cap do
        elt = cast(u64@(old_buf + i * sizeof_TSET_ELEM), ptr);
        if elt then
            set_add(self, elt);
        end
        i += 1;
    end
    free(old_buf);
end

def _set_at self: set, idx: int -> ptr in
    var buf = set_buffer(self);
    return buf + idx * sizeof_TSET_ELEM;
end

def set_contains self: set, elem: ptr -> bool in
    var cap = set_cap(self);
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then
        idx = 0 - idx;
    end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while u64@(cur) do
        if comparer(u64@(cur), elem) then
            return true;
        end
        idx = (idx + 1) % cap;
        cur = _set_at(self, idx);
    end
    return false;
end

def set_add self: set, elem: ptr in
    var cap = set_cap(self);
    if set_len(self) >= cap / SET_Load_Factor then
        _set_expand(self);
        cap = set_cap(self);
    end

    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then
        idx = 0 - idx;
    end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    end
    cur = _set_at(self, idx);
    if not u64@(cur) then
        // increment length
        u64!(self + TSET_length, u64@(self + TSET_length) + 1);
    end
    u64!(cur, elem);
end

def set_remove self: set, elem: ptr in
    var cap = set_cap(self);
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then
        idx = 0 - idx;
    end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    end
    cur = _set_at(self, idx);
    if u64@(cur) then
        // decrement length
        u64!(self + TSET_length, u64@(self + TSET_length) - 1);
    end
    u64!(cur, NULL);
end

def set_end self: set -> set_iterator in
    return cast(_set_at(self, set_cap(self)), set_iterator);
end

def set_begin self: set -> set_iterator in
    var cur = _set_at(self, 0);
    var end_ = set_end(self);
    if set_len(self) == 0 then
        return end_;
    end
    while cur != end_ do
        if u64@(cur) then
            return cast(cur, set_iterator);
        end
        cur = cur + sizeof_TSET_ELEM;
    end
    return end_;
end

def set_next self: set, iter: set_iterator -> set_iterator in
    iter = cast(cast(iter, ptr) + sizeof_TSET_ELEM, set_iterator);
    var end_ = set_end(self);
    while iter != end_ do
        if u64@(iter) then
            return cast(iter, set_iterator);
        end
        iter = cast(cast(iter, ptr) + sizeof_TSET_ELEM, set_iterator);
    end
    return end_;
end

def set_reset self: set in
    if u64@(self + TSET_length) != 0 then
        u64!(self + TSET_length, 0);
        memset(set_buffer(self), 0, set_cap(self) * sizeof_TSET_ELEM);
    end
end
