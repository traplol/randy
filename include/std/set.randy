#include memory

def _default_set_compare a: ptr, b: ptr -> bool in
    return a == b;
end

def _default_set_hash e: ptr -> int in
    return cast(e, int);
end

const TSET_length   =  0; // int
const TSET_capacity =  8; // int
const TSET_buffer   = 16; // ptr
const TSET_comparer = 24; // compare_fn
const TSET_hasher   = 32; // hash_fn
const sizeof_TSET   = 40; 
const sizeof_TSET_ELEM = sizeof_PTR;

const SET_Load_Factor = 2; // resize & rehash when size >= capacity/2
const SET_Default_Cap = 16;

def make_set capacity: int, comparer: (ptr, ptr -> bool), hasher: (ptr -> int) -> set in
    var self = malloc(sizeof_TSET);
    if capacity <= 0 then
        capacity = SET_Default_Cap;
    end
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, capacity);
    u64!(self + TSET_buffer, calloc(capacity, sizeof_TSET_ELEM));
    if not comparer then
        comparer = _default_set_compare;
    end
    if not hasher then
        hasher = _default_set_hash;
    end
    u64!(self + TSET_comparer, comparer);
    u64!(self + TSET_hasher, hasher);
    return cast(self, set);
end

def make_set_default in
    return make_set(0, NULL, NULL);
end

def set_len self: set in return cast(u64@(self + TSET_length), int); end
def set_cap self: set in return cast(u64@(self + TSET_capacity), int); end
def set_buffer self: set in return cast(u64@(self + TSET_buffer), ptr); end
def set_comparer self: set in
    return cast(u64@(self + TSET_comparer), (ptr, ptr -> bool));
end
def set_hasher self: set in
    return cast(u64@(self + TSET_hasher), (ptr -> int));
end

def free_set self: set in
    if self then
        free(set_buffer(self));
        free(self);
    end
end

def _set_expand self: set in
    var old_cap = set_cap(self);
    var old_buf = set_buffer(self);
    var new_cap = old_cap * 2;
    u64!(self + TSET_length, 0);
    u64!(self + TSET_capacity, new_cap);
    var new_buf = calloc(new_cap, sizeof_TSET_ELEM);
    u64!(self + TSET_buffer, new_buf);
    var i = 0; var elt;
    while i < old_cap do
        elt = cast(u64@(old_buf + i * sizeof_TSET_ELEM), ptr);
        if elt then
            set_add(self, elt);
        end
        i += 1;
    end
    free(old_buf);
end

def _set_at self: set, idx: int -> ptr in
    var buf = set_buffer(self);
    return buf + idx * sizeof_TSET_ELEM;
end

def set_contains self: set, elem: ptr -> bool in
    var cap = set_cap(self);
    var hasher = set_hasher(self); 
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while u64@(cur) do
        if comparer(u64@(cur), elem) then
            return true;
        end
        idx = (idx + 1) % cap;
        cur = _set_at(self, idx);
    end
    return false;
end

def set_add self: set, elem: ptr in
    var cap = set_cap(self);
    if set_len(self) >= cap / SET_Load_Factor then
        _set_expand(self);
        cap = set_cap(self);
    end
    
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    end
    cur = _set_at(self, idx);
    if not u64@(cur) then
        // increment length
        u64!(self + TSET_length, u64@(self + TSET_length) + 1);
    end
    u64!(cur, elem);
end

def set_remove self: set, elem: ptr in
    var cap = set_cap(self);
    var hasher = set_hasher(self);
    var idx = hasher(elem) % cap;
    if idx < 0 then idx = 0 - idx; end
    var comparer = set_comparer(self);
    var cur = _set_at(self, idx);
    while cur and u64@(cur) do
        if comparer(u64@(cur), elem) then
            cur = NULL;
        else
            idx = (idx + 1) % cap;
            cur = _set_at(self, idx);
        end
    end
    cur = _set_at(self, idx);
    if u64@(cur) then
        // decrement length
        u64!(self + TSET_length, u64@(self + TSET_length) - 1);
    end
    u64!(cur, NULL);
end

def set_end self: set -> set_iterator in
    return cast(_set_at(self, set_cap(self)), set_iterator);
end

def set_begin self: set -> set_iterator in
    var cur = _set_at(self, 0);
    var end_ = set_end(self);
    if set_len(self) == 0 then
        return end_;
    end
    while cur != end_ do
        if u64@(cur) then
            return cast(cur, set_iterator);
        end
        cur = cur + sizeof_TSET_ELEM;
    end
    return end_;
end

def set_next self: set, iter: set_iterator -> set_iterator in
    iter = cast(cast(iter, ptr) + sizeof_TSET_ELEM, set_iterator);
    var end_ = set_end(self);
    while iter != end_ do
        if u64@(iter) then
            return cast(iter, set_iterator);
        end
        iter = cast(cast(iter, ptr) + sizeof_TSET_ELEM, set_iterator);
    end
    return end_;
end

def set_reset self: set in
    if u64@(self + TSET_length) != 0 then
        u64!(self + TSET_length, 0);
        memset(set_buffer(self), 0, set_cap(self) * sizeof_TSET_ELEM);
    end
end
