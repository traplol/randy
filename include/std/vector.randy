
#include string
#include core

const TVECTOR_buffer = TSTRING_buffer;
const TVECTOR_length = TSTRING_length;
const TVECTOR_capacity = TSTRING_capacity;
const sizeof_TVECTOR = sizeof_TSTRING;
const sizeof_TVECTOR_ELEMENT = sizeof_PTR;

proc make_vector init in
    var self = make_string(init * sizeof_TVECTOR_ELEMENT);
    return self;
end

proc free_vector self in
    free_string(self);
end

proc vector_buf self in
    return u64@(self);
end

proc vector_len self in
    return u64@(self + TVECTOR_length) / sizeof_TVECTOR_ELEMENT;
end

proc vector_cap self in
    return u64@(self + TVECTOR_capacity) / sizeof_TVECTOR_ELEMENT;
end

proc vector_get self, idx in
    // TODO: Bounds check & abort
    return u64@(u64@(self) + (idx * sizeof_TVECTOR_ELEMENT));
end

proc vector_set self, idx, val in
    // TODO: Bounds check & abort
    u64!(u64@(self) + (idx * sizeof_TVECTOR_ELEMENT), val);
end

proc vector_resize self, new_cap in
    string_resize(self, new_cap * sizeof_TVECTOR_ELEMENT);
end

proc vector_push self, val in
    var len = string_len(self);
    var cap = string_cap(self);
    if len >= cap then
        string_resize(self, (2 * cap) + sizeof_TVECTOR_ELEMENT);
    end
    u64!(u64@(self) + len, val);
    u64!(self + TVECTOR_length, len + sizeof_TVECTOR_ELEMENT);
end

proc vector_pop self in
    var len = string_len(self);
    if len > 0 then
        u64!(self + TVECTOR_length, len - sizeof_TVECTOR_ELEMENT);
    else
        printf("ERROR: vector_pop out of bounds.\n");
        abort();
    end
end

proc vector_back self in
    var len = vector_len(self);
    if len > 0 then
        return u64@(u64@(self) + ((len - 1) * sizeof_TVECTOR_ELEMENT));
    end
    printf("ERROR: vector_back out of bounds.\n");
    abort();
end

proc vector_set_len self, len in
    string_set_len(self, len * sizeof_TVECTOR_ELEMENT);
end
