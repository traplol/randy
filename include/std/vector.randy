
#include string
#include core

const sizeof_TVECTOR_ELEMENT = sizeof_PTR;

struct Vector in
    buffer: ptr;
    length: int;
    capacity: int;

    def new init: int -> Vector& in
        var self = cast(malloc(__sizeof(Vector)), Vector&);
        self.buffer = malloc(sizeof_TVECTOR_ELEMENT * init);
        self.length = 0;
        self.capacity = init;
        return self;
    end

    def delete self: Vector& in
        if self then
            free(self.buffer);
            free(self);
        end
    end

    def get self: Vector&, idx: int -> ptr in
        // TODO: Bounds check & abort
        return cast(u64@(self.buffer + (idx * sizeof_TVECTOR_ELEMENT)), ptr);
    end

    def set self: Vector&, idx: int, val: ptr in
        // TODO: Bounds check & abort
        u64!(self.buffer + (idx * sizeof_TVECTOR_ELEMENT), val);
    end

    def resize self: Vector&, new_cap: int in
        var new = malloc(new_cap * sizeof_TVECTOR_ELEMENT);
        var old = self.buffer;
        var len = self.length;
        if new_cap < len then
            len = new_cap;
        end
        memcpy(new, old, len * sizeof_TVECTOR_ELEMENT);
        free(old);
        self.buffer = new;
        self.length = len;
        self.capacity = new_cap;
    end

    def push self: Vector&, val: ptr in
        var len = self.length;
        var cap = self.capacity;
        if len >= cap then
            self.resize(2 * cap + 1);
        end
        u64!(self.buffer + len * sizeof_TVECTOR_ELEMENT, val);
        self.length = len + 1;
    end

    def pop self: Vector& in
        var len = self.length;
        if len > 0 then
            self.length = len - 1;
        else
            printf("ERROR: vector_pop out of bounds.\n");
            abort();
        end
    end

    def back self: Vector& -> ptr in
        var len = self.length;
        if len > 0 then
            return cast(u64@(self.buffer + ((len - 1) * sizeof_TVECTOR_ELEMENT)), ptr);
        end
        printf("ERROR: vector_back out of bounds.\n");
        abort();
    end

    def front self: Vector& -> ptr in
        if self.length > 0 then
            return cast(u64@(self.buffer), ptr);
        end
        printf("ERROR: vector_front out of bounds.\n");
        abort();
    end

    def insert_front self: Vector&, val: ptr in
        var len = self.length;
        var cap = self.capacity;
        if len >= cap then
            self.resize(2 * cap + 1);
        end

        if len == 0 then
            u64!(self.buffer, val);
            self.length = 1;
            return;
        end

        var buf = self.buffer;
        var tmp = u64@(buf + sizeof_TVECTOR_ELEMENT);
        var x = u64@(buf);
        u64!(buf + sizeof_TVECTOR_ELEMENT, x);
        while len > 1 do
            buf += sizeof_TVECTOR_ELEMENT;
            x = tmp;
            tmp = u64@(buf + sizeof_TVECTOR_ELEMENT);
            u64!(buf + sizeof_TVECTOR_ELEMENT, x);
            len -= 1;
        end
        u64!(self.buffer, val);
        self.length += 1;
    end
end
