
#include core
#include memory

const sizeof_TQUEUE_ELEM = sizeof_PTR;
struct Queue in
    buffer: ptr;
    head: int;
    tail: int;
    capacity: int;

    def new init: int -> Queue& in
        if init <= 0 then
            init = 16;
        end

        var self = cast(malloc(__sizeof(Queue)), Queue&);
        var buf = malloc(init * sizeof_TQUEUE_ELEM);
        self.buffer = buf;
        self.head = 0;
        self.tail = 0;
        self.capacity = init;
        return self;
    end

    def delete self: Queue& in
        if self then
            free(self.buffer);
            free(self);
        end
    end

    def resize self: Queue&, new_cap: int in
        var old_buf = self.buffer;
        var old_cap = self.capacity;
        if new_cap == old_cap then
            return;
        elif new_cap < old_cap then
            printf("queue:resize: shrinking queue unsupported.\n");
            abort();
        end
        var new_buf = malloc(new_cap * sizeof_TQUEUE_ELEM);
        var head = self.head;
        var tail = self.tail;

        if tail - head > 0 then
            memcpy(new_buf, old_buf + head, (tail - head) * sizeof_TQUEUE_ELEM);
        end

        self.head = 0;
        self.tail = tail - head;
        self.buffer = new_buf;
        self.capacity = new_cap;
        free(old_buf);
    end

    def enqueue self: Queue&, elem: ptr in
        var tail = self.tail;
        var cap = self.capacity;
        if tail == cap then
            self.resize(cap * 2 + 1);
        end

        var buf = self.buffer;
        u64!(buf + tail * sizeof_TQUEUE_ELEM, elem);
        self.tail += 1;
    end

    def dequeue self: Queue& -> ptr in
        var head = self.head;
        var tail = self.tail;
        if head == tail then
            printf("queue_dequeue: queue empty!\n");
            abort();
        end

        var val = cast(u64@(self.buffer + head * sizeof_TQUEUE_ELEM), ptr);
        if head + 1 == tail then
            self.head = 0;
            self.tail = 0;
        else
            self.head += 1;
        end
        return val;
    end

    def peek self: Queue& -> ptr in
        var head = self.head;
        var tail = self.tail;
        if head == tail then
            printf("peek: queue empty!\n");
            abort();
        end

        return cast(u64@(self.buffer + head * sizeof_TQUEUE_ELEM), ptr);
    end

    def reset self: Queue& in
        self.head = 0;
        self.tail = 0;
    end

    def length self: Queue& -> int in
        return self.tail - self.head;
    end
end
