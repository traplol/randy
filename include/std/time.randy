#include core
#include syscall
#include memory

const TTIMESPEC_tv_sec  = 0;
const TTIMESPEC_tv_nsec = 8;
const sizeof_TTIMESPEC = 16;

proc make_timespec sec, nsec in
    var self = malloc(sizeof_TTIMESPEC);
    u64!(self + TTIMESPEC_tv_sec, sec);
    u64!(self + TTIMESPEC_tv_nsec, nsec);
    return self;
end

proc make_empty_timespec in
    return malloc(sizeof_TTIMESPEC);
end

proc free_timespec self in
    free(self);
end

proc timespec_sec self in
    return cast(u64@(self + TTIMESPEC_tv_sec), int);
end

proc timespec_set_sec self, val in
    u64!(self + TTIMESPEC_tv_sec, val);
end

proc timespec_nsec self in
    return cast(u64@(self + TTIMESPEC_tv_nsec), int);
end

proc timespec_set_nsec self, val in
    u64!(self + TTIMESPEC_tv_nsec, val);
end

const CLOCK_REALTIME      = 0;
const CLOCK_MONOTONIC_RAW = 4;

proc time timespec in
    return syscall(SYS_clock_gettime, CLOCK_MONOTONIC_RAW, timespec);
end

proc clock timespec in
    return syscall(SYS_clock_gettime, CLOCK_REALTIME, timespec);
end

const CLOCK_US_PER_NS = 1000;
const CLOCK_MS_PER_US = 1000;
const CLOCK_S_PER_MS  = 1000;
const CLOCK_S_PER_US  = CLOCK_S_PER_MS * CLOCK_MS_PER_US;
const CLOCK_NS_BOUNDS = CLOCK_S_PER_MS * CLOCK_MS_PER_US * CLOCK_US_PER_NS;

proc usleep usec in
    if usec < 0 then
        return;
    end
    var sec = usec / CLOCK_S_PER_US;
    var rem = usec % CLOCK_S_PER_US;
    var sleeptime = make_timespec(sec, rem * CLOCK_US_PER_NS);
    var remtime = make_empty_timespec();
    syscall(SYS_nanosleep, sleeptime, remtime);
    free_timespec(sleeptime);
    free_timespec(remtime);
end
