#include core
#include string
#include vector

proc read_file_to_string path in
    var fd = open_for_read(path);
    if fd < 0 then
        printf("Error reading file: (%d) %s\n", fd, path);
        return NULL;
    end
    
    var buf = malloc(1024);
    var running = 1;
    var result = 0;
    var string = make_string(64);
    var x = 0;
    while running do
        result = read_file(fd, buf, 1023);
        if result < 0 then
            running = 0;
            printf("error reading file: %d\n", result);
            free(buf);
            free_string(string);
            return NULL;
        else if result == 0 then
            running = 0;
        else
            x = 0;
            while x < result do
                string_push(string, u8@(buf+x));
                x = x + 1;
            done
        end
    done
    free(buf);

    string_push(string, 0);
    return string;
end

////////////////////////////////////////////////////////////////////////////////
//                                   TOKENS
// Token Kinds
const TK_Integer = 0;
const TK_String = 1;
const TK_Char = 2;
const TK_Ident = 3;
const TK_KW_proc = 4;
const TK_KW_do = 5;
const TK_KW_var = 6;
const TK_KW_in = 7;
const TK_KW_if = 8;
const TK_KW_else = 9;
const TK_KW_then = 10;
const TK_KW_end = 11;
const TK_KW_while = 12;
const TK_KW_done = 13;
const TK_KW_return = 14;
const TK_KW_and = 15;
const TK_KW_or = 16;
const TK_KW_not = 17;
const TK_KW_u8@ = 18;
const TK_KW_u16@ = 19;
const TK_KW_u32@ = 20;
const TK_KW_u64@ = 21;
const TK_KW_u8! = 22;
const TK_KW_u16! = 23;
const TK_KW_u32! = 24;
const TK_KW_u64! = 25;
const TK_KW_const = 26;
const TK_KW_extern = 27;
const TK_KW_asm = 28;
const TK_Plus = 29;
const TK_Minus = 30;
const TK_Star = 31;
const TK_Slash = 32;
const TK_Percent = 33;
const TK_Semicolon = 34;
const TK_Less = 35;
const TK_LessEq = 36;
const TK_Greater = 37;
const TK_GreaterEq = 38;
const TK_Assign = 39;
const TK_EqEq = 40;
const TK_NotEq = 41;
const TK_Tilde = 42;
const TK_Comma = 43;
const TK_LParen = 44;
const TK_RParen = 45;
const TK_Bar = 46;
const TK_Amper = 47;
const TK_Caret = 48;
const TK_Ellipsis = 49;
const TK_MAX_VAL = 50;

proc token_kind_cstr k in
    if k < 0 or k >= TK_MAX_VAL then return "TK_OUT_OF_RANGE";
    else if k == TK_Integer then return "TK_Integer";
    else if k == TK_String then return "TK_String";
    else if k == TK_Char then return "TK_Char";
    else if k == TK_Ident then return "TK_Ident";
    else if k == TK_KW_proc then return "TK_KW_proc";
    else if k == TK_KW_do then return "TK_KW_do";
    else if k == TK_KW_var then return "TK_KW_var";
    else if k == TK_KW_in then return "TK_KW_in";
    else if k == TK_KW_if then return "TK_KW_if";
    else if k == TK_KW_else then return "TK_KW_else";
    else if k == TK_KW_then then return "TK_KW_then";
    else if k == TK_KW_end then return "TK_KW_end";
    else if k == TK_KW_while then return "TK_KW_while";
    else if k == TK_KW_done then return "TK_KW_done";
    else if k == TK_KW_return then return "TK_KW_return";
    else if k == TK_KW_and then return "TK_KW_and";
    else if k == TK_KW_or then return "TK_KW_or";
    else if k == TK_KW_not then return "TK_KW_not";
    else if k == TK_KW_u8@ then return "TK_KW_u8@";
    else if k == TK_KW_u16@ then return "TK_KW_u16@";
    else if k == TK_KW_u32@ then return "TK_KW_u32@";
    else if k == TK_KW_u64@ then return "TK_KW_u64@";
    else if k == TK_KW_u8! then return "TK_KW_u8!";
    else if k == TK_KW_u16! then return "TK_KW_u16!";
    else if k == TK_KW_u32! then return "TK_KW_u32!";
    else if k == TK_KW_u64! then return "TK_KW_u64!";
    else if k == TK_KW_const then return "TK_KW_const";
    else if k == TK_KW_extern then return "TK_KW_extern";
    else if k == TK_KW_asm then return "TK_KW_asm";
    else if k == TK_Plus then return "TK_Plus";
    else if k == TK_Minus then return "TK_Minus";
    else if k == TK_Star then return "TK_Star";
    else if k == TK_Slash then return "TK_Slash";
    else if k == TK_Percent then return "TK_Percent";
    else if k == TK_Semicolon then return "TK_Semicolon";
    else if k == TK_Less then return "TK_Less";
    else if k == TK_LessEq then return "TK_LessEq";
    else if k == TK_Greater then return "TK_Greater";
    else if k == TK_GreaterEq then return "TK_GreaterEq";
    else if k == TK_Assign then return "TK_Assign";
    else if k == TK_EqEq then return "TK_EqEq";
    else if k == TK_NotEq then return "TK_NotEq";
    else if k == TK_Tilde then return "TK_Tilde";
    else if k == TK_Comma then return "TK_Comma";
    else if k == TK_LParen then return "TK_LParen";
    else if k == TK_RParen then return "TK_RParen";
    else if k == TK_Bar then return "TK_Bar";
    else if k == TK_Amper then return "TK_Amper";
    else if k == TK_Caret then return "TK_Caret";
    else if k == TK_Ellipsis then return "TK_Ellipsis";
    end
end

const TTOKEN_kind = 0;
const TTOKEN_cstr = 8;
const TTOKEN_value = 16;
const TTOKEN_line = 24;
const TTOKEN_filename = 32;
const sizeof_TTOKEN = 40;

proc make_token kind, cstr, value, line, filename in
    if kind < 0 or kind >= TK_MAX_VAL then
        printf("make_token kind out of range: %d\n", kind);
        exit(1);
    end

    var token = malloc(sizeof_TTOKEN);
    u64!(token + TTOKEN_kind, kind);
    u64!(token + TTOKEN_cstr, cstr);
    u64!(token + TTOKEN_value, value);
    u64!(token + TTOKEN_line, line);
    u64!(token + TTOKEN_filename, filename);
    return token;
end

proc free_token token in
    free(token);
end

proc token_kind token in
    return u64@(token + TTOKEN_kind);
end

proc token_cstr token in
    return u64@(token + TTOKEN_cstr);
end

proc token_value token in
    return u64@(token + TTOKEN_value);
end

proc token_line token in
    return u64@(token + TTOKEN_line);
end

proc token_filename token in
    return u64@(token + TTOKEN_filename);
end

proc print_token token in
    var k = token_kind(token);
    printf("token: %s -> '%s' = ", token_kind_cstr(k)
                                 , token_cstr(token));

    var v = token_value(token);
    if k == TK_Integer then
        printf("%d\n", v);
    else if k == TK_String then
        printf("\"%s\"\n", string_cstr(v));
    else if k == TK_Char then
        printf("'%c'\n", v);
    else
        printf("%s\n", v);
    end
end

proc print_token_loc token in
    var line_no = token_line(token);
    var filename = token_filename(token);
    printf("  File \"%s\", line %d\n", filename, line_no);
end

////////////////////////////////////////////////////////////////////////////////
//                                  LEXER

proc is_digit c in
    return '0' <= c and c <= '9';
end

proc is_whitespace c in
    return c == ' ' or c == '\t' or c == '\n' or c == 0;
end

proc is_ident_start c in
    return c == '_' or ('a' <= c and c <= 'z') or ('A' <= c and c <= 'Z');
end

proc is_ident_char c in
    return is_ident_start(c) or is_digit(c) or c == '@' or c == '!';
end

proc get_escaped_char c in
    if c == 't' then
        return 9; // \t tab
    else if c == 'n' then
        return 10; // \n newline
    else if c == 'r' then
        return 13; // \r carriage return
    else if c == '0' then
        return 0; // \0 null character
    end
    return c;
end

proc get_ident_kind string in
    var cstr = string_cstr(string);
    var first = u8@(cstr);
    if 'a' == first then
        if cstr_eq("asm", cstr) then return TK_KW_asm; end
        if cstr_eq("and", cstr) then return TK_KW_and; end
    else if 'c' == first then
        if cstr_eq("const", cstr) then return TK_KW_const; end
    else if 'd' == first then
        if cstr_eq("do", cstr) then return TK_KW_do; end
        if cstr_eq("done", cstr) then return TK_KW_done; end
    else if 'e' == first then
        if cstr_eq("else", cstr) then return TK_KW_else; end
        if cstr_eq("end", cstr) then return TK_KW_end; end
        if cstr_eq("extern", cstr) then return TK_KW_extern; end
    else if 'i' == first then
        if cstr_eq("in", cstr) then return TK_KW_in; end
        if cstr_eq("if", cstr) then return TK_KW_if; end
    else if 'n' == first then
        if cstr_eq("not", cstr) then return TK_KW_not; end
    else if 'o' == first then
        if cstr_eq("or", cstr) then return TK_KW_or; end
    else if 'p' == first then
        if cstr_eq("proc", cstr) then return TK_KW_proc; end
    else if 'r' == first then
        if cstr_eq("return", cstr) then return TK_KW_return; end
    else if 't' == first then
        if cstr_eq("then", cstr) then return TK_KW_return; end
    else if 'u' == first then
        if cstr_eq("u8@", cstr) then return TK_KW_u8@; end
        if cstr_eq("u16@", cstr) then return TK_KW_u16@; end
        if cstr_eq("u32@", cstr) then return TK_KW_u32@; end
        if cstr_eq("u64@", cstr) then return TK_KW_u64@; end

        if cstr_eq("u8!", cstr) then return TK_KW_u8!; end
        if cstr_eq("u16!", cstr) then return TK_KW_u16!; end
        if cstr_eq("u32!", cstr) then return TK_KW_u32!; end
        if cstr_eq("u64!", cstr) then return TK_KW_u64!; end
    else if 'w' == first then
        if cstr_eq("while", cstr) then return TK_KW_while; end
    end
    return TK_Ident;
end

proc int_from_string string in
    var result = 0;
    var i = string_len(string) - 1;
    var k = 1;
    var c;
    while i >= 0 do
        c = string_get(string, i);
        if not is_digit(c) then
            i = 0;
        else
            result = result + (c - '0') * k;
            k = k * 10;
        end
        i = i - 1;
    done
    return result;
end

proc lex_code filename, code in
    var i = 0;
    var tokens = make_vector(0);
    var length = string_len(code);
    var line_no = 1;
    var temp; var c; var cc; var val;
    while i < length do
        // Consume whitespace
        while i < length and is_whitespace(string_get(code, i)) do
            if string_get(code, i) == '\n' then
                line_no = line_no + 1;
            end
            i = i + 1;
        done

        if i < length then
            c = string_get(code, i);
            if c == '/' and i+1 < length and string_get(code, i+1) == '/' then
                while i < length and string_get(code, i) != '\n' do
                    i = i + 1;
                done
            else if is_ident_start(c) then
                temp = make_string(2);
                string_push(temp, c);
                while i < length and is_ident_char(c) do
                   i = i + 1;
                   c = string_get(code, i);
                   if is_ident_char(c) then
                       string_push(temp, c);
                   end
                done
                vector_push(tokens, make_token(get_ident_kind(temp), string_cstr(temp), string_cstr(temp), line_no, filename));
            else if is_digit(c) then
                temp = make_string(2);
                string_push(temp, c);
                while i < length and is_digit(c) do
                   i = i + 1;
                   c = string_get(code, i);
                   if is_digit(c) then
                       string_push(temp, c);
                   end
                done
                val = int_from_string(temp);
                vector_push(tokens, make_token(TK_Integer, string_cstr(temp), val, line_no, filename));
            else if c == '"' then
                temp = make_string(2);
                i = i + 1; // skip open quote
                while i < length and string_get(code, i) != '"' do
                    c = string_get(code, i);
                    if c == '\\' then
                        i = i + 1; // skip \
                        c = string_get(code, i);
                        c = get_escaped_char(c);
                    else if c == '\n' then
                        line_no = line_no + 1;
                    end
                    string_push(temp, c);
                    i = i + 1;
                done
                i = i + 1; // skip close quote
                vector_push(tokens, make_token(TK_String, string_cstr(temp), temp, line_no, filename));
            else if c == '\'' then
                temp = make_string(2);
                i = i + 1; // skip open quote
                c = string_get(code, i);
                if c == '\\' then
                    i = i + 1; // skip \
                    c = string_get(code, i);
                    c = get_escaped_char(c);
                else if cc == '\n' then
                    line_no = line_no + 1;
                end
                string_push(temp, c);
                i = i + 2; // skip char and close quote
                vector_push(tokens, make_token(TK_Char, string_cstr(temp), c, line_no, filename));
            else if c == '#' then
                while i < length and string_get(code, i) != '\n' do
                    i = i + 1;
                done
            else if c == ';' then
                vector_push(tokens, make_token(TK_Semicolon, ";", ";", line_no, filename));
                i = i + 1;
            else if c == ',' then
                vector_push(tokens, make_token(TK_Comma, ",", ",", line_no, filename));
                i = i + 1;
            else if c == '(' then
                vector_push(tokens, make_token(TK_LParen, "(", "(", line_no, filename));
                i = i + 1;
            else if c == ')' then
                vector_push(tokens, make_token(TK_RParen, ")", ")", line_no, filename));
                i = i + 1;
            else if c == '+' then
                vector_push(tokens, make_token(TK_Plus, "+", "+", line_no, filename));
                i = i + 1;
            else if c == '-' then
                vector_push(tokens, make_token(TK_Minus, "-", "-", line_no, filename));
                i = i + 1;
            else if c == '*' then
                vector_push(tokens, make_token(TK_Star, "*", "*", line_no, filename));
                i = i + 1;
            else if c == '/' then
                vector_push(tokens, make_token(TK_Slash, "/", "/", line_no, filename));
                i = i + 1;
            else if c == '%' then
                vector_push(tokens, make_token(TK_Percent, "%", "%", line_no, filename));
                i = i + 1;
            else if c == '|' then
                vector_push(tokens, make_token(TK_Bar, "|", "|", line_no, filename));
                i = i + 1;
            else if c == '&' then
                vector_push(tokens, make_token(TK_Amper, "&", "&", line_no, filename));
                i = i + 1;
            else if c == '^' then
                vector_push(tokens, make_token(TK_Caret, "^", "^", line_no, filename));
                i = i + 1;
            else if c == '~' then
                vector_push(tokens, make_token(TK_Tilde, "~", "~", line_no, filename));
                i = i + 1;
            else if c == '.' then
                if i+2 < length and string_get(code, i+1) == '.' and string_get(code, i+2) == '.' then
                    vector_push(tokens, make_token(TK_Ellipsis, "...", "...", line_no, filename));
                    i = i + 3;
                end
            else if c == '!' then
                if i+1 < length and string_get(code, i+1) == '=' then
                    vector_push(tokens, make_token(TK_NotEq, "!=", "!=", line_no, filename));
                    i = i + 2;
                else
                    printf("Unrecognized character: '%c' (%d) on line %d\n", c, c, line_no);
                    exit(1);
                end
            else if c == '<' then
                if i+1 < length and string_get(code, i+1) == '=' then
                    vector_push(tokens, make_token(TK_LessEq, "<=", "<=", line_no, filename));
                    i = i + 2;
                else
                    vector_push(tokens, make_token(TK_Less, "<", "<", line_no, filename));
                    i = i + 1;
                end
            else if c == '>' then
                if i+1 < length and string_get(code, i+1) == '=' then
                    vector_push(tokens, make_token(TK_GreaterEq, ">=", ">=", line_no, filename));
                    i = i + 2;
                else
                    vector_push(tokens, make_token(TK_Greater, ">", ">", line_no, filename));
                    i = i + 1;
                end
            else if c == '=' then
                if i+1 < length and string_get(code, i+1) == '=' then
                    vector_push(tokens, make_token(TK_EqEq, "==", "==", line_no, filename));
                    i = i + 2;
                else
                    vector_push(tokens, make_token(TK_Assign, "=", "=", line_no, filename));
                    i = i + 1;
                end
            else
                printf("Unrecognized character: '%c' (%d)\n", c, c);
                printf("  File \"%s\", line %d", filename, line_no);
                exit(1);
            end
        end
    done
    return tokens;
end

proc lex_file path in
    var code = read_file_to_string(path);
    if not code then
        return NULL;
    end
    return lex_code(path, code);
end

////////////////////////////////////////////////////////////////////////////////
//                                TOKEN STREAM
const TTOKEN_STREAM_tokens = 0;
const TTOKEN_STREAM_idx = 8;
const sizeof_TTOKEN_STREAM = 16;

proc make_token_stream tokens in
    var token_stream = malloc(sizeof_TTOKEN_STREAM);
    u64!(token_stream + TTOKEN_STREAM_tokens, tokens);
    u64!(token_stream + TTOKEN_STREAM_idx, 0);
    return token_stream;
end

proc ts_tokens self in
    return u64@(self + TTOKEN_STREAM_tokens);
end

proc ts_idx self in
    return u64@(self + TTOKEN_STREAM_idx);
end

proc ts_peek self in
    var tks = ts_tokens(self);
    var idx = ts_idx(self);
    if idx >= vector_len(tks) then
        return NULL;
    end
    return vector_get(tks, idx);
end

proc ts_peekk self, kind in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end

    return token_kind(peek) == kind;
end

proc ts_peekk_one_of_2 self, k1, k2 in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2;
end

proc ts_peekk_one_of_3 self, k1, k2, k3 in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3;
end

proc ts_peekk_one_of_4 self, k1, k2, k3, k4 in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3 or tk == k4;
end

proc ts_peekk_one_of_5 self, k1, k2, k3, k4, k5 in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3 or tk == k4 or tk == k5;
end

proc ts_next self in
    var peek = ts_peek(self);
    u64!(self + TTOKEN_STREAM_idx, u64@(self + TTOKEN_STREAM_idx) + 1);
    return peek;
end

proc ts_accept self, kind in
    var tmp = ts_peek(self);
    if tmp and token_kind(tmp) == kind then
        return ts_next(self);
    end
    return NULL;
end

proc ts_expect self, kind in
    var tmp = ts_peek(self);
    if not tmp then
        printf("ERROR: Expected token kind %s but ran out of tokens.\n", token_kind_cstr(kind));
        exit(1);
    end
    var tmp_k = token_kind(tmp);
    if tmp_k != kind then
        printf("ERROR: Expected token kind %s, got %s\n",
            token_kind_cstr(kind),
            token_kind_cstr(tmp_k));
        print_token_loc(tmp);
        exit(1);
    end
    ts_next(self);
    return tmp;
end

proc main argc, argv in
    if argc < 2 then
        printf("No input file.\n");
    else
        var path = u64@(argv + sizeof_PTR);
        var tokens = lex_file(path);
        if not tokens then
            return 1;
        end

        var tokstr = make_token_stream(tokens);

        ts_expect(tokstr, TK_Plus);
        ts_expect(tokstr, TK_Minus);
        ts_expect(tokstr, TK_Slash);
        ts_expect(tokstr, TK_Star);
        printf("Accept String: %p\n", ts_accept(tokstr, TK_String));
        printf("Accept Ident: %p\n", ts_accept(tokstr, TK_Ident));
        // while ts_peek(tokstr) do
        //     var token = ts_peek(tokstr);
        //     print_token(token);
        //     ts_next(tokstr);
        // done
    end
end

