
const AstK_Ident     = 0;
const AstK_Integer   = 1;
const AstK_String    = 2;
const AstK_Call      = 3;
const AstK_BinOp     = 4;
const AstK_Return    = 5;
const AstK_VarDecl   = 6;
const AstK_VarAssign = 7;
const AstK_Assign    = 8;
const AstK_Procedure = 9;
const AstK_IfElse    = 10;
const AstK_While     = 11;
const AstK_PointerOp = 12;
const AstK_Prefix    = 13;
const AstK_Const     = 14;
const AstK_Extern    = 15;
const AstK_InlineAsm = 16;

proc ast_kind_cstr k in
    if k == AstK_Ident then return "AstK_Ident"; end
    if k == AstK_Integer then return "AstK_Integer"; end
    if k == AstK_String then return "AstK_String"; end
    if k == AstK_Call then return "AstK_Call"; end
    if k == AstK_BinOp then return "AstK_BinOp"; end
    if k == AstK_Return then return "AstK_Return"; end
    if k == AstK_VarDecl then return "AstK_VarDecl"; end
    if k == AstK_VarAssign then return "AstK_VarAssign"; end
    if k == AstK_Assign then return "AstK_Assign"; end
    if k == AstK_Procedure then return "AstK_Procedure"; end
    if k == AstK_IfElse then return "AstK_IfElse"; end
    if k == AstK_While then return "AstK_While"; end
    if k == AstK_PointerOp then return "AstK_PointerOp"; end
    if k == AstK_Prefix then return "AstK_Prefix"; end
    if k == AstK_Const then return "AstK_Const"; end
    if k == AstK_Extern then return "AstK_Extern"; end
    if k == AstK_InlineAsm then return "AstK_InlineAsm"; end
    return "AstK_OUT_OF_RANGE";
end

const TAST_kind        = 0;  // AstK
const TAST_token       = 8;  // token
// This represents each AST node as a c-"union"
// Ident
const TAST_ident       = 16; // string
// Integer, String
const TAST_value       = 16; // Union(int, string)
// Call
const TAST_expr        = 16; // ast
const TAST_args        = 24; // ast vector
// Prefix
const TAST_expr        = 16; // ast
const TAST_op          = 24; // TK
// BinOp
const TAST_lhs         = 16; // ast
const TAST_op          = 24; // TK
const TAST_rhs         = 32; // ast
// IfElse
const TAST_test        = 16; // ast
const TAST_consequence = 24; // ast vector
const TAST_alternative = 32; // ast vector
// While
const TAST_test        = 16; // ast
const TAST_body        = 24; // ast vector
// PointerOp
const TAST_size        = 16; // int
const TAST_op          = 24; // TK
const TAST_pop_args    = 32; // ast vector
// VarDecl
const TAST_ident       = 16; // string
// VarAssign
const TAST_ident       = 16; // string
const TAST_assign_expr = 24; // ast
// Assign
const TAST_ident       = 16; // string
const TAST_assign_expr = 24; // ast
// Return
const TAST_expr        = 16; // ast
// Procedure
const TAST_ident       = 16; // string
const TAST_body        = 24; // ast vector
const TAST_params      = 32; // string vector
// Const
const TAST_ident       = 16; // string
const TAST_val_tok     = 24; // token
// Extern
const TAST_ident       = 16; // string
const TAST_varargs     = 24; // bool
const TAST_params      = 32; // string vector
// InlineAsm
const TAST_ident       = 16; // string
const TAST_asm         = 24; // string

const sizeof_TAST      = 40;

proc make_ast_ident token, ident in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Ident);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_integer token, value in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Integer);
    u64!(self + TAST_token, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_string token, value in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_String);
    u64!(self + TAST_token, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_call token, expr, args in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Call);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_args, args);
    return self;
end

proc make_ast_binop token, lhs, op, rhs in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_BinOp);
    u64!(self + TAST_token, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

proc make_ast_return token, expr in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Return);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    return self;
end

proc make_ast_var_decl token, ident in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_VarDecl);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_var_assign token, ident, expr in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_VarAssign);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_assign token, ident, expr in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Assign);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_procedure token, ident, params, body in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Procedure);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_body, body);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_if_else token, test, conseq, altern in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_IfElse);
    u64!(self + TAST_token, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_consequence, conseq);
    u64!(self + TAST_alternative, altern);
    return self;
end

proc make_ast_while token, test, body in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_While);
    u64!(self + TAST_token, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_body, body);
    return self;
end

proc make_ast_pointer_op token, size, op, args in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_PointerOp);
    u64!(self + TAST_token, token);
    u64!(self + TAST_size, size);
    u64!(self + TAST_op, op);
    u64!(self + TAST_pop_args, args);
    return self;
end

proc make_ast_prefix token, op, expr in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Prefix);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_op, op);
    return self;
end

proc make_ast_const token, ident, val_tok in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Const);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_val_tok, val_tok);
    return self;
end

proc make_ast_extern token, ident, params, varargs in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Extern);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_varargs, varargs);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_inline_asm token, ident, asmcode in
    var self= malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_InlineAsm);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_asm, asmcode);
    return self;
end

proc ast_kind self in return u64@(self + TAST_kind); end
proc ast_token self in return u64@(self + TAST_token); end
proc ast_alternative self in return u64@(self + TAST_alternative); end
proc ast_args self in return u64@(self + TAST_args); end
proc ast_asm self in return u64@(self + TAST_asm); end
proc ast_assign_expr self in return u64@(self + TAST_assign_expr); end
proc ast_body self in return u64@(self + TAST_body); end
proc ast_consequence self in return u64@(self + TAST_consequence); end
proc ast_expr self in return u64@(self + TAST_expr); end
proc ast_ident self in return u64@(self + TAST_ident); end
proc ast_lhs self in return u64@(self + TAST_lhs); end
proc ast_op self in return u64@(self + TAST_op); end
proc ast_params self in return u64@(self + TAST_params); end
proc ast_pop_args self in return u64@(self + TAST_pop_args); end
proc ast_rhs self in return u64@(self + TAST_rhs); end
proc ast_size self in return u64@(self + TAST_size); end
proc ast_test self in return u64@(self + TAST_test); end
proc ast_val_tok self in return u64@(self + TAST_val_tok); end
proc ast_value self in return u64@(self + TAST_value); end
proc ast_varargs self in return u64@(self + TAST_varargs); end

proc ast_src_loc self in
    var token = ast_token(self);
    return token_src_loc(token);
end

    