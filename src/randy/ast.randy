
const PointerOp_Read  = 0;
const PointerOp_Write = 1;

const AstK_Ident        = 0;
const AstK_Integer      = 1;
const AstK_String       = 2;
const AstK_Call         = 3;
const AstK_BinOp        = 4;
const AstK_Return       = 5;
const AstK_VarDecl      = 6;
const AstK_VarAssign    = 7;
const AstK_Assign       = 8;
const AstK_Procedure    = 9;
const AstK_IfElse       = 10;
const AstK_While        = 11;
const AstK_PointerRead  = 12;
const AstK_PointerWrite = 13;
const AstK_Prefix       = 14;
const AstK_Const        = 15;
const AstK_Extern       = 16;
const AstK_InlineAsm    = 17;
const AstK_Global       = 18;
const AstK_Break        = 19;
const AstK_Continue     = 20;
const AstK_AssignOp     = 21;

proc ast_kind_cstr k in
    if k == AstK_Ident then return "AstK_Ident"; end
    if k == AstK_Integer then return "AstK_Integer"; end
    if k == AstK_String then return "AstK_String"; end
    if k == AstK_Call then return "AstK_Call"; end
    if k == AstK_BinOp then return "AstK_BinOp"; end
    if k == AstK_Return then return "AstK_Return"; end
    if k == AstK_VarDecl then return "AstK_VarDecl"; end
    if k == AstK_VarAssign then return "AstK_VarAssign"; end
    if k == AstK_Assign then return "AstK_Assign"; end
    if k == AstK_Procedure then return "AstK_Procedure"; end
    if k == AstK_IfElse then return "AstK_IfElse"; end
    if k == AstK_While then return "AstK_While"; end
    if k == AstK_PointerRead then return "AstK_PointerRead"; end
    if k == AstK_PointerWrite then return "AstK_PointerWrite"; end
    if k == AstK_Prefix then return "AstK_Prefix"; end
    if k == AstK_Const then return "AstK_Const"; end
    if k == AstK_Extern then return "AstK_Extern"; end
    if k == AstK_InlineAsm then return "AstK_InlineAsm"; end
    if k == AstK_Global then return "AstK_Global"; end
    if k == AstK_Break then return "AstK_Break"; end
    if k == AstK_Continue then return "AstK_Continue"; end
    if k == AstK_AssignOp then return "AstK_AssignOp"; end
    return "AstK_OUT_OF_RANGE";
end

proc ast_requires_semi k in
    if k == AstK_Procedure then return false;
    else if k == AstK_IfElse then return false;
    else if k == AstK_While then return false;
    else if k == AstK_InlineAsm then return false;
    else
        return true;
    end
end

const TAST_kind        = 0;  // AstK
const TAST_token       = 8;  // token
// This represents each AST node as a c-"union"
// Ident
const TAST_ident       = 16; // cstr
// Integer, String
const TAST_value       = 16; // Union(int, string)
// Call
const TAST_expr        = 16; // ast
const TAST_args        = 24; // ast vector
// Prefix
const TAST_expr        = 16; // ast
const TAST_op          = 24; // TK
// BinOp
const TAST_lhs         = 16; // ast
const TAST_op          = 24; // TK
const TAST_rhs         = 32; // ast
// IfElse
const TAST_test        = 16; // ast
const TAST_consequence = 24; // ast vector
const TAST_alternative = 32; // ast vector
// While
const TAST_test        = 16; // ast
const TAST_body        = 24; // ast vector
// PointerRead, PointerWrite
const TAST_size        = 16; // int
const TAST_op          = 24; // int
const TAST_pop_args    = 32; // ast vector
// VarDecl
const TAST_ident       = 16; // cstr
// VarAssign
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// Assign
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// AssignOp
const TAST_ident       = 16; // cstr
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// Return
const TAST_expr        = 16; // ast
// Procedure
const TAST_ident       = 16; // cstr
const TAST_body        = 24; // ast vector
const TAST_params      = 32; // cstr vector
// Const
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// Extern
const TAST_ident       = 16; // cstr
const TAST_varargs     = 24; // bool
const TAST_params      = 32; // cstr vector
// InlineAsm
const TAST_ident       = 16; // cstr
const TAST_asm         = 24; // cstr

const sizeof_TAST      = 40;

proc make_ast_ident token, ident in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Ident);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_integer token, value in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Integer);
    u64!(self + TAST_token, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_string token, value in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_String);
    u64!(self + TAST_token, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_call token, expr, args in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Call);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_args, args);
    return self;
end

proc make_ast_binop token, lhs, op, rhs in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_BinOp);
    u64!(self + TAST_token, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

proc make_ast_return token, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Return);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    return self;
end

proc make_ast_var_decl token, ident in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_VarDecl);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_var_assign token, ident, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_VarAssign);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_assign token, ident, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Assign);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_assign_op token, ident, op, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_AssignOp);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_op, op);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_procedure token, ident, params, body in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Procedure);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_body, body);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_if_else token, test, conseq, altern in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_IfElse);
    u64!(self + TAST_token, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_consequence, conseq);
    u64!(self + TAST_alternative, altern);
    return self;
end

proc make_ast_while token, test, body in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_While);
    u64!(self + TAST_token, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_body, body);
    return self;
end

proc make_ast_pointer_op token, size, op, args in
    var self = malloc(sizeof_TAST);
    if op == PointerOp_Read then
        u64!(self + TAST_kind, AstK_PointerRead);
    else
        u64!(self + TAST_kind, AstK_PointerWrite);
    end
    u64!(self + TAST_token, token);
    u64!(self + TAST_size, size);
    u64!(self + TAST_op, op);
    u64!(self + TAST_pop_args, args);
    return self;
end

proc make_ast_prefix token, op, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Prefix);
    u64!(self + TAST_token, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_op, op);
    return self;
end

proc make_ast_const token, ident, expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Const);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_extern token, ident, params, varargs in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Extern);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_varargs, varargs);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_inline_asm token, ident, asmcode in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_InlineAsm);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_asm, asmcode);
    return self;
end

proc make_ast_global token, ident, assign_expr in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Global);
    u64!(self + TAST_token, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, assign_expr);
    return self;
end

proc make_ast_break token in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Break);
    u64!(self + TAST_token, token);
    return self;
end

proc make_ast_continue token in
    var self = malloc(sizeof_TAST);
    u64!(self + TAST_kind, AstK_Continue);
    u64!(self + TAST_token, token);
    return self;
end

proc ast_kind self in return u64@(self + TAST_kind); end
proc ast_token self in return u64@(self + TAST_token); end
proc ast_alternative self in return u64@(self + TAST_alternative); end
proc ast_args self in return u64@(self + TAST_args); end
proc ast_asm self in return u64@(self + TAST_asm); end
proc ast_assign_expr self in return u64@(self + TAST_assign_expr); end
proc ast_body self in return u64@(self + TAST_body); end
proc ast_consequence self in return u64@(self + TAST_consequence); end
proc ast_expr self in return u64@(self + TAST_expr); end
proc ast_ident self in return u64@(self + TAST_ident); end
proc ast_lhs self in return u64@(self + TAST_lhs); end
proc ast_op self in return u64@(self + TAST_op); end
proc ast_params self in return u64@(self + TAST_params); end
proc ast_pop_args self in return u64@(self + TAST_pop_args); end
proc ast_rhs self in return u64@(self + TAST_rhs); end
proc ast_size self in return u64@(self + TAST_size); end
proc ast_test self in return u64@(self + TAST_test); end
proc ast_value self in return u64@(self + TAST_value); end
proc ast_varargs self in return u64@(self + TAST_varargs); end

proc ast_src_loc self in
    var token = ast_token(self);
    return token_src_loc(token);
end

proc _print_indent indent in
    var i = 0;
    while i < indent do
        printf("    ");
        i = i + 1;
    end
end

proc _print_args args, indent in
    var i = 0;
    var len = vector_len(args);
    while i < len do
        _print_ast(vector_get(args, i), indent);
        i = i + 1;
        if i < len then
            printf(", ");
        end
    end
end

proc _print_ast_ident ast, indent in
    printf("%s", ast_ident(ast));
end

proc _print_ast_integer ast, indent in
    printf("%ld", ast_value(ast));
end

proc _print_ast_string ast, indent in
    printf("\"%s\"", string_cstr(ast_value(ast)));
end

proc _print_ast_call ast, indent in
    _print_ast(ast_expr(ast), indent);
    printf("(");
    _print_args(ast_args(ast), indent);
    printf(")");
end

proc _print_ast_binop ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf(" %s ", token_cstr(ast_token(ast)));
    _print_ast(ast_rhs(ast), indent);
end

proc _print_ast_return ast, indent in
    var expr = ast_expr(ast);
    if expr then
        printf("return ");
        _print_ast(expr, indent);
    else
        printf("return");
    end
end

proc _print_ast_var_decl ast, indent in
    printf("var %s", ast_ident(ast));
end

proc _print_ast_var_assign ast, indent in
    printf("var %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_assign ast, indent in
    printf("%s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_body body, indent in
    var i = 0;
    var len = vector_len(body);
    var stmt;
    while i < len do
        stmt = vector_get(body, i);
        _print_indent(indent);
        _print_ast(stmt, indent);
        if ast_requires_semi(ast_kind(stmt)) then
            printf(";\n");
        else
            printf("\n");
        end
        i = i + 1;
    end
end

proc _print_ast_procedure ast, indent in
    printf("proc %s", ast_ident(ast));
    var i = 0;
    var params = ast_params(ast);
    var len = vector_len(params);
    while i < len do
        printf(" %s", vector_get(params, i));
        i = i + 1;
        if i < len then
            printf(",");
        end
    end
    printf(" in\n");
    _print_ast_body(ast_body(ast), indent + 1);
    printf("end\n");
end

proc _print_ast_if_else ast, indent in
    printf("if ");
    _print_ast(ast_test(ast), indent);
    printf(" then\n");
    var conseq = ast_consequence(ast);
    var altern = ast_alternative(ast);
    _print_ast_body(conseq, indent+1);
    if vector_len(altern) > 0 then
        if vector_len(altern) == 1 and AstK_IfElse == ast_kind(vector_get(altern, 0)) then
            _print_indent(indent); printf("else ");
            _print_ast_if_else(vector_get(altern, 0), indent);
            return;
        else
            _print_indent(indent); printf("else\n");
            _print_ast_body(altern, indent+1);
        end
    end
    _print_indent(indent); printf("end");
end

proc _print_ast_while ast, indent in
    printf("while ");
    _print_ast(ast_test(ast), indent);
    printf(" do\n");
    _print_ast_body(ast_body(ast), indent+1);
    _print_indent(indent); printf("end");
end

proc _print_ast_pointer_op ast, indent in
    printf("%s(", token_cstr(ast_token(ast)));
    _print_args(ast_pop_args(ast), indent);
    printf(")");
end

proc _print_ast_prefix ast, indent in
    var token = ast_token(ast);
    if token_kind(token) == TK_KW_not then
        printf("not ");
    else
        printf("%s", token_cstr(token));
    end
    _print_ast(ast_expr(ast), indent);
end

proc _print_ast_const ast, indent in
    printf("const %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_global ast, indent in
    printf("global %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_extern ast, indent in
    printf("extern %s", ast_ident(ast));
    var i = 0;
    var params = ast_params(ast);
    var len = vector_len(params);
    while i < len do
        printf(" %s", vector_get(params, i));
        i = i + 1;
        if i < len then
            printf(",");
        end
    end
    if ast_varargs(ast) then
        if len != 0 then
            printf(", ...");
        else
            printf(", ...");
        end
    end
end

proc _print_ast_inline_asm ast, indent in
    printf("asm %s in\n", ast_ident(ast));
    printf("\"%s\"\n", ast_asm(ast));
    printf("end");
end

proc _print_ast_break ast, indent in
    printf("break");
end

proc _print_ast_continue ast, indent in
    printf("continue");
end

proc _print_ast ast, indent in
    var k = ast_kind(ast);
    if k == AstK_Ident then _print_ast_ident(ast, indent);
    else if k == AstK_Integer then _print_ast_integer(ast, indent);
    else if k == AstK_String then _print_ast_string(ast, indent);
    else if k == AstK_Call then _print_ast_call(ast, indent);
    else if k == AstK_BinOp then _print_ast_binop(ast, indent);
    else if k == AstK_Return then _print_ast_return(ast, indent);
    else if k == AstK_VarDecl then _print_ast_var_decl(ast, indent);
    else if k == AstK_VarAssign then _print_ast_var_assign(ast, indent);
    else if k == AstK_Assign then _print_ast_assign(ast, indent);
    else if k == AstK_Procedure then _print_ast_procedure(ast, indent);
    else if k == AstK_IfElse then _print_ast_if_else(ast, indent);
    else if k == AstK_While then _print_ast_while(ast, indent);
    else if k == AstK_PointerRead then _print_ast_pointer_op(ast, indent);
    else if k == AstK_PointerWrite then _print_ast_pointer_op(ast, indent);
    else if k == AstK_Prefix then _print_ast_prefix(ast, indent);
    else if k == AstK_Const then _print_ast_const(ast, indent);
    else if k == AstK_Extern then _print_ast_extern(ast, indent);
    else if k == AstK_InlineAsm then _print_ast_inline_asm(ast, indent);
    else if k == AstK_Global then _print_ast_global(ast, indent);
    else if k == AstK_Break then _print_ast_break(ast, indent);
    end
end

proc print_ast ast in
    _print_ast(ast, 0);
    if ast_requires_semi(ast_kind(ast)) then
        printf(";\n");
    else
        printf("\n");
    end
end

proc check_ast_kind expect, ast in
    var actual = ast_kind(ast);
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end
