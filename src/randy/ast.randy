
const PointerOp_Read  = 0;
const PointerOp_Write = 1;

const AstK_Ident        = 0;
const AstK_Integer      = 1;
const AstK_String       = 2;
const AstK_Call         = 3;
const AstK_BinOp        = 4;
const AstK_Return       = 5;
const AstK_VarDecl      = 6;
const AstK_VarAssign    = 7;
const AstK_Procedure    = 8;
const AstK_IfElse       = 9;
const AstK_While        = 10;
const AstK_PointerRead  = 11;
const AstK_PointerWrite = 12;
const AstK_Prefix       = 13;
const AstK_Const        = 14;
const AstK_Extern       = 15;
const AstK_InlineAsm    = 16;
const AstK_Global       = 17;
const AstK_Break        = 18;
const AstK_Continue     = 19;
const AstK_AssignOp     = 20;
const AstK_Cast         = 21;
const AstK_Struct       = 22;
const AstK_MemberAccess = 23;

proc ast_kind_cstr k: int in
    if k == AstK_Ident then return "AstK_Ident"; end
    if k == AstK_Integer then return "AstK_Integer"; end
    if k == AstK_String then return "AstK_String"; end
    if k == AstK_Call then return "AstK_Call"; end
    if k == AstK_BinOp then return "AstK_BinOp"; end
    if k == AstK_Return then return "AstK_Return"; end
    if k == AstK_VarDecl then return "AstK_VarDecl"; end
    if k == AstK_VarAssign then return "AstK_VarAssign"; end
    if k == AstK_Procedure then return "AstK_Procedure"; end
    if k == AstK_IfElse then return "AstK_IfElse"; end
    if k == AstK_While then return "AstK_While"; end
    if k == AstK_PointerRead then return "AstK_PointerRead"; end
    if k == AstK_PointerWrite then return "AstK_PointerWrite"; end
    if k == AstK_Prefix then return "AstK_Prefix"; end
    if k == AstK_Const then return "AstK_Const"; end
    if k == AstK_Extern then return "AstK_Extern"; end
    if k == AstK_InlineAsm then return "AstK_InlineAsm"; end
    if k == AstK_Global then return "AstK_Global"; end
    if k == AstK_Break then return "AstK_Break"; end
    if k == AstK_Continue then return "AstK_Continue"; end
    if k == AstK_AssignOp then return "AstK_AssignOp"; end
    if k == AstK_Cast then return "AstK_Cast"; end
    if k == AstK_Struct then return "AstK_Struct"; end
    if k == AstK_MemberAccess then return "AstK_MemberAccess"; end
    return "AstK_OUT_OF_RANGE";
end

proc ast_requires_semi k in
    if k == AstK_Procedure then return false;
    elif k == AstK_IfElse then return false;
    elif k == AstK_While then return false;
    elif k == AstK_InlineAsm then return false;
    elif k == AstK_Struct then return false;
    else
        return true;
    end
end

const TAST_kind        = 0;  // AstK
const TAST_is_expr     = 4;  // bool
const TAST_token       = 8;  // token
// This represents each AST node as a c-"union"
// Ident
const TAST_ident       = 16; // cstr
// Integer, String
const TAST_value       = 16; // Union(int, string)
// Call
const TAST_expr        = 16; // ast
const TAST_args        = 24; // ast vector
// Prefix
const TAST_expr        = 16; // ast
const TAST_op          = 24; // TK
// BinOp
const TAST_lhs         = 16; // ast
const TAST_op          = 24; // TK
const TAST_rhs         = 32; // ast
// IfElse
const TAST_test        = 16; // ast
const TAST_consequence = 24; // ast vector
const TAST_alternative = 32; // ast vector
// While
const TAST_test        = 16; // ast
const TAST_body        = 24; // ast vector
// PointerRead, PointerWrite
const TAST_size        = 16; // int
const TAST_op          = 24; // int
const TAST_pop_args    = 32; // ast vector
// VarDecl
const TAST_ident       = 16; // cstr
// VarAssign
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// AssignOp
const TAST_ident       = 16; // cstr
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// Return
const TAST_expr        = 16; // ast
// Procedure
const TAST_ident       = 16; // cstr
const TAST_body        = 24; // ast vector
const TAST_params      = 32; // cstr vector
// Const
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// Extern
const TAST_ident       = 16; // cstr
const TAST_varargs     = 24; // bool
const TAST_params      = 32; // cstr vector
// InlineAsm
const TAST_ident       = 16; // cstr
const TAST_asm         = 24; // cstr
// Cast
const TAST_expr        = 16; // ast
const TAST_type        = 24; // type
// Struct
const TAST_struct      = 16; // type
const TAST_fields      = 24; // field vector
const TAST_procs       = 32; // ast_proc vector
// MemberAccess
const TAST_expr        = 16; // ast
const TAST_member      = 24; // cstr

const sizeof_TAST      = 40;

proc _make_ast kind: int, is_expr: bool, token: token -> ast in
    var self = malloc(sizeof_TAST);
    u32!(self + TAST_kind, kind);
    u8!(self + TAST_is_expr, is_expr);
    u64!(self + TAST_token, token);
    return cast(self, ast);
end

proc make_ast_ident token: token, ident: cstr -> ast in
    var self = _make_ast(AstK_Ident, true, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_integer token: token, value: int -> ast in
    var self = _make_ast(AstK_Integer, true, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_string token: token, value: string -> ast in
    var self = _make_ast(AstK_String, true, token);
    u64!(self + TAST_value, value);
    return self;
end

proc make_ast_call token: token, expr: ast, args: vector -> ast in
    var self = _make_ast(AstK_Call, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_args, args);
    return self;
end

proc make_ast_binop token: token, lhs: ast, op: int, rhs: ast -> ast in
    var self = _make_ast(AstK_BinOp, true, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

proc make_ast_return token: token, expr: ast -> ast in
    var self = _make_ast(AstK_Return, false, token);
    u64!(self + TAST_expr, expr);
    return self;
end

proc make_ast_var_decl token: token, ident: cstr -> ast in
    var self = _make_ast(AstK_VarDecl, false, token);
    u64!(self + TAST_ident, ident);
    return self;
end

proc make_ast_var_assign token: token, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK_VarAssign, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_assign_op token: token, ident: cstr, op: int, expr: ast -> ast in
    var self = _make_ast(AstK_AssignOp, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_op, op);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_procedure token: token, ident: cstr, params: vector, body: vector -> ast in
    var self = _make_ast(AstK_Procedure, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_body, body);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_if_else token: token, test: ast, conseq: vector, altern: vector -> ast in
    var self = _make_ast(AstK_IfElse, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_consequence, conseq);
    u64!(self + TAST_alternative, altern);
    return self;
end

proc make_ast_while token: token, test: ast, body: vector -> ast in
    var self = _make_ast(AstK_While, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_body, body);
    return self;
end

proc make_ast_pointer_op token: token, size: int, op: int, args: vector -> ast in
    var astk; var is_expr;
    if op == PointerOp_Read then
        astk = AstK_PointerRead;
        is_expr = true;
    else
        astk = AstK_PointerWrite;
        is_expr = false;
    end
    var self = _make_ast(astk, is_expr, token);
    u64!(self + TAST_size, size);
    u64!(self + TAST_op, op);
    u64!(self + TAST_pop_args, args);
    return self;
end

proc make_ast_prefix token: token, op: int, expr: ast -> ast in
    var self = _make_ast(AstK_Prefix, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_op, op);
    return self;
end

proc make_ast_const token: token, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK_Const, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

proc make_ast_extern token: token, ident: cstr, params: vector, varargs: bool -> ast in
    var self = _make_ast(AstK_Extern, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_varargs, varargs);
    u64!(self + TAST_params, params);
    return self;
end

proc make_ast_inline_asm token: token, ident: cstr, asmcode: cstr -> ast in
    var self = _make_ast(AstK_InlineAsm, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_asm, asmcode);
    return self;
end

proc make_ast_global token: token, ident: cstr, assign_expr: ast -> ast in
    var self = _make_ast(AstK_Global, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, assign_expr);
    return self;
end

proc make_ast_break token: token -> ast in
    return _make_ast(AstK_Break, false, token);
end

proc make_ast_continue token: token -> ast in
    return _make_ast(AstK_Continue, false, token);
end

proc make_ast_cast token: token, expr: ast, type: type -> ast in
    var self = _make_ast(AstK_Cast, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_type, type);
    return self;
end

proc make_ast_struct token: token, struct_: type, fields: vector, procs: vector -> ast in
    var self = _make_ast(AstK_Struct, false, token);
    u64!(self + TAST_struct, struct_);
    u64!(self + TAST_fields, fields);
    u64!(self + TAST_procs, procs);
    return self;
end

proc make_ast_member_access token: token, expr: ast, member: cstr -> ast in
    var self = _make_ast(AstK_MemberAccess, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_member, member);
    return self;
end

proc ast_kind self: ast in return cast(u32@(self + TAST_kind), int); end
proc ast_is_expr self: ast in return cast(u8@(self + TAST_is_expr), bool); end
proc ast_token self: ast in return cast(u64@(self + TAST_token), token); end
proc ast_alternative self: ast in return cast(u64@(self + TAST_alternative), vector); end
proc ast_args self: ast in return cast(u64@(self + TAST_args), vector); end
proc ast_asm self: ast in return cast(u64@(self + TAST_asm), cstr); end
proc ast_assign_expr self: ast in return cast(u64@(self + TAST_assign_expr), ast); end
proc ast_body self: ast in return cast(u64@(self + TAST_body), vector); end
proc ast_consequence self: ast in return cast(u64@(self + TAST_consequence), vector); end
proc ast_expr self: ast in return cast(u64@(self + TAST_expr), ast); end
proc ast_ident self: ast in return cast(u64@(self + TAST_ident), cstr); end
proc ast_lhs self: ast in return cast(u64@(self + TAST_lhs), ast); end
proc ast_op self: ast in return cast(u64@(self + TAST_op), int); end
proc ast_params self: ast in return cast(u64@(self + TAST_params), vector); end
proc ast_pop_args self: ast in return cast(u64@(self + TAST_pop_args), vector); end
proc ast_rhs self: ast in return cast(u64@(self + TAST_rhs), ast); end
proc ast_size self: ast in return cast(u64@(self + TAST_size), int); end
proc ast_test self: ast in return cast(u64@(self + TAST_test), ast); end
proc ast_value self: ast in return cast(u64@(self + TAST_value), ptr); end
proc ast_varargs self: ast in return cast(u64@(self + TAST_varargs), bool); end
proc ast_type self: ast in return cast(u64@(self + TAST_type), type); end
proc ast_fields self: ast in return cast(u64@(self + TAST_fields), vector); end
proc ast_procs self: ast in return cast(u64@(self + TAST_procs), vector); end
proc ast_member self: ast in return cast(u64@(self + TAST_member), cstr); end
proc ast_struct self: ast in return cast(u64@(self + TAST_struct), type); end

proc ast_src_loc self: ast in
    var token = ast_token(self);
    return token_src_loc(token);
end

proc print_ast_src_loc self: ast in
    print_token_loc(ast_token(self));
end

proc _print_indent indent: int in
    var i = 0;
    while i < indent do
        printf("    ");
        i += 1;
    end
end

proc _print_args args: vector, indent: int in
    var i = 0;
    var len = vector_len(args);
    while i < len do
        _print_ast(cast(vector_get(args, i), ast), indent);
        i += 1;
        if i < len then
            printf(", ");
        end
    end
end

proc _print_ast_ident ast, indent in
    printf("%s", ast_ident(ast));
end

proc _print_ast_integer ast, indent in
    printf("%ld", ast_value(ast));
end

proc _print_ast_string ast, indent in
    printf("\"");
    var string = ast_value(ast);
    var i = 0; var len = string_len(string);
    while i < len do
        var c = string_get(string, i);
        if c == '\n' then
            printf("\\n");
        elif c == '\t' then
            printf("\\t");
        elif c == '\0' then
            printf("\\0");
        elif c == '\r' then
            printf("\\r");
        else
            printf("%c", c);
        end
        i += 1;
    end
    printf("\"");
end

proc _print_ast_call ast, indent in
    _print_ast(ast_expr(ast), indent);
    printf("(");
    _print_args(ast_args(ast), indent);
    printf(")");
end

proc _print_ast_binop ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf(" %s ", token_cstr(ast_token(ast)));
    _print_ast(ast_rhs(ast), indent);
end

proc _print_ast_return ast, indent in
    var expr = ast_expr(ast);
    if expr then
        printf("return ");
        _print_ast(expr, indent);
    else
        printf("return");
    end
end

proc _print_type type in
    if type then
        if type_is_procedure(type) then
            var string = tt_get_proc_type_name(g_TypeTable, type);
            printf("%s", string_cstr(string));
            free_string(string);
        else
            printf("%s", tt_get_type_name(g_TypeTable, type));
        end
    else
        printf("{no type}");
    end
end

proc _print_ast_var_decl ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        _print_type(type);
    end
end

proc _print_ast_var_assign ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        _print_type(type);
    end
    printf(" = ");
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_assign ast, indent in
    printf("%s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_assign_op ast, indent in
    printf("%s ", ast_ident(ast));
    var op = ast_op(ast);
    var op_str = "FIXME in ast.randy";
    if op == TK_Assign      then op_str = "=";
    elif op == TK_PlusEq    then op_str = "+=";
    elif op == TK_MinusEq   then op_str = "-=";
    elif op == TK_StarEq    then op_str = "*=";
    elif op == TK_SlashEq   then op_str = "/=";
    elif op == TK_PercentEq then op_str = "%=";
    elif op == TK_LShiftEq  then op_str = "<<=";
    elif op == TK_RShiftEq  then op_str = ">>=";
    elif op == TK_AmperEq   then op_str = "&=";
    elif op == TK_CaretEq   then op_str = "^=";
    elif op == TK_BarEq     then op_str = "|=";
    end
    printf("%s ", op_str);
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_body body, indent in
    var i = 0;
    var len = vector_len(body);
    var stmt;
    while i < len do
        stmt = cast(vector_get(body, i), ast);
        _print_indent(indent);
        _print_ast(stmt, indent);
        if ast_requires_semi(ast_kind(stmt)) then
            printf(";\n");
        else
            printf("\n");
        end
        i += 1;
    end
end

proc _print_ast_procedure ast, indent in
    printf("proc %s", ast_ident(ast));
    var i = 0;
    var params = ast_params(ast);
    var len = vector_len(params);
    while i < len do
        var param_name = vector_get(params, i);
        printf(" %s", param_name);
        var param_sym = st_get_symbol(g_SymbolTable, param_name);
        assert(param_sym, "psym is NULL");
        var param_type = symbol_type(param_sym);
        if param_type then
            printf(": ");
            _print_type(param_type);
        end
        i += 1;
        if i < len then
            printf(",");
        end
    end
    var proc_sym = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(proc_sym);
    var proc_type = symbol_type(proc_sym);
    if proc_type then
        assert(type_is_procedure(proc_type), "proc_type not procedure.\n");
        var ret_type = type_proc_return_type(proc_type);
        printf(" -> ");
        _print_type(ret_type);
    end
    printf(" in\n");
    _print_ast_body(ast_body(ast), indent + 1);
    printf("end\n");
end

proc _print_ast_if_else ast, indent, print_if in
    if print_if then
        printf("if ");
    end
    _print_ast(ast_test(ast), indent);
    printf(" then\n");
    var conseq = ast_consequence(ast);
    var altern = ast_alternative(ast);
    _print_ast_body(conseq, indent+1);
    if vector_len(altern) > 0 then
        if vector_len(altern) == 1 and AstK_IfElse == ast_kind(vector_get(altern, 0)) then
            _print_indent(indent); printf("elif ");
            _print_ast_if_else(cast(vector_get(altern, 0), ast), indent, false);
            return;
        else
            _print_indent(indent); printf("else\n");
            _print_ast_body(altern, indent+1);
        end
    end
    _print_indent(indent); printf("end");
end

proc _print_ast_while ast, indent in
    printf("while ");
    _print_ast(ast_test(ast), indent);
    printf(" do\n");
    _print_ast_body(ast_body(ast), indent+1);
    _print_indent(indent); printf("end");
end

proc _print_ast_pointer_op ast, indent in
    printf("%s(", token_cstr(ast_token(ast)));
    _print_args(ast_pop_args(ast), indent);
    printf(")");
end

proc _print_ast_prefix ast, indent in
    var token = ast_token(ast);
    // FIXME == TK_KW_assert is a hack.
    if token_kind(token) == TK_KW_not or token_kind(token) == TK_KW_assert then
        printf("not ");
    else
        printf("%s", token_cstr(token));
    end
    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK_BinOp then
        printf("(");
    end
    _print_ast(ast_expr(ast), indent);
    if ast_kind(expr) == AstK_BinOp then
        printf(")");
    end
end

proc _print_ast_const ast, indent in
    printf("const %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_global ast, indent in
    printf("global %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

proc _print_ast_extern ast, indent in
    printf("extern %s", ast_ident(ast));
    var i = 0;
    var params = ast_params(ast);
    var len = vector_len(params);
    while i < len do
        printf(" %s", vector_get(params, i));
        i += 1;
        if i < len then
            printf(",");
        end
    end
    if ast_varargs(ast) then
        if len != 0 then
            printf(", ...");
        else
            printf(", ...");
        end
    end
end

proc _print_ast_inline_asm ast, indent in
    printf("asm %s in\n", ast_ident(ast));
    printf("\"%s\"\n", ast_asm(ast));
    printf("end\n");
end

proc _print_ast_break ast, indent in
    printf("break");
end

proc _print_ast_continue ast, indent in
    printf("continue");
end

proc _print_ast_cast ast, indent in
    printf("cast(");
    _print_ast(ast_expr(ast), indent);
    printf(", ");
    _print_type(ast_type(ast));
    printf(")");
end

proc _print_ast_struct ast, indent in
    printf("struct ");
    _print_type(ast_struct(ast));
    printf(" in\n");
    var fields = ast_fields(ast);
    var i = 0; var len = vector_len(fields);
    while i < len do
        var field = vector_get(fields, i);
        _print_indent(indent+1);
        printf("%s: ", field_name(field));
        _print_type(field_type(field));
        printf("\n");
        i += 1;
    end
    var procs = ast_procs(ast);
    if i != 0 and vector_len(procs) != 0 then
        printf("\n");
    end
    i = 0; len = vector_len(procs);
    while i < len do
        _print_indent(indent+1);
        _print_ast_procedure(cast(vector_get(procs, i), ast), indent+1);
        printf("\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

proc _print_ast_member_access ast, indent in
    var expr = ast_expr(ast);
    var member = ast_member(ast);
    _print_ast(expr, indent);
    printf(".%s", member);
end

proc _print_ast ast, indent in
    var k = ast_kind(ast);
    if k == AstK_Ident then _print_ast_ident(ast, indent);
    elif k == AstK_Integer then _print_ast_integer(ast, indent);
    elif k == AstK_String then _print_ast_string(ast, indent);
    elif k == AstK_Call then _print_ast_call(ast, indent);
    elif k == AstK_BinOp then _print_ast_binop(ast, indent);
    elif k == AstK_Return then _print_ast_return(ast, indent);
    elif k == AstK_VarDecl then _print_ast_var_decl(ast, indent);
    elif k == AstK_VarAssign then _print_ast_var_assign(ast, indent);
    elif k == AstK_Procedure then _print_ast_procedure(ast, indent);
    elif k == AstK_IfElse then _print_ast_if_else(ast, indent, true);
    elif k == AstK_While then _print_ast_while(ast, indent);
    elif k == AstK_PointerRead then _print_ast_pointer_op(ast, indent);
    elif k == AstK_PointerWrite then _print_ast_pointer_op(ast, indent);
    elif k == AstK_Prefix then _print_ast_prefix(ast, indent);
    elif k == AstK_Const then _print_ast_const(ast, indent);
    elif k == AstK_Extern then _print_ast_extern(ast, indent);
    elif k == AstK_InlineAsm then _print_ast_inline_asm(ast, indent);
    elif k == AstK_Global then _print_ast_global(ast, indent);
    elif k == AstK_Break then _print_ast_break(ast, indent);
    elif k == AstK_Continue then _print_ast_continue(ast, indent);
    elif k == AstK_AssignOp then _print_ast_assign_op(ast, indent);
    elif k == AstK_Cast then _print_ast_cast(ast, indent);
    elif k == AstK_Struct then _print_ast_struct(ast, indent);
    elif k == AstK_MemberAccess then _print_ast_member_access(ast, indent);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end

proc print_ast ast: ast in
    _print_ast(ast, 0);
    if ast_requires_semi(ast_kind(ast)) then
        printf(";\n");
    else
        printf("\n");
    end
end

proc check_ast_kind expect: int, ast: ast in
    var actual = ast_kind(ast);
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end

proc print_whole_ast roots in
    var i = 0; var len = vector_len(roots);
    while i < len do
        print_ast(vector_get(roots, i));
        i += 1;
    end
end

proc print_compile_ast roots, compile_order in
    var i = 0; var len = vector_len(roots);
    while i < len do
        var ast = vector_get(roots, i);
        if ast_kind(ast) != AstK_Procedure then
            print_ast(ast);
        end
        i += 1;
    end

    i = 0; len = vector_len(compile_order);
    while i < len do
        print_ast(vector_get(compile_order, i));
        i += 1;
    end
end
