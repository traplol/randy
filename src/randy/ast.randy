
enum PointerOp in
    Read;
    Write;
end

enum AstK in
    Ident;
    Integer;
    String;
    Call;
    BinOp;
    Return;
    VarDecl;
    VarAssign;
    Def;
    IfElse;
    While;
    PointerRead;
    PointerWrite;
    Prefix;
    Const;
    Extern;
    InlineAsm;
    Global;
    Break;
    Continue;
    AssignOp;
    Cast;
    Struct;
    MemberAccess;
    AssignMember;
    SizeofExpr;
    SizeofType;
    Enum;
    Type;
    ScopeResolve;
    GetReference; // unavailable from source code
    Union;
    StaticAssert;
    OffsetOf;
end

def ast_kind_cstr k: AstK in
    if k == AstK::Ident then return "AstK::Ident"; end
    if k == AstK::Integer then return "AstK::Integer"; end
    if k == AstK::String then return "AstK::String"; end
    if k == AstK::Call then return "AstK::Call"; end
    if k == AstK::BinOp then return "AstK::BinOp"; end
    if k == AstK::Return then return "AstK::Return"; end
    if k == AstK::VarDecl then return "AstK::VarDecl"; end
    if k == AstK::VarAssign then return "AstK::VarAssign"; end
    if k == AstK::Def then return "AstK::Def"; end
    if k == AstK::IfElse then return "AstK::IfElse"; end
    if k == AstK::While then return "AstK::While"; end
    if k == AstK::PointerRead then return "AstK::PointerRead"; end
    if k == AstK::PointerWrite then return "AstK::PointerWrite"; end
    if k == AstK::Prefix then return "AstK::Prefix"; end
    if k == AstK::Const then return "AstK::Const"; end
    if k == AstK::Extern then return "AstK::Extern"; end
    if k == AstK::InlineAsm then return "AstK::InlineAsm"; end
    if k == AstK::Global then return "AstK::Global"; end
    if k == AstK::Break then return "AstK::Break"; end
    if k == AstK::Continue then return "AstK::Continue"; end
    if k == AstK::AssignOp then return "AstK::AssignOp"; end
    if k == AstK::Cast then return "AstK::Cast"; end
    if k == AstK::Struct then return "AstK::Struct"; end
    if k == AstK::MemberAccess then return "AstK::MemberAccess"; end
    if k == AstK::AssignMember then return "AstK::AssignMember"; end
    if k == AstK::SizeofExpr then return "AstK::SizeofExpr"; end
    if k == AstK::SizeofType then return "AstK::SizeofType"; end
    if k == AstK::Enum then return "AstK::Enum"; end
    if k == AstK::Type then return "AstK::Type"; end
    if k == AstK::ScopeResolve then return "AstK::ScopeResolve"; end
    if k == AstK::GetReference then return "AstK::GetReference"; end
    if k == AstK::Union then return "AstK::Union"; end
    if k == AstK::StaticAssert then return "AstK::StaticAssert"; end
    if k == AstK::OffsetOf then return "AstK::OffsetOf"; end
    return "AstK::OUT_OF_RANGE";
end

def ast_requires_semi k in
    if k == AstK::Def then return false;
    elif k == AstK::IfElse then return false;
    elif k == AstK::While then return false;
    elif k == AstK::InlineAsm then return false;
    elif k == AstK::Struct then return false;
    elif k == AstK::Enum then return false;
    elif k == AstK::Union then return false;
    else
        return true;
    end
end

struct Ast in
    kind: AstK;
    is_expr: bool;
    token: Token&;

    u: union in
        ident: cstr;
        integer: int;
        string: String&;
        return_: Ast&;
        var_decl: cstr;
        type: Type&;
        get_reference: Ast&;
        static_assert_: Vector[Ast&]&;
        sizeof_expr: Ast&;
        sizeof_type: Type&;

        call: struct in
            expr: Ast&;
            args: Vector[Ast&]&;
        end
        binop: struct in
            lhs: Ast&;
            op: TK;
            rhs: Ast&;
        end
        var_assign: struct in
            ident: cstr;
            expr: Ast&;
        end
        assign_op: struct in
            ident: cstr;
            op: TK;
            expr: Ast&;
        end
        def_: struct in
            ident: cstr;
            body: Vector[Ast&]&;
            params: Vector[cstr]&;
        end
        if_else: struct in
            test: Ast&;
            consequence: Vector[Ast&]&;
            alternative: Vector[Ast&]&;
        end
        while_: struct in
            test: Ast&;
            body: Vector[Ast&]&;
        end
        ptr_op: struct in
            size: int;
            op: PointerOp;
            args: Vector[Ast&]&;
        end
        prefix: struct in
            expr: Ast&;
            op: TK;
        end
        const_: struct in
            ident: cstr;
            expr: Ast&;
        end
        extern_: struct in
            ident: cstr;
            type: Type&;
        end
        inline_asm: struct in
            ident: cstr;
            asmcode: cstr;
        end
        global_: struct in
            ident: cstr;
            expr: Ast&;
        end
        cast_: struct in
            expr: Ast&;
            type: Type&;
        end
        struct_: struct in
            type: Type&;
            fields: Vector[Field&]&;
            body: Vector[Ast&]&;
        end
        union_: struct in
            type: Type&;
            fields: Vector[Field&]&;
        end
        enum_: struct in
            ident: cstr;
            type: Type&;
            values: Vector[EnumValue&]&;
        end
        member_access: struct in
            expr: Ast&;
            member: cstr;
        end
        assign_member: struct in
            lhs: Ast&;
            op: TK;
            rhs: Ast&;
        end
        scope_resolve: struct in
            lhs: Ast&;
            rhs: Ast&;
        end
    end

    def new_ident token: Token&, ident: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Ident;
        self.is_expr = true;
        self.token = token;
        self.u.ident = ident;
    end

    def new_integer token: Token&, val: int in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Integer;
        self.is_expr = true;
        self.token = token;
        self.u.integer = val;
    end

    def new_string token: Token&, val: String& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::String;
        self.is_expr = true;
        self.token = token;
        self.u.string = val;
    end

    def new_call token: Token&, expr: Ast&, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Call;
        self.is_expr = true;
        self.token = token;
        self.u.call.expr = expr;
        self.u.call.args = args;
    end

    def new_binop token: Token&, lhs: Ast&, op: TK, rhs: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::BinOp;
        self.is_expr = true;
        self.token = token;
        self.u.binop.lhs = lhs;
        self.u.binop.op = op;
        self.u.binop.rhs = rhs;
    end

    def new_return token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Return;
        self.is_expr = false;
        self.token = token;
        self.u.return_ = expr;
    end

    def new_var_decl token: Token&, ident: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::VarDecl;
        self.is_expr = false;
        self.token = token;
        self.u.var_decl = ident;
    end

    def new_var_assign token: Token&, ident: cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::VarAssign;
        self.is_expr = false;
        self.token = token;
        self.u.var_assign.ident = ident;
        self.u.var_assign.expr = expr;
    end

    def new_assign_op token: Token&, ident: cstr, op: TK, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::AssignOp;
        self.is_expr = false;
        self.token = token;
        self.u.assign_op.ident = ident;
        self.u.assign_op.op = op;
        self.u.assign_op.expr = expr;
    end

    def new_def token: Token&, ident: cstr, body: Vector[Ast&]&, params: Vector[cstr]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Def;
        self.is_expr = false;
        self.token = token;
        self.u.def_.ident = ident;
        self.u.def_.body = body;
        self.u.def_.params = params;
    end

    def new_if_else token: Token&, test: Ast&, consequence: Vector[Ast&]&, alternative: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::IfElse;
        self.is_expr = false;
        self.token = token;
        self.u.if_else.test = test;
        self.u.if_else.consequence = consequence;
        self.u.if_else.alternative = alternative;
    end

    def new_while token: Token&, test: Ast&, body: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::While;
        self.is_expr = false;
        self.token = token;
        self.u.while_.test = test;
        self.u.while_.body = body;
    end

    def new_ptr_op token: Token&, size: int, op: PointerOp, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        if op == PointerOp::Read then
            self.kind = AstK::PointerRead;
            self.is_expr = true;
        else
            self.kind = AstK::PointerWrite;
            self.is_expr = false;
        end
        self.token = token;
        self.u.ptr_op.size = size;
        self.u.ptr_op.op = op;
        self.u.ptr_op.args = args;
    end

    def new_prefix token: Token&, op: TK, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Prefix;
        self.is_expr = true;
        self.token = token;
        self.u.prefix.op = op;
        self.u.prefix.expr = expr;
    end

    def new_const token: Token&, ident: cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Const;
        self.is_expr = false;
        self.token = token;
        self.u.const_.ident = ident;
        self.u.const_.expr = expr;
    end

    def new_extern token: Token&, ident: cstr, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Extern;
        self.is_expr = false;
        self.token = token;
        self.u.extern_.ident = ident;
        self.u.extern_.type = type;
    end

    def new_inline_asm token: Token&, ident: cstr, asmcode: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::InlineAsm;
        self.is_expr = false;
        self.token = token;
        self.u.inline_asm.ident = ident;
        self.u.inline_asm.asmcode = asmcode;
    end

    def new_global token: Token&, ident:cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Global;
        self.is_expr = false;
        self.token = token;
        self.u.global_.ident = ident;
        self.u.global_.expr = expr;
    end

    def new_cast token: Token&, expr: Ast&, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Cast;
        self.is_expr = true;
        self.token = token;
        self.u.cast_.expr = expr;
        self.u.cast_.type = type;
    end

    def new_struct token: Token&, type: Type&, fields: Vector[Field&]&, body: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Struct;
        self.is_expr = false;
        self.token = token;
        self.u.struct_.type = type;
        self.u.struct_.fields = fields;
        self.u.struct_.body = body;
    end

    def new_union token: Token&, type: Type&, fields: Vector[Field&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Union;
        self.is_expr = false;
        self.token = token;
        self.u.union_.type = type;
        self.u.union_.fields = fields;
    end

    def new_enum token: Token&, ident: cstr, type: Type&, values: Vector[EnumValue&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Enum;
        self.is_expr = false;
        self.token = token;
        self.u.enum_.ident = ident;
        self.u.enum_.type = type;
        self.u.enum_.values = values;
    end

    def new_member_access token: Token&, expr: Ast&, member: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::MemberAccess;
        self.is_expr = true;
        self.token = token;
        self.u.member_access.expr = expr;
        self.u.member_access.member = member;
    end

    def new_assign_member token: Token&, lhs: Ast&, op: TK, rhs: Ast& in
        assert(lhs.kind == AstK::MemberAccess);
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::AssignMember;
        self.is_expr = false;
        self.token = token;
        self.u.assign_member.lhs = lhs;
        self.u.assign_member.op = op;
        self.u.assign_member.rhs = rhs;
    end

    def new_sizeof_expr token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::SizeofExpr;
        self.is_expr = true;
        self.token = token;
        self.u.sizeof_expr = expr;
    end

    def new_sizeof_type token: Token&, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::SizeofType;
        self.is_expr = true;
        self.token = token;
        self.u.sizeof_type = type;
    end

    def new_scope_resolve token: Token&, lhs: Ast&, rhs: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::ScopeResolve;
        self.is_expr = true;
        self.token = token;
        self.u.scope_resolve.lhs = lhs;
        self.u.scope_resolve.rhs = rhs;
    end

    def new_get_reference token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::GetReference;
        self.is_expr = true;
        self.token = token;
        self.u.get_reference = expr;
    end

    def new_static_assert token: Token&, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::StaticAssert;
        self.is_expr = false;
        self.token = token;
        self.u.static_assert_ = args;
    end

end

const TAST_kind        = 0;  // AstK
const TAST_is_expr     = 4;  // bool
const TAST_token       = 8;  // Token&
// This represents each AST node as a c-"union"
// Ident
const TAST_ident       = 16; // cstr
// Integer, String
const TAST_value       = 16; // Union(int, string)
// Call
const TAST_expr        = 16; // ast
const TAST_args        = 24; // ast Vector&
// Prefix
const TAST_expr        = 16; // ast
const TAST_op          = 24; // TK
// BinOp
const TAST_lhs         = 16; // ast
const TAST_op          = 24; // TK
const TAST_rhs         = 32; // ast
// IfElse
const TAST_test        = 16; // ast
const TAST_consequence = 24; // ast Vector&
const TAST_alternative = 32; // ast Vector&
// While
const TAST_test        = 16; // ast
const TAST_body        = 24; // ast Vector&
// PointerRead, PointerWrite
const TAST_size        = 16; // int
const TAST_pop         = 24; // PointerOp
const TAST_pop_args    = 32; // ast Vector&
// VarDecl
const TAST_ident       = 16; // cstr
// VarAssign
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// AssignOp
const TAST_ident       = 16; // cstr
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// Return
const TAST_expr        = 16; // ast
// Def
const TAST_ident       = 16; // cstr
const TAST_body        = 24; // ast Vector&
const TAST_params      = 32; // cstr Vector&
// Const
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// Extern
const TAST_ident       = 16; // cstr
const TAST_varargs     = 24; // bool
// InlineAsm
const TAST_ident       = 16; // cstr
const TAST_asm         = 24; // cstr
// Cast
const TAST_expr        = 16; // ast
const TAST_type        = 24; // type
// Struct
const TAST_struct      = 16; // type
const TAST_fields      = 24; // field Vector&
const TAST_defs        = 32; // ast_def Vector&
// MemberAccess
const TAST_expr        = 16; // ast
const TAST_member      = 24; // cstr
// AssignMember
const TAST_expr        = 16; // ast_member_access
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// SizeofExpr/Type
const TAST_expr        = 16; // ast
const TAST_type        = 24; // type
// Enum
const TAST_ident       = 16; // cstr
const TAST_enum        = 24; // type
const TAST_values      = 32; // EnumValue& Vector&
// Type
const TAST_type        = 24; // type
// ScopeResolve
const TAST_lhs         = 16; // Union(type_ast, scope_resolve_ast)
const TAST_rhs         = 32; // Union(type_ast, ident_ast)
// GetReference
const TAST_object      = 16; // ast
// Union
const TAST_union       = 16; // type
const TAST_fields      = 24; // field Vector&
// StaticAssert
const TAST_args        = 24; // ast Vector&

const sizeof_TAST      = 40;

def _make_ast kind: AstK, is_expr: bool, token: Token& -> ast in
    var self = calloc(1, sizeof_TAST);
    u32!(self + TAST_kind, kind);
    u8!(self + TAST_is_expr, is_expr);
    u64!(self + TAST_token, token);
    return cast(self, ast);
end

def make_ast_ident token: Token&, ident: cstr -> ast in
    var self = _make_ast(AstK::Ident, true, token);
    u64!(self + TAST_ident, ident);
    return self;
end

def make_ast_integer token: Token&, value: int -> ast in
    var self = _make_ast(AstK::Integer, true, token);
    u64!(self + TAST_value, value);
    return self;
end

def make_ast_string token: Token&, value: String& -> ast in
    var self = _make_ast(AstK::String, true, token);
    u64!(self + TAST_value, value);
    return self;
end

def make_ast_call token: Token&, expr: ast, args: Vector[ast]& -> ast in
    var self = _make_ast(AstK::Call, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_args, args);
    return self;
end

def make_ast_binop token: Token&, lhs: ast, op: TK, rhs: ast -> ast in
    var self = _make_ast(AstK::BinOp, true, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def make_ast_return token: Token&, expr: ast -> ast in
    var self = _make_ast(AstK::Return, false, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def make_ast_var_decl token: Token&, ident: cstr -> ast in
    var self = _make_ast(AstK::VarDecl, false, token);
    u64!(self + TAST_ident, ident);
    return self;
end

def make_ast_var_assign token: Token&, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK::VarAssign, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_assign_op token: Token&, ident: cstr, op: TK, expr: ast -> ast in
    var self = _make_ast(AstK::AssignOp, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_op, op);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_def token: Token&, ident: cstr, params: Vector[cstr]&, body: Vector[ast]& -> ast in
    var self = _make_ast(AstK::Def, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_body, body);
    u64!(self + TAST_params, params);
    return self;
end

def make_ast_if_else token: Token&, test: ast, conseq: Vector[ast]&, altern: Vector[ast]& -> ast in
    var self = _make_ast(AstK::IfElse, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_consequence, conseq);
    u64!(self + TAST_alternative, altern);
    return self;
end

def make_ast_while token: Token&, test: ast, body: Vector[ast]& -> ast in
    var self = _make_ast(AstK::While, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_body, body);
    return self;
end

def make_ast_pointer_op token: Token&, size: int, op: PointerOp, args: Vector[ast]& -> ast in
    var astk; var is_expr;
    if op == PointerOp::Read then
        astk = AstK::PointerRead;
        is_expr = true;
    else
        astk = AstK::PointerWrite;
        is_expr = false;
    end
    var self = _make_ast(astk, is_expr, token);
    u64!(self + TAST_size, size);
    u64!(self + TAST_op, op);
    u64!(self + TAST_pop_args, args);
    return self;
end

def make_ast_prefix token: Token&, op: TK, expr: ast -> ast in
    var self = _make_ast(AstK::Prefix, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_op, op);
    return self;
end

def make_ast_const token: Token&, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK::Const, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_extern token: Token&, ident: cstr, type: Type& -> ast in
    var self = _make_ast(AstK::Extern, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_inline_asm token: Token&, ident: cstr, asmcode: cstr -> ast in
    var self = _make_ast(AstK::InlineAsm, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_asm, asmcode);
    return self;
end

def make_ast_global token: Token&, ident: cstr, assign_expr: ast -> ast in
    var self = _make_ast(AstK::Global, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, assign_expr);
    return self;
end

def make_ast_break token: Token& -> ast in
    return _make_ast(AstK::Break, false, token);
end

def make_ast_continue token: Token& -> ast in
    return _make_ast(AstK::Continue, false, token);
end

def make_ast_cast token: Token&, expr: ast, type: Type& -> ast in
    var self = _make_ast(AstK::Cast, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_struct token: Token&, struct_type: Type&, fields: Vector[Field&]&, defs: Vector[ast]& -> ast in
    var self = _make_ast(AstK::Struct, false, token);
    u64!(self + TAST_struct, struct_type);
    u64!(self + TAST_fields, fields);
    u64!(self + TAST_defs, defs);
    return self;
end

def make_ast_union token: Token&, union_type: Type&, fields: Vector[Field&]& -> ast in
    var self = _make_ast(AstK::Union, false, token);
    u64!(self + TAST_union, union_type);
    u64!(self + TAST_fields, fields);
    return self;
end

def make_ast_member_access token: Token&, expr: ast, member: cstr -> ast in
    var self = _make_ast(AstK::MemberAccess, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_member, member);
    return self;
end

def make_ast_assign_member token: Token&, lhs: ast, op: TK, rhs: ast -> ast in
    assert(ast_kind(lhs) == AstK::MemberAccess,
        "Compiler bug: cannot make_ast_assign_member where lhs is %s (%d)\n",
        ast_kind_cstr(ast_kind(lhs)),
        ast_kind(lhs));
    var self = _make_ast(AstK::AssignMember, false, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def make_ast_sizeof_expr token: Token&, expr: ast -> ast in
    if ast_kind(expr) == AstK::Type then
        return make_ast_sizeof_type(token, ast_type(expr));
    end
    var self = _make_ast(AstK::SizeofExpr, true, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def make_ast_sizeof_type token: Token&, type: Type& -> ast in
    var self = _make_ast(AstK::SizeofType, true, token);
    u64!(self + TAST_type, type);
    return self;
end

def ast_change_sizeof_expr_to_type self: ast, type: Type& in
    assert(ast_kind(self) == AstK::SizeofExpr);
    u32!(self + TAST_kind, AstK::SizeofType);
    u64!(self + TAST_type, type);
end

def make_ast_enum token: Token&, ident: cstr, enum_: Type&, values: Vector[EnumValue&]& -> ast in
    var self = _make_ast(AstK::Enum, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_enum, enum_);
    u64!(self + TAST_values, values);
    return self;
end

def make_ast_type token: Token&, type: Type& -> ast in
    var self = _make_ast(AstK::Type, false, token);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_scope_resolve token: Token&, lhs: ast, rhs: ast -> ast in
    var self = _make_ast(AstK::ScopeResolve, true, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def ast_change_member_access_to_scope_access self: ast, type: Type&, member: Symbol& in
    assert(ast_kind(self) == AstK::MemberAccess);
    u32!(self + TAST_kind, AstK::ScopeResolve);

    var lhs = make_ast_type(ast_token(self), type);
    var rhs = make_ast_ident(ast_token(self), member.name);

    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_rhs, rhs);
end

def make_ast_get_reference token: Token&, expr: ast -> ast in
    var self = _make_ast(AstK::GetReference, true, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def make_ast_static_assert token: Token&, args: Vector[ast]& -> ast in
    var self = _make_ast(AstK::StaticAssert, false, token);
    u64!(self + TAST_args, args);
    return self;
end

def make_ast_offsetof token: Token&, expr: ast -> ast in
    var self = _make_ast(AstK::OffsetOf, true, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def ast_kind self: ast in return cast(u32@(self + TAST_kind), AstK); end
def ast_is_expr self: ast in return cast(u8@(self + TAST_is_expr), bool); end
def ast_token self: ast in return cast(u64@(self + TAST_token), Token&); end
def ast_alternative self: ast in return cast(u64@(self + TAST_alternative), Vector[ast]&); end
def ast_args self: ast in return cast(u64@(self + TAST_args), Vector[ast]&); end
def ast_asm self: ast in return cast(u64@(self + TAST_asm), cstr); end
def ast_assign_expr self: ast in return cast(u64@(self + TAST_assign_expr), ast); end
def ast_body self: ast in return cast(u64@(self + TAST_body), Vector[ast]&); end
def ast_consequence self: ast in return cast(u64@(self + TAST_consequence), Vector[ast]&); end
def ast_expr self: ast in return cast(u64@(self + TAST_expr), ast); end
def ast_ident self: ast in return cast(u64@(self + TAST_ident), cstr); end
def ast_lhs self: ast in return cast(u64@(self + TAST_lhs), ast); end
def ast_op self: ast in return cast(u64@(self + TAST_op), TK); end
def ast_pop self: ast in return cast(u64@(self + TAST_op), PointerOp); end
def ast_params self: ast in return cast(u64@(self + TAST_params), Vector[cstr]&); end
def ast_pop_args self: ast in return cast(u64@(self + TAST_pop_args), Vector[ast]&); end
def ast_rhs self: ast in return cast(u64@(self + TAST_rhs), ast); end
def ast_size self: ast in return cast(u64@(self + TAST_size), int); end
def ast_test self: ast in return cast(u64@(self + TAST_test), ast); end
def ast_value self: ast in return cast(u64@(self + TAST_value), ptr); end
def ast_varargs self: ast in return cast(u64@(self + TAST_varargs), bool); end
def ast_type self: ast in return cast(u64@(self + TAST_type), Type&); end
def ast_fields self: ast in return cast(u64@(self + TAST_fields), Vector[Field&]&); end
def ast_defs self: ast in return cast(u64@(self + TAST_defs), Vector[ast]&); end
def ast_member self: ast in return cast(u64@(self + TAST_member), cstr); end
def ast_struct self: ast in return cast(u64@(self + TAST_struct), Type&); end
def ast_enum self: ast in return cast(u64@(self + TAST_enum), Type&); end
def ast_union self: ast in return cast(u64@(self + TAST_union), Type&); end
def ast_values self: ast in return cast(u64@(self + TAST_values), Vector[EnumValue&]&); end

def ast_set_struct self: ast, struct_: Type& in
    assert(ast_kind(self) == AstK::Struct);
    u64!(self + TAST_struct, struct_);
end

def ast_src_loc self: ast in
    var token = ast_token(self);
    return token_src_loc(token);
end

def print_ast_src_loc self: ast in
    print_token_loc(ast_token(self));
end

def _print_indent indent: int in
    var i = 0;
    while i < indent do
        printf("    ");
        i += 1;
    end
end

def _print_args args: Vector[ast]&, indent: int in
    var i = 0;
    var len = args.length;
    while i < len do
        _print_ast(args.get(i), indent);
        i += 1;
        if i < len then
            printf(", ");
        end
    end
end

def _print_ast_ident ast, indent in
    printf("%s", ast_ident(ast));
end

def _print_ast_integer ast, indent in
    printf("%ld", cast(ast_value(ast), int));
end

def _print_ast_string ast, indent in
    printf("\"");
    var string = cast(ast_value(ast), String&);
    var i = 0; var len = string.length;
    while i < len do
        var c = string.get(i);
        if c == '\n' then
            printf("\\n");
        elif c == '"' then
            printf("\\\"");
        elif c == '\t' then
            printf("\\t");
        elif c == '\0' then
            printf("\\0");
        elif c == '\r' then
            printf("\\r");
        else
            printf("%c", c);
        end
        i += 1;
    end
    printf("\"");
end

def _print_ast_call ast, indent in
    _print_ast(ast_expr(ast), indent);
    printf("(");
    _print_args(ast_args(ast), indent);
    printf(")");
end

def _print_ast_binop ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf(" %s ", ast_token(ast).cstr);
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast_return ast, indent in
    var expr = ast_expr(ast);
    if expr then
        printf("return ");
        _print_ast(expr, indent);
    else
        printf("return");
    end
end

def _print_ast_var_decl ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
end

def _print_ast_var_assign ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
    printf(" = ");
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_assign_op ast, indent in
    printf("%s ", ast_ident(ast));
    var op = ast_op(ast);
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf("%s ", op_str);
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_body body, indent in
    var i = 0;
    var len = body.length;
    var stmt;
    while i < len do
        stmt = body.get(i);
        _print_indent(indent);
        _print_ast(stmt, indent);
        if ast_requires_semi(ast_kind(stmt)) then
            printf(";\n");
        else
            printf("\n");
        end
        i += 1;
    end
end

def _print_ast_def ast, indent in
    var def_sym = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(def_sym);
    if def_sym and def_sym.owned_by then
        printf("def ");
        tt_print_type_name(g_TypeTable, def_sym.owned_by);
        printf("::%s", ast_ident(ast));
    else
        printf("def %s", ast_ident(ast));
    end
    var i = 0;
    var params = ast_params(ast);
    var len = params.length;
    while i < len do
        var param_name = params.get(i);
        printf(" %s", param_name);
        var param_sym = st_get_symbol(g_SymbolTable, param_name);
        assert(param_sym, "psym is NULL");
        var param_type = symbol_type(param_sym);
        if param_type then
            printf(": ");
            tt_print_type_name(g_TypeTable, param_type);
        end
        i += 1;
        if i < len then
            printf(",");
        end
    end
    var def_type = symbol_type(def_sym);
    if def_type then
        assert(type_is_def(def_type), "def_type not def.\n");
        var ret_type = type_def_return_type(def_type);
        printf(" -> ");
        tt_print_type_name(g_TypeTable, ret_type);
    end
    printf(" in\n");
    _print_ast_body(ast_body(ast), indent + 1);
    _print_indent(indent); printf("end\n");
end

def _print_ast_if_else ast, indent, print_if in
    if print_if then
        printf("if ");
    end
    _print_ast(ast_test(ast), indent);
    printf(" then\n");
    var conseq = ast_consequence(ast);
    var altern = ast_alternative(ast);
    _print_ast_body(conseq, indent+1);
    if altern.length > 0 then
        if altern.length == 1 and AstK::IfElse == ast_kind(altern.get(0)) then
            _print_indent(indent); printf("elif ");
            _print_ast_if_else(altern.get(0), indent, false);
            return;
        else
            _print_indent(indent); printf("else\n");
            _print_ast_body(altern, indent+1);
        end
    end
    _print_indent(indent); printf("end");
end

def _print_ast_while ast, indent in
    printf("while ");
    _print_ast(ast_test(ast), indent);
    printf(" do\n");
    _print_ast_body(ast_body(ast), indent+1);
    _print_indent(indent); printf("end");
end

def _print_ast_pointer_op ast, indent in
    printf("%s(", ast_token(ast).cstr);
    _print_args(ast_pop_args(ast), indent);
    printf(")");
end

def _print_ast_prefix ast, indent in
    var token = ast_token(ast);
    // FIXME == TK::KW_assert is a hack.
    if token.kind == TK::KW_not or token.kind == TK::KW_assert then
        printf("not ");
    else
        printf("%s", token.cstr);
    end
    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK::BinOp then
        printf("(");
    end
    _print_ast(ast_expr(ast), indent);
    if ast_kind(expr) == AstK::BinOp then
        printf(")");
    end
end

def _print_ast_const ast, indent in
    printf("const %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_global ast, indent in
    printf("global %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_extern ast, indent in
    printf("extern %s: ", ast_ident(ast));
    tt_print_type_name(g_TypeTable, ast_type(ast));
end

def _print_ast_inline_asm ast, indent in
    printf("asm %s in\n", ast_ident(ast));
    printf("\"%s\"\n", ast_asm(ast));
    printf("end\n");
end

def _print_ast_break ast, indent in
    printf("break");
end

def _print_ast_continue ast, indent in
    printf("continue");
end

def _print_ast_static_assert ast, indent in
    printf("static_assert(");
    _print_args(ast_args(ast), indent);
    printf(")");
end

def _print_ast_cast ast, indent in
    printf("cast(");
    _print_ast(ast_expr(ast), indent);
    printf(", ");
    tt_print_type_name(g_TypeTable, ast_type(ast));
    printf(")");
end

def _print_ast_struct ast, indent in
    printf("struct ");
    tt_print_type_name(g_TypeTable, ast_struct(ast));
    printf(" in\n");
    var fields = ast_fields(ast);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        _print_indent(indent+1);
        printf("%s: ", field.name);
        tt_print_type_name(g_TypeTable, field.type);
        printf(";\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

def _print_ast_union ast, indent in
    printf("union ");
    tt_print_type_name(g_TypeTable, ast_struct(ast));
    printf(" in\n");
    var fields = ast_fields(ast);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        _print_indent(indent+1);
        printf("%s: ", field.name);
        tt_print_type_name(g_TypeTable, field.type);
        printf(";\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

def _print_ast_member_access ast, indent in
    var expr = ast_expr(ast);
    printf("(");
    var member = ast_member(ast);
    _print_ast(expr, indent);
    printf(".%s)", member);
end

def _print_ast_assign_member ast, indent in
    _print_ast(ast_lhs(ast), indent);
    var op = ast_op(ast);
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf(" %s ", op_str);
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast_sizeof_expr ast, indent in
    printf("__sizeof(");
    _print_ast(ast_expr(ast), indent);
    printf(")");
end

def _print_ast_sizeof_type ast, indent in
    printf("__sizeof(");
    tt_print_type_name(g_TypeTable, ast_type(ast));
    printf(")");
end

def _print_ast_enum ast, indent in
    var enum_name = ast_ident(ast);
    var enum_vals = ast_values(ast);

    printf("enum %s in\n", enum_name);
    var i = 0; var len = enum_vals.length;
    while i < len do
        _print_indent(indent + 1);
        var ev = enum_vals.get(i);
        printf("%s = %d;\n", ev.name, ev.value);
        i += 1;
    end
    _print_indent(indent);
    printf("end\n");
end

def _print_ast_type ast, indent in
    tt_print_type_name(g_TypeTable, ast_type(ast));
end

def _print_ast_scope_resolve ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf("::");
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast_get_reference ast, indent in
    printf("#REF(");
    _print_ast(ast_expr(ast), indent);
    printf(")");
end

def _print_ast_offsetof ast, indent in
    printf("__offsetof(");
    _print_ast(ast_expr(ast), indent);
    printf(")");
end

def _print_ast ast, indent in
    var k = ast_kind(ast);
    if k == AstK::Ident then _print_ast_ident(ast, indent);
    elif k == AstK::Integer then _print_ast_integer(ast, indent);
    elif k == AstK::String then _print_ast_string(ast, indent);
    elif k == AstK::Call then _print_ast_call(ast, indent);
    elif k == AstK::BinOp then _print_ast_binop(ast, indent);
    elif k == AstK::Return then _print_ast_return(ast, indent);
    elif k == AstK::VarDecl then _print_ast_var_decl(ast, indent);
    elif k == AstK::VarAssign then _print_ast_var_assign(ast, indent);
    elif k == AstK::Def then _print_ast_def(ast, indent);
    elif k == AstK::IfElse then _print_ast_if_else(ast, indent, true);
    elif k == AstK::While then _print_ast_while(ast, indent);
    elif k == AstK::PointerRead then _print_ast_pointer_op(ast, indent);
    elif k == AstK::PointerWrite then _print_ast_pointer_op(ast, indent);
    elif k == AstK::Prefix then _print_ast_prefix(ast, indent);
    elif k == AstK::Const then _print_ast_const(ast, indent);
    elif k == AstK::Extern then _print_ast_extern(ast, indent);
    elif k == AstK::InlineAsm then _print_ast_inline_asm(ast, indent);
    elif k == AstK::Global then _print_ast_global(ast, indent);
    elif k == AstK::Break then _print_ast_break(ast, indent);
    elif k == AstK::Continue then _print_ast_continue(ast, indent);
    elif k == AstK::AssignOp then _print_ast_assign_op(ast, indent);
    elif k == AstK::Cast then _print_ast_cast(ast, indent);
    elif k == AstK::Struct then _print_ast_struct(ast, indent);
    elif k == AstK::MemberAccess then _print_ast_member_access(ast, indent);
    elif k == AstK::AssignMember then _print_ast_assign_member(ast, indent);
    elif k == AstK::SizeofExpr then _print_ast_sizeof_expr(ast, indent);
    elif k == AstK::SizeofType then _print_ast_sizeof_type(ast, indent);
    elif k == AstK::Enum then _print_ast_enum(ast, indent);
    elif k == AstK::Type then _print_ast_type(ast, indent);
    elif k == AstK::ScopeResolve then _print_ast_scope_resolve(ast, indent);
    elif k == AstK::GetReference then _print_ast_get_reference(ast, indent);
    elif k == AstK::Union then _print_ast_union(ast, indent);
    elif k == AstK::StaticAssert then _print_ast_static_assert(ast, indent);
    elif k == AstK::OffsetOf then _print_ast_offsetof(ast, indent);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end

def print_ast ast: ast in
    _print_ast(ast, 0);
    if ast_requires_semi(ast_kind(ast)) then
        printf(";\n");
    else
        printf("\n");
    end
end

def check_ast_kind expect: AstK, ast: ast in
    var actual = ast_kind(ast);
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end

def print_whole_ast roots in
    var i = 0; var len = roots.length;
    while i < len do
        print_ast(roots.get(i));
        i += 1;
    end
end

def _ast_deep_copy_vector vector, tt, st in
    var i = 0; var len = vector.length;
    var copy = Vector[ast]::new(len);
    while i < len do
        copy.push(_ast_deep_copy(vector.get(i), tt, st));
        i += 1;
    end
    return copy;
end


// these copy functions don't create copies of the tokens

def _ast_deep_copy_ident ast, tt, st in
    var sym = st_get_symbol(st, ast_ident(ast));
    return make_ast_ident(ast_token(ast), symbol_name(sym));
end

def _ast_deep_copy_integer ast, tt, st in
    return make_ast_integer(ast_token(ast), cast(ast_value(ast), int));
end

def _ast_deep_copy_string ast, tt, st in
    return make_ast_string(ast_token(ast), cast(ast_value(ast), String&).duplicate());
end

def _ast_deep_copy_call ast, tt, st in
    var copy_expr = _ast_deep_copy(ast_expr(ast), tt, st);
    var copy_args = _ast_deep_copy_vector(ast_args(ast), tt, st);
    return make_ast_call(ast_token(ast), copy_expr, copy_args);
end

def _ast_deep_copy_binop ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_binop(ast_token(ast), lhs_copy, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_return ast, tt, st in
    if ast_expr(ast) then
        return make_ast_return(ast_token(ast), _ast_deep_copy(ast_expr(ast), tt, st));
    else
        return make_ast_return(ast_token(ast), NULL);
    end
end

def _ast_deep_copy_var_decl ast, tt, st in
    var ident = ast_ident(ast);
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    return make_ast_var_decl(ast_token(ast), symbol_name(copy_sym));
end

def _ast_deep_copy_var_assign ast, tt, st in
    var ident = ast_ident(ast);
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    var assign_expr_copy = _ast_deep_copy(ast_assign_expr(ast), tt, st);
    return make_ast_var_assign(ast_token(ast), symbol_name(copy_sym), assign_expr_copy);
end

def _ast_deep_copy_def ast, tt, st in
    var def_ident = ast_ident(ast);
    var def_sym = st_get_exact_symbol(st, def_ident);
    var def_params = ast_params(ast);
    var def_copy_ident = strdup(def_ident);
    var def_copy_sym = st_make_def(st, def_copy_ident, def_sym.token);
    st_push_scope(st);
    var def_copy_params = Vector[cstr]::new(def_params.length);
    var def_copy_params_types = Vector[Type&]::new(def_params.length);
    var i = 0; var len = def_params.length;
    while i < len do
        var param = def_params.get(i);
        var param_sym = st_get_exact_symbol(st, param);
        assert(param_sym);
        var param_copy = strdup(param);
        var param_copy_sym = st_make_param(st, param_copy, param_sym.token);
        param_copy_sym.type = tt_substitute_type(tt, param_sym.type);
        def_copy_params_types.push(param_copy_sym.type);
        def_copy_params.push(param_copy); // push the cstr not the symbol!
        i += 1;
    end
    var return_type = tt_substitute_type(tt, type_def_return_type(def_sym.type));
    def_copy_sym.type = tt_make_anon_def(tt,
                            return_type, def_copy_params_types, type_def_varargs(def_sym.type));
    var def_copy_body = _ast_deep_copy_vector(ast_body(ast), tt, st);
    st_pop_scope(st);
    var copy_ast = make_ast_def(ast_token(ast), def_copy_ident, def_copy_params, def_copy_body);
    type_set_ast(def_copy_sym.type, copy_ast);
    return copy_ast;
end

def _ast_deep_copy_if_else ast, tt, st in
    var test_copy = _ast_deep_copy(ast_test(ast), tt, st);
    var conseq_copy = _ast_deep_copy_vector(ast_consequence(ast), tt, st);
    var altern_copy = _ast_deep_copy_vector(ast_alternative(ast), tt, st);
    return make_ast_if_else(ast_token(ast), test_copy, conseq_copy, altern_copy);
end

def _ast_deep_copy_while ast, tt, st in
    var test_copy = _ast_deep_copy(ast_test(ast), tt, st);
    var body_copy = _ast_deep_copy_vector(ast_body(ast), tt, st);
    return make_ast_while(ast_token(ast), test_copy, body_copy);
end

def _ast_deep_copy_pointer_op ast, tt, st in
    var args_copy = _ast_deep_copy_vector(ast_pop_args(ast), tt, st);
    return make_ast_pointer_op(ast_token(ast), ast_size(ast), ast_pop(ast), args_copy);
end

def _ast_deep_copy_prefix ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_prefix(ast_token(ast), ast_op(ast), expr_copy);
end

def _ast_deep_copy_const ast, tt, st in
    // here is a place where types would be replaced
    assert(false, "TODO: deep copy const\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_extern ast, tt, st in
    assert(false, "TODO: deep copy extern\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_inline_asm ast, tt, st in
    assert(false, "TODO: deep copy inline asm\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_global ast, tt, st in
    assert(false, "TODO: deep copy global\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_break ast, tt, st in
    return make_ast_break(ast_token(ast));
end

def _ast_deep_copy_continue ast, tt, st in
    return make_ast_continue(ast_token(ast));
end

def _ast_deep_copy_assign_op ast, tt, st in
    var sym = st_get_symbol(st, ast_ident(ast));
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_assign_op(ast_token(ast), sym.name, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_cast ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_cast(ast_token(ast), expr_copy, type);
end

def _ast_deep_copy_struct ast, tt, st in
    st_push_scope(st);
    var fields = ast_fields(ast);
    var fields_copy = Vector[Field&]::new(fields.length);
    var i = 0; var len = fields.length;
    while i < len do
        // fields aren't actually resolved with symbols so no need to create a copy of those
        var field_copy = field_make_copy(fields.get(i));
        field_copy.type = tt_substitute_type(tt, field_copy.type);
        fields_copy.push(field_copy);
        i += 1;
    end
    var struct_type = tt_substitute_type(tt, ast_struct(ast));
    var struct_changed = struct_type != ast_struct(ast);
    var defs = ast_defs(ast);
    var defs_copy = Vector[ast]::new(defs.length);
    var defs_copy_symbols = Vector[Symbol&]::new(defs.length);
    i = 0; len = defs.length;
    while i < len do
        var def_ = defs.get(i);
        assert(ast_kind(def_) == AstK::Def);
        var def_copy = _ast_deep_copy_def(def_, tt, st);
        var def_copy_sym = st_get_symbol(st, ast_ident(def_copy));
        assert(def_copy_sym);
        def_copy_sym.owned_by = struct_type;
        defs_copy.push(def_copy);
        defs_copy_symbols.push(def_copy_sym);
        i += 1;
    end
    var struct_copy = make_ast_struct(ast_token(ast), struct_type, fields_copy, defs_copy);
    if struct_changed then
        type_set_ast(struct_type, struct_copy);
        type_set_struct_fields(struct_type, fields_copy);
        type_set_struct_defs(struct_type, defs_copy_symbols);
    end
    st_pop_scope(st);
    return struct_copy;
end

def _ast_deep_copy_union ast, tt, st in
    st_push_scope(st);
    var fields = ast_fields(ast);
    var fields_copy = Vector[Field&]::new(fields.length);
    var i = 0; var len = fields.length;
    while i < len do
        // fields aren't actually resolved with symbols so no need to create a copy of those
        var field_copy = field_make_copy(fields.get(i));
        field_copy.type = tt_substitute_type(tt, field_copy.type);
        fields_copy.push(field_copy);
        i += 1;
    end
    var union_type = tt_substitute_type(tt, ast_union(ast));
    var union_changed = union_type != ast_union(ast);
    var union_copy = make_ast_union(ast_token(ast), union_type, fields_copy);
    if union_changed then
        type_set_ast(union_type, union_copy);
        type_set_union_fields(union_type, fields_copy);
    end
    st_pop_scope(st);
    return union_copy;
end

def _ast_deep_copy_member_access ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_member_access(ast_token(ast), expr_copy, ast_member(ast));
end

def _ast_deep_copy_assign_member ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_assign_member(ast_token(ast), lhs_copy, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_sizeof_expr ast, tt, st in
    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK::Ident then
        var type = tt_get_type_or_null(tt, ast_ident(expr));
        if type then
            type = tt_substitute_type(tt, type);
            return make_ast_sizeof_type(ast_token(ast), type);
        end
        printf("not a type\n");
        tt_dump_cur_scope(tt);
    end
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_sizeof_expr(ast_token(ast), expr_copy);
end

def _ast_deep_copy_sizeof_type ast, tt, st in
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_sizeof_type(ast_token(ast), type);
end

def _ast_deep_copy_enum ast, tt, st in
    assert(false, "TODO: deep copy enum\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_type ast, tt, st in
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_type(ast_token(ast), type);
end

def _ast_deep_copy_scope_resolve ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_scope_resolve(ast_token(ast), lhs_copy, rhs_copy);
end

def _ast_deep_copy_get_reference ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_get_reference(ast_token(ast), expr_copy);
end

def _ast_deep_copy_static_assert ast, tt, st in
    var args_copy = _ast_deep_copy_vector(ast_args(ast), tt, st);
    return make_ast_static_assert(ast_token(ast), args_copy);
end

def _ast_deep_copy_offsetof ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_offsetof(ast_token(ast), expr_copy);
end

def _ast_deep_copy ast, tt, st in
    var k = ast_kind(ast);
    if k == AstK::Ident then return _ast_deep_copy_ident(ast, tt, st);
    elif k == AstK::Integer then return _ast_deep_copy_integer(ast, tt, st);
    elif k == AstK::String then return _ast_deep_copy_string(ast, tt, st);
    elif k == AstK::Call then return _ast_deep_copy_call(ast, tt, st);
    elif k == AstK::BinOp then return _ast_deep_copy_binop(ast, tt, st);
    elif k == AstK::Return then return _ast_deep_copy_return(ast, tt, st);
    elif k == AstK::VarDecl then return _ast_deep_copy_var_decl(ast, tt, st);
    elif k == AstK::VarAssign then return _ast_deep_copy_var_assign(ast, tt, st);
    elif k == AstK::Def then return _ast_deep_copy_def(ast, tt, st);
    elif k == AstK::IfElse then return _ast_deep_copy_if_else(ast, tt, st);
    elif k == AstK::While then return _ast_deep_copy_while(ast, tt, st);
    elif k == AstK::PointerRead then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK::PointerWrite then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK::Prefix then return _ast_deep_copy_prefix(ast, tt, st);
    elif k == AstK::Const then return _ast_deep_copy_const(ast, tt, st);
    elif k == AstK::Extern then return _ast_deep_copy_extern(ast, tt, st);
    elif k == AstK::InlineAsm then return _ast_deep_copy_inline_asm(ast, tt, st);
    elif k == AstK::Global then return _ast_deep_copy_global(ast, tt, st);
    elif k == AstK::Break then return _ast_deep_copy_break(ast, tt, st);
    elif k == AstK::Continue then return _ast_deep_copy_continue(ast, tt, st);
    elif k == AstK::AssignOp then return _ast_deep_copy_assign_op(ast, tt, st);
    elif k == AstK::Cast then return _ast_deep_copy_cast(ast, tt, st);
    elif k == AstK::Struct then return _ast_deep_copy_struct(ast, tt, st);
    elif k == AstK::MemberAccess then return _ast_deep_copy_member_access(ast, tt, st);
    elif k == AstK::AssignMember then return _ast_deep_copy_assign_member(ast, tt, st);
    elif k == AstK::SizeofExpr then return _ast_deep_copy_sizeof_expr(ast, tt, st);
    elif k == AstK::SizeofType then return _ast_deep_copy_sizeof_type(ast, tt, st);
    elif k == AstK::Enum then return _ast_deep_copy_enum(ast, tt, st);
    elif k == AstK::Type then return _ast_deep_copy_type(ast, tt, st);
    elif k == AstK::ScopeResolve then return _ast_deep_copy_scope_resolve(ast, tt, st);
    elif k == AstK::GetReference then return _ast_deep_copy_get_reference(ast, tt, st);
    elif k == AstK::Union then return _ast_deep_copy_union(ast, tt, st);
    elif k == AstK::StaticAssert then return _ast_deep_copy_static_assert(ast, tt, st);
    elif k == AstK::OffsetOf then return _ast_deep_copy_offsetof(ast, tt, st);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end
