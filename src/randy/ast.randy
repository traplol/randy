
enum PointerOp in
    Read;
    Write;
end

const AstK_Ident        = 0;
const AstK_Integer      = 1;
const AstK_String       = 2;
const AstK_Call         = 3;
const AstK_BinOp        = 4;
const AstK_Return       = 5;
const AstK_VarDecl      = 6;
const AstK_VarAssign    = 7;
const AstK_Def          = 8;
const AstK_IfElse       = 9;
const AstK_While        = 10;
const AstK_PointerRead  = 11;
const AstK_PointerWrite = 12;
const AstK_Prefix       = 13;
const AstK_Const        = 14;
const AstK_Extern       = 15;
const AstK_InlineAsm    = 16;
const AstK_Global       = 17;
const AstK_Break        = 18;
const AstK_Continue     = 19;
const AstK_AssignOp     = 20;
const AstK_Cast         = 21;
const AstK_Struct       = 22;
const AstK_MemberAccess = 23;
const AstK_AssignMember = 24;
const AstK_SizeofExpr   = 25;
const AstK_SizeofType   = 26;
const AstK_Enum         = 27;
const AstK_Type         = 28;
const AstK_ScopeResolve = 29;

def ast_kind_cstr k: int in
    if k == AstK_Ident then return "AstK_Ident"; end
    if k == AstK_Integer then return "AstK_Integer"; end
    if k == AstK_String then return "AstK_String"; end
    if k == AstK_Call then return "AstK_Call"; end
    if k == AstK_BinOp then return "AstK_BinOp"; end
    if k == AstK_Return then return "AstK_Return"; end
    if k == AstK_VarDecl then return "AstK_VarDecl"; end
    if k == AstK_VarAssign then return "AstK_VarAssign"; end
    if k == AstK_Def then return "AstK_Def"; end
    if k == AstK_IfElse then return "AstK_IfElse"; end
    if k == AstK_While then return "AstK_While"; end
    if k == AstK_PointerRead then return "AstK_PointerRead"; end
    if k == AstK_PointerWrite then return "AstK_PointerWrite"; end
    if k == AstK_Prefix then return "AstK_Prefix"; end
    if k == AstK_Const then return "AstK_Const"; end
    if k == AstK_Extern then return "AstK_Extern"; end
    if k == AstK_InlineAsm then return "AstK_InlineAsm"; end
    if k == AstK_Global then return "AstK_Global"; end
    if k == AstK_Break then return "AstK_Break"; end
    if k == AstK_Continue then return "AstK_Continue"; end
    if k == AstK_AssignOp then return "AstK_AssignOp"; end
    if k == AstK_Cast then return "AstK_Cast"; end
    if k == AstK_Struct then return "AstK_Struct"; end
    if k == AstK_MemberAccess then return "AstK_MemberAccess"; end
    if k == AstK_AssignMember then return "AstK_AssignMember"; end
    if k == AstK_SizeofExpr then return "AstK_SizeofExpr"; end
    if k == AstK_SizeofType then return "AstK_SizeofType"; end
    if k == AstK_Enum then return "AstK_Enum"; end
    if k == AstK_Type then return "AstK_Type"; end
    if k == AstK_ScopeResolve then return "AstK_ScopeResolve"; end
    return "AstK_OUT_OF_RANGE";
end

def ast_requires_semi k in
    if k == AstK_Def then return false;
    elif k == AstK_IfElse then return false;
    elif k == AstK_While then return false;
    elif k == AstK_InlineAsm then return false;
    elif k == AstK_Struct then return false;
    elif k == AstK_Enum then return false;
    else
        return true;
    end
end

const TAST_kind        = 0;  // AstK
const TAST_is_expr     = 4;  // bool
const TAST_token       = 8;  // Token&
// This represents each AST node as a c-"union"
// Ident
const TAST_ident       = 16; // cstr
// Integer, String
const TAST_value       = 16; // Union(int, string)
// Call
const TAST_expr        = 16; // ast
const TAST_args        = 24; // ast Vector&
// Prefix
const TAST_expr        = 16; // ast
const TAST_op          = 24; // TK
// BinOp
const TAST_lhs         = 16; // ast
const TAST_op          = 24; // TK
const TAST_rhs         = 32; // ast
// IfElse
const TAST_test        = 16; // ast
const TAST_consequence = 24; // ast Vector&
const TAST_alternative = 32; // ast Vector&
// While
const TAST_test        = 16; // ast
const TAST_body        = 24; // ast Vector&
// PointerRead, PointerWrite
const TAST_size        = 16; // int
const TAST_pop         = 24; // PointerOp
const TAST_pop_args    = 32; // ast Vector&
// VarDecl
const TAST_ident       = 16; // cstr
// VarAssign
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// AssignOp
const TAST_ident       = 16; // cstr
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// Return
const TAST_expr        = 16; // ast
// Def
const TAST_ident       = 16; // cstr
const TAST_body        = 24; // ast Vector&
const TAST_params      = 32; // cstr Vector&
// Const
const TAST_ident       = 16; // cstr
const TAST_assign_expr = 32; // ast
// Extern
const TAST_ident       = 16; // cstr
const TAST_varargs     = 24; // bool
const TAST_params      = 32; // cstr Vector&
// InlineAsm
const TAST_ident       = 16; // cstr
const TAST_asm         = 24; // cstr
// Cast
const TAST_expr        = 16; // ast
const TAST_type        = 24; // type
// Struct
const TAST_struct      = 16; // type
const TAST_fields      = 24; // field Vector&
const TAST_defs        = 32; // ast_def Vector&
// MemberAccess
const TAST_expr        = 16; // ast
const TAST_member      = 24; // cstr
// AssignMember
const TAST_expr        = 16; // ast_member_access
const TAST_op          = 24; // TK
const TAST_assign_expr = 32; // ast
// SizeofExpr/Type
const TAST_expr        = 16; // ast
const TAST_type        = 24; // type
// Enum
const TAST_ident       = 16; // cstr
const TAST_enum        = 24; // type
const TAST_values      = 32; // EnumValue& Vector&
// Type
const TAST_type        = 24; // type
// ScopeResolve
const TAST_lhs         = 16; // Union(type_ast, scope_resolve_ast)
const TAST_rhs         = 32; // Union(type_ast, ident_ast)

const sizeof_TAST      = 40;

def _make_ast kind: int, is_expr: bool, token: Token& -> ast in
    var self = malloc(sizeof_TAST);
    u32!(self + TAST_kind, kind);
    u8!(self + TAST_is_expr, is_expr);
    u64!(self + TAST_token, token);
    return cast(self, ast);
end

def make_ast_ident token: Token&, ident: cstr -> ast in
    var self = _make_ast(AstK_Ident, true, token);
    u64!(self + TAST_ident, ident);
    return self;
end

def make_ast_integer token: Token&, value: int -> ast in
    var self = _make_ast(AstK_Integer, true, token);
    u64!(self + TAST_value, value);
    return self;
end

def make_ast_string token: Token&, value: String& -> ast in
    var self = _make_ast(AstK_String, true, token);
    u64!(self + TAST_value, value);
    return self;
end

def make_ast_call token: Token&, expr: ast, args: Vector& -> ast in
    var self = _make_ast(AstK_Call, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_args, args);
    return self;
end

def make_ast_binop token: Token&, lhs: ast, op: TK, rhs: ast -> ast in
    var self = _make_ast(AstK_BinOp, true, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def make_ast_return token: Token&, expr: ast -> ast in
    var self = _make_ast(AstK_Return, false, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def make_ast_var_decl token: Token&, ident: cstr -> ast in
    var self = _make_ast(AstK_VarDecl, false, token);
    u64!(self + TAST_ident, ident);
    return self;
end

def make_ast_var_assign token: Token&, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK_VarAssign, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_assign_op token: Token&, ident: cstr, op: TK, expr: ast -> ast in
    var self = _make_ast(AstK_AssignOp, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_op, op);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_def token: Token&, ident: cstr, params: Vector&, body: Vector& -> ast in
    var self = _make_ast(AstK_Def, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_body, body);
    u64!(self + TAST_params, params);
    return self;
end

def make_ast_if_else token: Token&, test: ast, conseq: Vector&, altern: Vector& -> ast in
    var self = _make_ast(AstK_IfElse, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_consequence, conseq);
    u64!(self + TAST_alternative, altern);
    return self;
end

def make_ast_while token: Token&, test: ast, body: Vector& -> ast in
    var self = _make_ast(AstK_While, false, token);
    u64!(self + TAST_test, test);
    u64!(self + TAST_body, body);
    return self;
end

def make_ast_pointer_op token: Token&, size: int, op: PointerOp, args: Vector& -> ast in
    var astk; var is_expr;
    if op == PointerOp::Read then
        astk = AstK_PointerRead;
        is_expr = true;
    else
        astk = AstK_PointerWrite;
        is_expr = false;
    end
    var self = _make_ast(astk, is_expr, token);
    u64!(self + TAST_size, size);
    u64!(self + TAST_op, op);
    u64!(self + TAST_pop_args, args);
    return self;
end

def make_ast_prefix token: Token&, op: TK, expr: ast -> ast in
    var self = _make_ast(AstK_Prefix, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_op, op);
    return self;
end

def make_ast_const token: Token&, ident: cstr, expr: ast -> ast in
    var self = _make_ast(AstK_Const, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, expr);
    return self;
end

def make_ast_extern token: Token&, ident: cstr, type: type -> ast in
    var self = _make_ast(AstK_Extern, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_inline_asm token: Token&, ident: cstr, asmcode: cstr -> ast in
    var self = _make_ast(AstK_InlineAsm, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_asm, asmcode);
    return self;
end

def make_ast_global token: Token&, ident: cstr, assign_expr: ast -> ast in
    var self = _make_ast(AstK_Global, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_assign_expr, assign_expr);
    return self;
end

def make_ast_break token: Token& -> ast in
    return _make_ast(AstK_Break, false, token);
end

def make_ast_continue token: Token& -> ast in
    return _make_ast(AstK_Continue, false, token);
end

def make_ast_cast token: Token&, expr: ast, type: type -> ast in
    var self = _make_ast(AstK_Cast, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_struct token: Token&, struct_: type, fields: Vector&, defs: Vector& -> ast in
    var self = _make_ast(AstK_Struct, false, token);
    u64!(self + TAST_struct, struct_);
    u64!(self + TAST_fields, fields);
    u64!(self + TAST_defs, defs);
    return self;
end

def make_ast_member_access token: Token&, expr: ast, member: cstr -> ast in
    var self = _make_ast(AstK_MemberAccess, true, token);
    u64!(self + TAST_expr, expr);
    u64!(self + TAST_member, member);
    return self;
end

def make_ast_assign_member token: Token&, lhs: ast, op: TK, rhs: ast -> ast in
    assert(ast_kind(lhs) == AstK_MemberAccess,
        "Compiler bug: cannot make_ast_assign_member where lhs is %s (%d)\n",
        ast_kind_cstr(ast_kind(lhs)),
        ast_kind(lhs));
    var self = _make_ast(AstK_AssignMember, false, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_op, op);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def make_ast_sizeof_expr token: Token&, expr: ast -> ast in
    if ast_kind(expr) == AstK_Type then
        return make_ast_sizeof_type(token, ast_type(expr));
    end
    var self = _make_ast(AstK_SizeofExpr, true, token);
    u64!(self + TAST_expr, expr);
    return self;
end

def make_ast_sizeof_type token: Token&, type: type -> ast in
    var self = _make_ast(AstK_SizeofType, true, token);
    u64!(self + TAST_type, type);
    return self;
end

def ast_change_sizeof_expr_to_type self: ast, type: type in
    assert(ast_kind(self) == AstK_SizeofExpr);
    u32!(self + TAST_kind, AstK_SizeofType);
    u64!(self + TAST_type, type);
end

def make_ast_enum token: Token&, ident: cstr, enum_: type, values: Vector& -> ast in
    var self = _make_ast(AstK_Enum, false, token);
    u64!(self + TAST_ident, ident);
    u64!(self + TAST_enum, enum_);
    u64!(self + TAST_values, values);
    return self;
end

def make_ast_type token: Token&, type: type -> ast in
    var self = _make_ast(AstK_Type, false, token);
    u64!(self + TAST_type, type);
    return self;
end

def make_ast_scope_resolve token: Token&, lhs: ast, rhs: ast -> ast in
    var self = _make_ast(AstK_ScopeResolve, true, token);
    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_rhs, rhs);
    return self;
end

def ast_change_member_access_to_scope_access self: ast, type: type, member: Symbol& in
    assert(ast_kind(self) == AstK_MemberAccess);
    u32!(self + TAST_kind, AstK_ScopeResolve);

    var lhs = make_ast_type(ast_token(self), type);
    var rhs = make_ast_ident(ast_token(self), member.name);

    u64!(self + TAST_lhs, lhs);
    u64!(self + TAST_rhs, rhs);
end

def ast_kind self: ast in return cast(u32@(self + TAST_kind), int); end
def ast_is_expr self: ast in return cast(u8@(self + TAST_is_expr), bool); end
def ast_token self: ast in return cast(u64@(self + TAST_token), Token&); end
def ast_alternative self: ast in return cast(u64@(self + TAST_alternative), Vector&); end
def ast_args self: ast in return cast(u64@(self + TAST_args), Vector&); end
def ast_asm self: ast in return cast(u64@(self + TAST_asm), cstr); end
def ast_assign_expr self: ast in return cast(u64@(self + TAST_assign_expr), ast); end
def ast_body self: ast in return cast(u64@(self + TAST_body), Vector&); end
def ast_consequence self: ast in return cast(u64@(self + TAST_consequence), Vector&); end
def ast_expr self: ast in return cast(u64@(self + TAST_expr), ast); end
def ast_ident self: ast in return cast(u64@(self + TAST_ident), cstr); end
def ast_lhs self: ast in return cast(u64@(self + TAST_lhs), ast); end
def ast_op self: ast in return cast(u64@(self + TAST_op), TK); end
def ast_pop self: ast in return cast(u64@(self + TAST_op), PointerOp); end
def ast_params self: ast in return cast(u64@(self + TAST_params), Vector&); end
def ast_pop_args self: ast in return cast(u64@(self + TAST_pop_args), Vector&); end
def ast_rhs self: ast in return cast(u64@(self + TAST_rhs), ast); end
def ast_size self: ast in return cast(u64@(self + TAST_size), int); end
def ast_test self: ast in return cast(u64@(self + TAST_test), ast); end
def ast_value self: ast in return cast(u64@(self + TAST_value), ptr); end
def ast_varargs self: ast in return cast(u64@(self + TAST_varargs), bool); end
def ast_type self: ast in return cast(u64@(self + TAST_type), type); end
def ast_fields self: ast in return cast(u64@(self + TAST_fields), Vector&); end
def ast_defs self: ast in return cast(u64@(self + TAST_defs), Vector&); end
def ast_member self: ast in return cast(u64@(self + TAST_member), cstr); end
def ast_struct self: ast in return cast(u64@(self + TAST_struct), type); end
def ast_values self: ast in return cast(u64@(self + TAST_values), Vector&); end

def ast_set_struct self: ast, struct_: type in
    assert(ast_kind(self) == AstK_Struct);
    u64!(self + TAST_struct, struct_);
end

def ast_src_loc self: ast in
    var token = ast_token(self);
    return token_src_loc(token);
end

def print_ast_src_loc self: ast in
    print_token_loc(ast_token(self));
end

def _print_indent indent: int in
    var i = 0;
    while i < indent do
        printf("    ");
        i += 1;
    end
end

def _print_args args: Vector&, indent: int in
    var i = 0;
    var len = args.length;
    while i < len do
        _print_ast(cast(vector_get(args, i), ast), indent);
        i += 1;
        if i < len then
            printf(", ");
        end
    end
end

def _print_ast_ident ast, indent in
    printf("%s", ast_ident(ast));
end

def _print_ast_integer ast, indent in
    printf("%ld", cast(ast_value(ast), int));
end

def _print_ast_string ast, indent in
    printf("\"");
    var string = cast(ast_value(ast), String&);
    var i = 0; var len = string.length;
    while i < len do
        var c = string_get(string, i);
        if c == '\n' then
            printf("\\n");
        elif c == '"' then
            printf("\\\"");
        elif c == '\t' then
            printf("\\t");
        elif c == '\0' then
            printf("\\0");
        elif c == '\r' then
            printf("\\r");
        else
            printf("%c", c);
        end
        i += 1;
    end
    printf("\"");
end

def _print_ast_call ast, indent in
    _print_ast(ast_expr(ast), indent);
    printf("(");
    _print_args(ast_args(ast), indent);
    printf(")");
end

def _print_ast_binop ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf(" %s ", ast_token(ast).cstr);
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast_return ast, indent in
    var expr = ast_expr(ast);
    if expr then
        printf("return ");
        _print_ast(expr, indent);
    else
        printf("return");
    end
end

def _print_ast_var_decl ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
end

def _print_ast_var_assign ast, indent in
    printf("var %s", ast_ident(ast));
    var symbol = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(symbol, "symbol is NULL");
    var type = symbol_type(symbol);
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
    printf(" = ");
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_assign_op ast, indent in
    printf("%s ", ast_ident(ast));
    var op = ast_op(ast);
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf("%s ", op_str);
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_body body, indent in
    var i = 0;
    var len = body.length;
    var stmt;
    while i < len do
        stmt = cast(vector_get(body, i), ast);
        _print_indent(indent);
        _print_ast(stmt, indent);
        if ast_requires_semi(ast_kind(stmt)) then
            printf(";\n");
        else
            printf("\n");
        end
        i += 1;
    end
end

def _print_ast_def ast, indent in
    var def_sym = st_get_symbol(g_SymbolTable, ast_ident(ast));
    assert(def_sym);
    if def_sym and def_sym.owned_by then
        printf("def ");
        tt_print_type_name(g_TypeTable, def_sym.owned_by);
        printf("::%s", ast_ident(ast));
    else
        printf("def %s", ast_ident(ast));
    end
    var i = 0;
    var params = ast_params(ast);
    var len = params.length;
    while i < len do
        var param_name = vector_get(params, i);
        printf(" %s", param_name);
        var param_sym = st_get_symbol(g_SymbolTable, param_name);
        assert(param_sym, "psym is NULL");
        var param_type = symbol_type(param_sym);
        if param_type then
            printf(": ");
            tt_print_type_name(g_TypeTable, param_type);
        end
        i += 1;
        if i < len then
            printf(",");
        end
    end
    var def_type = symbol_type(def_sym);
    if def_type then
        assert(type_is_def(def_type), "def_type not def.\n");
        var ret_type = type_def_return_type(def_type);
        printf(" -> ");
        tt_print_type_name(g_TypeTable, ret_type);
    end
    printf(" in\n");
    _print_ast_body(ast_body(ast), indent + 1);
    _print_indent(indent); printf("end\n");
end

def _print_ast_if_else ast, indent, print_if in
    if print_if then
        printf("if ");
    end
    _print_ast(ast_test(ast), indent);
    printf(" then\n");
    var conseq = ast_consequence(ast);
    var altern = ast_alternative(ast);
    _print_ast_body(conseq, indent+1);
    if altern.length > 0 then
        if altern.length == 1 and AstK_IfElse == ast_kind(vector_get(altern, 0)) then
            _print_indent(indent); printf("elif ");
            _print_ast_if_else(cast(vector_get(altern, 0), ast), indent, false);
            return;
        else
            _print_indent(indent); printf("else\n");
            _print_ast_body(altern, indent+1);
        end
    end
    _print_indent(indent); printf("end");
end

def _print_ast_while ast, indent in
    printf("while ");
    _print_ast(ast_test(ast), indent);
    printf(" do\n");
    _print_ast_body(ast_body(ast), indent+1);
    _print_indent(indent); printf("end");
end

def _print_ast_pointer_op ast, indent in
    printf("%s(", ast_token(ast).cstr);
    _print_args(ast_pop_args(ast), indent);
    printf(")");
end

def _print_ast_prefix ast, indent in
    var token = ast_token(ast);
    // FIXME == TK::KW_assert is a hack.
    if token.kind == TK::KW_not or token.kind == TK::KW_assert then
        printf("not ");
    else
        printf("%s", token.cstr);
    end
    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK_BinOp then
        printf("(");
    end
    _print_ast(ast_expr(ast), indent);
    if ast_kind(expr) == AstK_BinOp then
        printf(")");
    end
end

def _print_ast_const ast, indent in
    printf("const %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_global ast, indent in
    printf("global %s = ", ast_ident(ast));
    _print_ast(ast_assign_expr(ast), indent);
end

def _print_ast_extern ast, indent in
    printf("extern %s: ", ast_ident(ast));
    tt_print_type_name(g_TypeTable, ast_type(ast));
end

def _print_ast_inline_asm ast, indent in
    printf("asm %s in\n", ast_ident(ast));
    printf("\"%s\"\n", ast_asm(ast));
    printf("end\n");
end

def _print_ast_break ast, indent in
    printf("break");
end

def _print_ast_continue ast, indent in
    printf("continue");
end

def _print_ast_cast ast, indent in
    printf("cast(");
    _print_ast(ast_expr(ast), indent);
    printf(", ");
    tt_print_type_name(g_TypeTable, ast_type(ast));
    printf(")");
end

def _print_ast_struct ast, indent in
    printf("struct ");
    tt_print_type_name(g_TypeTable, ast_struct(ast));
    printf(" in\n");
    var fields = ast_fields(ast);
    var i = 0; var len = fields.length;
    while i < len do
        var field = cast(vector_get(fields, i), Field&);
        _print_indent(indent+1);
        printf("%s: ", field.name);
        tt_print_type_name(g_TypeTable, field.type);
        printf(";\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

def _print_ast_member_access ast, indent in
    var expr = ast_expr(ast);
    printf("(");
    var member = ast_member(ast);
    _print_ast(expr, indent);
    printf(".%s)", member);
end

def _print_ast_assign_member ast, indent in
    _print_ast(ast_lhs(ast), indent);
    var op = ast_op(ast);
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf(" %s ", op_str);
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast_sizeof_expr ast, indent in
    printf("__sizeof(");
    _print_ast(ast_expr(ast), indent);
    printf(")");
end

def _print_ast_sizeof_type ast, indent in
    printf("__sizeof(");
    tt_print_type_name(g_TypeTable, ast_type(ast));
    printf(")");
end

def _print_ast_enum ast, indent in
    var enum_name = ast_ident(ast);
    var enum_vals = ast_values(ast);

    printf("enum %s in\n", enum_name);
    var i = 0; var len = enum_vals.length;
    while i < len do
        _print_indent(indent + 1);
        var ev = cast(vector_get(enum_vals, i), EnumValue&);
        printf("%s = %d;\n", ev.name, ev.value);
        i += 1;
    end
    _print_indent(indent);
    printf("end\n");
end

def _print_ast_type ast, indent in
    tt_print_type_name(g_TypeTable, ast_type(ast));
end

def _print_ast_scope_resolve ast, indent in
    _print_ast(ast_lhs(ast), indent);
    printf("::");
    _print_ast(ast_rhs(ast), indent);
end

def _print_ast ast, indent in
    var k = ast_kind(ast);
    if k == AstK_Ident then _print_ast_ident(ast, indent);
    elif k == AstK_Integer then _print_ast_integer(ast, indent);
    elif k == AstK_String then _print_ast_string(ast, indent);
    elif k == AstK_Call then _print_ast_call(ast, indent);
    elif k == AstK_BinOp then _print_ast_binop(ast, indent);
    elif k == AstK_Return then _print_ast_return(ast, indent);
    elif k == AstK_VarDecl then _print_ast_var_decl(ast, indent);
    elif k == AstK_VarAssign then _print_ast_var_assign(ast, indent);
    elif k == AstK_Def then _print_ast_def(ast, indent);
    elif k == AstK_IfElse then _print_ast_if_else(ast, indent, true);
    elif k == AstK_While then _print_ast_while(ast, indent);
    elif k == AstK_PointerRead then _print_ast_pointer_op(ast, indent);
    elif k == AstK_PointerWrite then _print_ast_pointer_op(ast, indent);
    elif k == AstK_Prefix then _print_ast_prefix(ast, indent);
    elif k == AstK_Const then _print_ast_const(ast, indent);
    elif k == AstK_Extern then _print_ast_extern(ast, indent);
    elif k == AstK_InlineAsm then _print_ast_inline_asm(ast, indent);
    elif k == AstK_Global then _print_ast_global(ast, indent);
    elif k == AstK_Break then _print_ast_break(ast, indent);
    elif k == AstK_Continue then _print_ast_continue(ast, indent);
    elif k == AstK_AssignOp then _print_ast_assign_op(ast, indent);
    elif k == AstK_Cast then _print_ast_cast(ast, indent);
    elif k == AstK_Struct then _print_ast_struct(ast, indent);
    elif k == AstK_MemberAccess then _print_ast_member_access(ast, indent);
    elif k == AstK_AssignMember then _print_ast_assign_member(ast, indent);
    elif k == AstK_SizeofExpr then _print_ast_sizeof_expr(ast, indent);
    elif k == AstK_SizeofType then _print_ast_sizeof_type(ast, indent);
    elif k == AstK_Enum then _print_ast_enum(ast, indent);
    elif k == AstK_Type then _print_ast_type(ast, indent);
    elif k == AstK_ScopeResolve then _print_ast_scope_resolve(ast, indent);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end

def print_ast ast: ast in
    _print_ast(ast, 0);
    if ast_requires_semi(ast_kind(ast)) then
        printf(";\n");
    else
        printf("\n");
    end
end

def check_ast_kind expect: int, ast: ast in
    var actual = ast_kind(ast);
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end

def print_whole_ast roots in
    var i = 0; var len = roots.length;
    while i < len do
        print_ast(vector_get(roots, i));
        i += 1;
    end
end

def print_compile_ast compile_order: Vector& in
    var i = 0; var len = compile_order.length;
    while i < len do
        print_ast(vector_get(compile_order, i));
        i += 1;
    end
end

def _ast_deep_copy_vector vector, tt, st in
    var i = 0; var len = vector.length;
    var copy = make_vector(len);
    while i < len do
        vector_push(copy, _ast_deep_copy(cast(vector_get(vector, i), ast), tt, st));
        i += 1;
    end
    return copy;
end


// these copy functions don't create copies of the tokens

def _ast_deep_copy_ident ast, tt, st in
    var sym = st_get_symbol(st, ast_ident(ast));
    return make_ast_ident(ast_token(ast), symbol_name(sym));
end

def _ast_deep_copy_integer ast, tt, st in
    return make_ast_integer(ast_token(ast), cast(ast_value(ast), int));
end

def _ast_deep_copy_string ast, tt, st in
    return make_ast_string(ast_token(ast), string_duplicate(ast_value(ast)));
end

def _ast_deep_copy_call ast, tt, st in
    var copy_expr = _ast_deep_copy(ast_expr(ast), tt, st);
    var copy_args = _ast_deep_copy_vector(ast_args(ast), tt, st);
    return make_ast_call(ast_token(ast), copy_expr, copy_args);
end

def _ast_deep_copy_binop ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_binop(ast_token(ast), lhs_copy, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_return ast, tt, st in
    if ast_expr(ast) then
        return make_ast_return(ast_token(ast), _ast_deep_copy(ast_expr(ast), tt, st));
    else
        return make_ast_return(ast_token(ast), NULL);
    end
end

def _ast_deep_copy_var_decl ast, tt, st in
    // here is a place to types would be replaced
    var ident = ast_ident(ast);
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    return make_ast_var_decl(ast_token(ast), symbol_name(copy_sym));
end

def _ast_deep_copy_var_assign ast, tt, st in
    var ident = ast_ident(ast);
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    var assign_expr_copy = _ast_deep_copy(ast_assign_expr(ast), tt, st);
    return make_ast_var_assign(ast_token(ast), symbol_name(copy_sym), assign_expr_copy);
end

def _ast_deep_copy_def ast, tt, st in
    var def_ident = ast_ident(ast);
    var def_sym = st_get_symbol(st, def_ident);
    var def_params = ast_params(ast);
    var def_copy_ident = strdup(def_ident);
    var def_copy_sym = st_make_def(st, def_copy_ident, def_sym.token);
    st_push_scope(st);
    var def_copy_params = make_vector(def_params.length);
    var def_copy_params_types = make_vector(def_params.length);
    var i = 0; var len = def_params.length;
    while i < len do
        var param = vector_get(def_params, i);
        var param_sym = st_get_exact_symbol(st, param);
        assert(param_sym);
        var param_copy = strdup(param);
        var param_copy_sym = st_make_param(st, param_copy, param_sym.token);
        param_copy_sym.type = tt_substitute_type(tt, param_sym.type);
        vector_push(def_copy_params_types, param_copy_sym.type);
        vector_push(def_copy_params, param_copy); // push the cstr not the symbol!
        i += 1;
    end
    var return_type = tt_substitute_type(tt, type_def_return_type(def_sym.type));
    def_copy_sym.type = tt_make_anon_def(tt,
                            return_type, def_copy_params_types, type_def_varargs(def_sym.type));
    var def_copy_body = _ast_deep_copy_vector(ast_body(ast), tt, st);
    st_pop_scope(st);
    var copy_ast = make_ast_def(ast_token(ast), def_copy_ident, def_copy_params, def_copy_body);
    type_set_ast(def_copy_sym.type, copy_ast);
    return copy_ast;
end

def _ast_deep_copy_if_else ast, tt, st in
    var test_copy = _ast_deep_copy(ast_test(ast), tt, st);
    var conseq_copy = _ast_deep_copy_vector(ast_consequence(ast), tt, st);
    var altern_copy = _ast_deep_copy_vector(ast_alternative(ast), tt, st);
    return make_ast_if_else(ast_token(ast), test_copy, conseq_copy, altern_copy);
end

def _ast_deep_copy_while ast, tt, st in
    var test_copy = _ast_deep_copy(ast_test(ast), tt, st);
    var body_copy = _ast_deep_copy_vector(ast_body(ast), tt, st);
    return make_ast_while(ast_token(ast), test_copy, body_copy);
end

def _ast_deep_copy_pointer_op ast, tt, st in
    var args_copy = _ast_deep_copy_vector(ast_pop_args(ast), tt, st);
    return make_ast_pointer_op(ast_token(ast), ast_size(ast), ast_pop(ast), args_copy);
end

def _ast_deep_copy_prefix ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_prefix(ast_token(ast), ast_op(ast), expr_copy);
end

def _ast_deep_copy_const ast, tt, st in
    // here is a place where types would be replaced
    assert(false, "TODO: deep copy const\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_extern ast, tt, st in
    assert(false, "TODO: deep copy extern\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_inline_asm ast, tt, st in
    assert(false, "TODO: deep copy inline asm\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_global ast, tt, st in
    assert(false, "TODO: deep copy global\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_break ast, tt, st in
    return make_ast_break(ast_token(ast));
end

def _ast_deep_copy_continue ast, tt, st in
    return make_ast_continue(ast_token(ast));
end

def _ast_deep_copy_assign_op ast, tt, st in
    var sym = st_get_symbol(st, ast_ident(ast));
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_assign_op(ast_token(ast), sym.name, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_cast ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_cast(ast_token(ast), expr_copy, type);
end

def _ast_deep_copy_struct ast, tt, st in
    st_push_scope(st);
    var fields = ast_fields(ast);
    var fields_copy = make_vector(fields.length);
    var i = 0; var len = fields.length;
    while i < len do
        // fields aren't actually resolved with symbols so no need to create a copy of those
        var field_copy = field_make_copy(cast(vector_get(fields, i), Field&));
        field_copy.type = tt_substitute_type(tt, field_copy.type);
        vector_push(fields_copy, field_copy);
        i += 1;
    end
    var struct_type = tt_substitute_type(tt, ast_struct(ast));
    var struct_changed = struct_type != ast_struct(ast);
    var defs = ast_defs(ast);
    var defs_copy = make_vector(defs.length);
    var defs_copy_symbols = make_vector(defs.length);
    i = 0; len = defs.length;
    while i < len do
        var def_ = vector_get(defs, i);
        assert(ast_kind(def_) == AstK_Def);
        var def_copy = _ast_deep_copy_def(def_, tt, st);
        var def_copy_sym = st_get_symbol(st, ast_ident(def_copy));
        assert(def_copy_sym);
        def_copy_sym.owned_by = struct_type;
        vector_push(defs_copy, def_copy);
        vector_push(defs_copy_symbols, def_copy_sym);
        i += 1;
    end
    var struct_copy = make_ast_struct(ast_token(ast), struct_type, fields_copy, defs_copy);
    if struct_changed then
        type_set_ast(struct_type, struct_copy);
        type_set_struct_fields(struct_type, fields_copy);
        type_set_struct_defs(struct_type, defs_copy_symbols);
    end
    st_pop_scope(st);
    return struct_copy;
end

def _ast_deep_copy_member_access ast, tt, st in
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_member_access(ast_token(ast), expr_copy, ast_member(ast));
end

def _ast_deep_copy_assign_member ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_assign_member(ast_token(ast), lhs_copy, ast_op(ast), rhs_copy);
end

def _ast_deep_copy_sizeof_expr ast, tt, st in
    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK_Ident then
        var type = tt_get_type_or_null(tt, ast_ident(expr));
        if type then
            type = tt_substitute_type(tt, type);
            return make_ast_sizeof_type(ast_token(ast), type);
        end
        printf("not a type\n");
        tt_dump_cur_scope(tt);
    end
    var expr_copy = _ast_deep_copy(ast_expr(ast), tt, st);
    return make_ast_sizeof_expr(ast_token(ast), expr_copy);
end

def _ast_deep_copy_sizeof_type ast, tt, st in
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_sizeof_type(ast_token(ast), type);
end

def _ast_deep_copy_enum ast, tt, st in
    assert(false, "TODO: deep copy enum\n");
    return cast(NULL, ast);
end

def _ast_deep_copy_type ast, tt, st in
    var type = tt_substitute_type(tt, ast_type(ast));
    return make_ast_type(ast_token(ast), type);
end

def _ast_deep_copy_scope_resolve ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast_lhs(ast), tt, st);
    var rhs_copy = _ast_deep_copy(ast_rhs(ast), tt, st);
    return make_ast_scope_resolve(ast_token(ast), lhs_copy, rhs_copy);
end

def _ast_deep_copy ast, tt, st in
    var k = ast_kind(ast);
    if k == AstK_Ident then return _ast_deep_copy_ident(ast, tt, st);
    elif k == AstK_Integer then return _ast_deep_copy_integer(ast, tt, st);
    elif k == AstK_String then return _ast_deep_copy_string(ast, tt, st);
    elif k == AstK_Call then return _ast_deep_copy_call(ast, tt, st);
    elif k == AstK_BinOp then return _ast_deep_copy_binop(ast, tt, st);
    elif k == AstK_Return then return _ast_deep_copy_return(ast, tt, st);
    elif k == AstK_VarDecl then return _ast_deep_copy_var_decl(ast, tt, st);
    elif k == AstK_VarAssign then return _ast_deep_copy_var_assign(ast, tt, st);
    elif k == AstK_Def then return _ast_deep_copy_def(ast, tt, st);
    elif k == AstK_IfElse then return _ast_deep_copy_if_else(ast, tt, st);
    elif k == AstK_While then return _ast_deep_copy_while(ast, tt, st);
    elif k == AstK_PointerRead then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK_PointerWrite then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK_Prefix then return _ast_deep_copy_prefix(ast, tt, st);
    elif k == AstK_Const then return _ast_deep_copy_const(ast, tt, st);
    elif k == AstK_Extern then return _ast_deep_copy_extern(ast, tt, st);
    elif k == AstK_InlineAsm then return _ast_deep_copy_inline_asm(ast, tt, st);
    elif k == AstK_Global then return _ast_deep_copy_global(ast, tt, st);
    elif k == AstK_Break then return _ast_deep_copy_break(ast, tt, st);
    elif k == AstK_Continue then return _ast_deep_copy_continue(ast, tt, st);
    elif k == AstK_AssignOp then return _ast_deep_copy_assign_op(ast, tt, st);
    elif k == AstK_Cast then return _ast_deep_copy_cast(ast, tt, st);
    elif k == AstK_Struct then return _ast_deep_copy_struct(ast, tt, st);
    elif k == AstK_MemberAccess then return _ast_deep_copy_member_access(ast, tt, st);
    elif k == AstK_AssignMember then return _ast_deep_copy_assign_member(ast, tt, st);
    elif k == AstK_SizeofExpr then return _ast_deep_copy_sizeof_expr(ast, tt, st);
    elif k == AstK_SizeofType then return _ast_deep_copy_sizeof_type(ast, tt, st);
    elif k == AstK_Enum then return _ast_deep_copy_enum(ast, tt, st);
    elif k == AstK_Type then return _ast_deep_copy_type(ast, tt, st);
    elif k == AstK_ScopeResolve then return _ast_deep_copy_scope_resolve(ast, tt, st);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end
