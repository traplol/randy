
enum PointerOp in
    Read;
    Write;
end

enum AstK in
    Ident;
    Integer;
    String;
    Call;
    BinOp;
    Return;
    VarDecl;
    VarAssign;
    Def;
    IfElse;
    While;
    PointerRead;
    PointerWrite;
    Prefix;
    Const;
    Extern;
    InlineAsm;
    Global;
    Break;
    Continue;
    AssignOp;
    Cast;
    Struct;
    MemberAccess;
    AssignMember;
    SizeofExpr;
    SizeofType;
    Enum;
    Type;
    ScopeResolve;
    GetReference; // unavailable from source code
    Union;
    StaticAssert;
    OffsetOf;
    TupleLiteral;
    TupleLength; // not directly created from source code
    TupleGet; // not directly created from source code
end

def ast_kind_cstr k: AstK in
    if k == AstK::Ident then return "AstK::Ident"; end
    if k == AstK::Integer then return "AstK::Integer"; end
    if k == AstK::String then return "AstK::String"; end
    if k == AstK::Call then return "AstK::Call"; end
    if k == AstK::BinOp then return "AstK::BinOp"; end
    if k == AstK::Return then return "AstK::Return"; end
    if k == AstK::VarDecl then return "AstK::VarDecl"; end
    if k == AstK::VarAssign then return "AstK::VarAssign"; end
    if k == AstK::Def then return "AstK::Def"; end
    if k == AstK::IfElse then return "AstK::IfElse"; end
    if k == AstK::While then return "AstK::While"; end
    if k == AstK::PointerRead then return "AstK::PointerRead"; end
    if k == AstK::PointerWrite then return "AstK::PointerWrite"; end
    if k == AstK::Prefix then return "AstK::Prefix"; end
    if k == AstK::Const then return "AstK::Const"; end
    if k == AstK::Extern then return "AstK::Extern"; end
    if k == AstK::InlineAsm then return "AstK::InlineAsm"; end
    if k == AstK::Global then return "AstK::Global"; end
    if k == AstK::Break then return "AstK::Break"; end
    if k == AstK::Continue then return "AstK::Continue"; end
    if k == AstK::AssignOp then return "AstK::AssignOp"; end
    if k == AstK::Cast then return "AstK::Cast"; end
    if k == AstK::Struct then return "AstK::Struct"; end
    if k == AstK::MemberAccess then return "AstK::MemberAccess"; end
    if k == AstK::AssignMember then return "AstK::AssignMember"; end
    if k == AstK::SizeofExpr then return "AstK::SizeofExpr"; end
    if k == AstK::SizeofType then return "AstK::SizeofType"; end
    if k == AstK::Enum then return "AstK::Enum"; end
    if k == AstK::Type then return "AstK::Type"; end
    if k == AstK::ScopeResolve then return "AstK::ScopeResolve"; end
    if k == AstK::GetReference then return "AstK::GetReference"; end
    if k == AstK::Union then return "AstK::Union"; end
    if k == AstK::StaticAssert then return "AstK::StaticAssert"; end
    if k == AstK::OffsetOf then return "AstK::OffsetOf"; end
    if k == AstK::TupleLiteral then return "AstK::TupleLiteral"; end
    if k == AstK::TupleLength then return "AstK::TupleLength"; end
    if k == AstK::TupleGet then return "AstK::TupleGet"; end
    return "AstK::OUT_OF_RANGE";
end

def ast_requires_semi k in
    if k == AstK::Def then return false;
    elif k == AstK::IfElse then return false;
    elif k == AstK::While then return false;
    elif k == AstK::InlineAsm then return false;
    elif k == AstK::Struct then return false;
    elif k == AstK::Enum then return false;
    elif k == AstK::Union then return false;
    else
        return true;
    end
end

struct Ast in
    kind: AstK;
    is_expr: bool;
    token: Token&;

    u: union in
        ident: cstr;
        integer: int;
        string: String&;
        return_: Ast&;
        var_decl: cstr;
        type: Type&;
        get_reference: Ast&;
        static_assert_: Vector[Ast&]&;
        offsetof: Ast&;

        sizeof: struct in
            expr: Ast&;
            type: Type&;
        end
        call: struct in
            expr: Ast&;
            args: Vector[Ast&]&;
        end
        binop: struct in
            lhs: Ast&;
            op: TK;
            rhs: Ast&;
        end
        var_assign: struct in
            ident: cstr;
            expr: Ast&;
        end
        assign_op: struct in
            ident: cstr;
            op: TK;
            expr: Ast&;
        end
        def_: struct in
            ident: cstr;
            body: Vector[Ast&]&;
            params: Vector[cstr]&;
        end
        if_else: struct in
            test: Ast&;
            consequence: Vector[Ast&]&;
            alternative: Vector[Ast&]&;
        end
        while_: struct in
            test: Ast&;
            body: Vector[Ast&]&;
        end
        ptr_op: struct in
            size: int;
            op: PointerOp;
            args: Vector[Ast&]&;
        end
        prefix: struct in
            expr: Ast&;
            op: TK;
        end
        const_: struct in
            ident: cstr;
            expr: Ast&;
        end
        extern_: struct in
            ident: cstr;
            type: Type&;
        end
        inline_asm: struct in
            ident: cstr;
            asmcode: cstr;
        end
        global_: struct in
            ident: cstr;
            expr: Ast&;
        end
        cast_: struct in
            expr: Ast&;
            type: Type&;
        end
        struct_: struct in
            type: Type&;
            fields: Vector[Field&]&;
            body: Vector[Ast&]&;
        end
        union_: struct in
            type: Type&;
            fields: Vector[Field&]&;
        end
        enum_: struct in
            ident: cstr;
            type: Type&;
            values: Vector[EnumValue&]&;
        end
        member_access: struct in
            expr: Ast&;
            member: cstr;
        end
        assign_member: struct in
            lhs: Ast&;
            op: TK;
            rhs: Ast&;
        end
        scope_resolve: struct in
            lhs: Ast&;
            rhs: Ast&;
        end
        tuple_literal: struct in
            type: Type&;
            args: Vector[Ast&]&;
        end
        tuple_length: struct in
            expr: Ast&;
        end
        tuple_get: struct in
            expr: Ast&;
            idx: Ast&;
        end
    end

    def new_ident token: Token&, ident: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Ident;
        self.is_expr = true;
        self.token = token;
        self.u.ident = ident;
        return self;
    end

    def new_integer token: Token&, val: int in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Integer;
        self.is_expr = true;
        self.token = token;
        self.u.integer = val;
        return self;
    end

    def new_string token: Token&, val: String& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::String;
        self.is_expr = true;
        self.token = token;
        self.u.string = val;
        return self;
    end

    def new_call token: Token&, expr: Ast&, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Call;
        self.is_expr = true;
        self.token = token;
        self.u.call.expr = expr;
        self.u.call.args = args;
        return self;
    end

    def new_binop token: Token&, lhs: Ast&, op: TK, rhs: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::BinOp;
        self.is_expr = true;
        self.token = token;
        self.u.binop.lhs = lhs;
        self.u.binop.op = op;
        self.u.binop.rhs = rhs;
        return self;
    end

    def new_return token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Return;
        self.is_expr = false;
        self.token = token;
        self.u.return_ = expr;
        return self;
    end

    def new_var_decl token: Token&, ident: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::VarDecl;
        self.is_expr = false;
        self.token = token;
        self.u.var_decl = ident;
        return self;
    end

    def new_var_assign token: Token&, ident: cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::VarAssign;
        self.is_expr = false;
        self.token = token;
        self.u.var_assign.ident = ident;
        self.u.var_assign.expr = expr;
        return self;
    end

    def new_assign_op token: Token&, ident: cstr, op: TK, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::AssignOp;
        self.is_expr = false;
        self.token = token;
        self.u.assign_op.ident = ident;
        self.u.assign_op.op = op;
        self.u.assign_op.expr = expr;
        return self;
    end

    def new_def token: Token&, ident: cstr, params: Vector[cstr]&, body: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Def;
        self.is_expr = false;
        self.token = token;
        self.u.def_.ident = ident;
        self.u.def_.body = body;
        self.u.def_.params = params;
        return self;
    end

    def new_if_else token: Token&, test: Ast&, consequence: Vector[Ast&]&, alternative: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::IfElse;
        self.is_expr = false;
        self.token = token;
        self.u.if_else.test = test;
        self.u.if_else.consequence = consequence;
        self.u.if_else.alternative = alternative;
        return self;
    end

    def new_while token: Token&, test: Ast&, body: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::While;
        self.is_expr = false;
        self.token = token;
        self.u.while_.test = test;
        self.u.while_.body = body;
        return self;
    end

    def new_pointer_op token: Token&, size: int, op: PointerOp, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        if op == PointerOp::Read then
            self.kind = AstK::PointerRead;
            self.is_expr = true;
        else
            self.kind = AstK::PointerWrite;
            self.is_expr = false;
        end
        self.token = token;
        self.u.ptr_op.size = size;
        self.u.ptr_op.op = op;
        self.u.ptr_op.args = args;
        return self;
    end

    def new_prefix token: Token&, op: TK, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Prefix;
        self.is_expr = true;
        self.token = token;
        self.u.prefix.op = op;
        self.u.prefix.expr = expr;
        return self;
    end

    def new_const token: Token&, ident: cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Const;
        self.is_expr = false;
        self.token = token;
        self.u.const_.ident = ident;
        self.u.const_.expr = expr;
        return self;
    end

    def new_extern token: Token&, ident: cstr, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Extern;
        self.is_expr = false;
        self.token = token;
        self.u.extern_.ident = ident;
        self.u.extern_.type = type;
        return self;
    end

    def new_inline_asm token: Token&, ident: cstr, asmcode: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::InlineAsm;
        self.is_expr = false;
        self.token = token;
        self.u.inline_asm.ident = ident;
        self.u.inline_asm.asmcode = asmcode;
        return self;
    end

    def new_global token: Token&, ident:cstr, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Global;
        self.is_expr = false;
        self.token = token;
        self.u.global_.ident = ident;
        self.u.global_.expr = expr;
        return self;
    end

    def new_cast token: Token&, expr: Ast&, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Cast;
        self.is_expr = true;
        self.token = token;
        self.u.cast_.expr = expr;
        self.u.cast_.type = type;
        return self;
    end

    def new_struct token: Token&, type: Type&, fields: Vector[Field&]&, body: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Struct;
        self.is_expr = false;
        self.token = token;
        self.u.struct_.type = type;
        self.u.struct_.fields = fields;
        self.u.struct_.body = body;
        return self;
    end

    def new_union token: Token&, type: Type&, fields: Vector[Field&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Union;
        self.is_expr = false;
        self.token = token;
        self.u.union_.type = type;
        self.u.union_.fields = fields;
        return self;
    end

    def new_enum token: Token&, ident: cstr, type: Type&, values: Vector[EnumValue&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Enum;
        self.is_expr = false;
        self.token = token;
        self.u.enum_.ident = ident;
        self.u.enum_.type = type;
        self.u.enum_.values = values;
        return self;
    end

    def new_member_access token: Token&, expr: Ast&, member: cstr in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::MemberAccess;
        self.is_expr = true;
        self.token = token;
        self.u.member_access.expr = expr;
        self.u.member_access.member = member;
        return self;
    end

    def new_assign_member token: Token&, lhs: Ast&, op: TK, rhs: Ast& in
        assert(lhs.kind == AstK::MemberAccess);
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::AssignMember;
        self.is_expr = false;
        self.token = token;
        self.u.assign_member.lhs = lhs;
        self.u.assign_member.op = op;
        self.u.assign_member.rhs = rhs;
        return self;
    end

    def new_sizeof_type token: Token&, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::SizeofType;
        self.is_expr = true;
        self.token = token;
        self.u.sizeof.type = type;
        return self;
    end

    def new_sizeof_expr token: Token&, expr: Ast& in
        if expr.kind == AstK::Type then
            return Ast::new_sizeof_type(token, expr.u.type);
        end
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::SizeofExpr;
        self.is_expr = true;
        self.token = token;
        self.u.sizeof.expr = expr;
        return self;
    end

    def new_offsetof token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::OffsetOf;
        self.is_expr = true;
        self.token = token;
        self.u.offsetof = expr;
        return self;
    end

    def new_scope_resolve token: Token&, lhs: Ast&, rhs: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::ScopeResolve;
        self.is_expr = true;
        self.token = token;
        self.u.scope_resolve.lhs = lhs;
        self.u.scope_resolve.rhs = rhs;
        return self;
    end

    def new_get_reference token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::GetReference;
        self.is_expr = true;
        self.token = token;
        self.u.get_reference = expr;
        return self;
    end

    def new_static_assert token: Token&, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::StaticAssert;
        self.is_expr = false;
        self.token = token;
        self.u.static_assert_ = args;
        return self;
    end

    def new_break token: Token& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Break;
        self.is_expr = false;
        self.token = token;
        return self;
    end

    def new_continue token: Token& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Continue;
        self.is_expr = false;
        self.token = token;
        return self;
    end

    def new_type token: Token&, type: Type& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::Type;
        self.is_expr = false;
        self.token = token;
        self.u.type = type;
        return self;
    end

    def new_tuple_literal token: Token&, args: Vector[Ast&]& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::TupleLiteral;
        self.is_expr = true;
        self.token = token;
        self.u.tuple_literal.type = NULL;
        self.u.tuple_literal.args = args;
        return self;
    end

    def new_tuple_length token: Token&, expr: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::TupleLength;
        self.is_expr = true;
        self.token = token;
        self.u.tuple_length.expr = expr;
        return self;
    end

    def new_tuple_get token: Token&, expr: Ast&, idx: Ast& in
        var self = cast(calloc(1, __sizeof(Ast)), Ast&);
        self.kind = AstK::TupleGet;
        self.is_expr = true;
        self.token = token;
        self.u.tuple_get.expr = expr;
        self.u.tuple_get.idx = idx;
        return self;
    end
end

def ast_change_sizeof_expr_to_type self: Ast&, type: Type& in
    assert(self.kind == AstK::SizeofExpr);
    self.is_expr = true;
    self.kind = AstK::SizeofType;
    self.u.sizeof.type = type;
end

def ast_change_member_access_to_scope_access self: Ast&, type: Type&, member: Symbol& in
    assert(self.kind == AstK::MemberAccess);
    self.kind = AstK::ScopeResolve;

    var lhs = Ast::new_type(self.token, type);
    var rhs = Ast::new_ident(self.token, member.name);

    self.is_expr = true;
    self.u.scope_resolve.lhs = lhs;
    self.u.scope_resolve.rhs = rhs;
end

def ast_change_member_access_to_tuple_length self: Ast& in
    assert(self.kind == AstK::MemberAccess);
    self.kind = AstK::TupleLength;
    self.is_expr = true;
    var expr = self.u.member_access.expr;
    self.u.tuple_length.expr = expr;
end

def ast_change_member_access_to_tuple_get self: Ast& in
    assert(self.kind == AstK::MemberAccess);
    self.kind = AstK::TupleGet;
    self.is_expr = true;
    var expr = self.u.member_access.expr;
    self.u.tuple_get.expr = expr;
    // the idx is set at call inference
    self.u.tuple_get.idx = NULL;
end

def ast_src_loc self: Ast& in
    var token = self.token;
    return token_src_loc(token);
end

def print_ast_src_loc self: Ast& in
    print_token_loc(self.token);
end

def _print_indent indent: int in
    var i = 0;
    while i < indent do
        printf("    ");
        i += 1;
    end
end

def _print_args args: Vector[Ast&]&, indent: int in
    var i = 0;
    var len = args.length;
    while i < len do
        _print_ast(args.get(i), indent);
        i += 1;
        if i < len then
            printf(", ");
        end
    end
end

def _print_ast_ident ast, indent in
    var ident_sym = st_get_symbol(g_SymbolTable, ast.u.ident);
    assert(ident_sym);
    if ident_sym and ident_sym.owned_by then
        tt_print_type_name(g_TypeTable, ident_sym.owned_by);
        printf("::");
    end
    printf("%s", ident_sym.name);
end

def _print_ast_integer ast, indent in
    printf("%ld", ast.u.integer);
end

def _print_ast_string ast, indent in
    printf("\"");
    var string = ast.u.string;
    var i = 0; var len = string.length;
    while i < len do
        var c = string.get(i);
        if c == '\n' then
            printf("\\n");
        elif c == '"' then
            printf("\\\"");
        elif c == '\t' then
            printf("\\t");
        elif c == '\0' then
            printf("\\0");
        elif c == '\r' then
            printf("\\r");
        else
            printf("%c", c);
        end
        i += 1;
    end
    printf("\"");
end

def _print_ast_call ast, indent in
    _print_ast(ast.u.call.expr, indent);
    printf("(");
    _print_args(ast.u.call.args, indent);
    printf(")");
end

def _print_ast_binop ast, indent in
    _print_ast(ast.u.binop.lhs, indent);
    printf(" %s ", ast.token.cstr);
    _print_ast(ast.u.binop.rhs, indent);
end

def _print_ast_return ast, indent in
    var expr = ast.u.return_;
    if expr then
        printf("return ");
        _print_ast(expr, indent);
    else
        printf("return");
    end
end

def _print_ast_var_decl ast, indent in
    var symbol = st_get_symbol(g_SymbolTable, ast.u.var_decl);
    assert(symbol, "symbol is NULL");
    printf("var %s", symbol.name);
    var type = symbol.type;
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
end

def _print_ast_var_assign ast, indent in
    var symbol = st_get_symbol(g_SymbolTable, ast.u.var_assign.ident);
    assert(symbol, "symbol is NULL");
    printf("var %s", symbol.name);
    var type = symbol.type;
    if type then
        printf(": ");
        tt_print_type_name(g_TypeTable, type);
    end
    printf(" = ");
    _print_ast(ast.u.var_assign.expr, indent);
end

def _print_ast_assign_op ast, indent in
    printf("%s ", ast.u.assign_op.ident);
    var op = ast.u.assign_op.op;
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf("%s ", op_str);
    _print_ast(ast.u.assign_op.expr, indent);
end

def _print_ast_body body, indent in
    var i = 0;
    var len = body.length;
    var stmt;
    while i < len do
        stmt = body.get(i);
        _print_indent(indent);
        _print_ast(stmt, indent);
        if ast_requires_semi(stmt.kind) then
            printf(";\n");
        else
            printf("\n");
        end
        i += 1;
    end
end

def _print_ast_def ast, indent in
    var def_sym = st_get_symbol(g_SymbolTable, ast.u.def_.ident);
    assert(def_sym);
    if def_sym and def_sym.owned_by then
        printf("def ");
        tt_print_type_name(g_TypeTable, def_sym.owned_by);
        printf("::%s", ast.u.def_.ident);
    else
        printf("def %s", ast.u.def_.ident);
    end
    var i = 0;
    var params = ast.u.def_.params;
    var len = params.length;
    while i < len do
        var param_name = params.get(i);
        printf(" %s", param_name);
        var param_sym = st_get_symbol(g_SymbolTable, param_name);
        assert(param_sym, "psym is NULL");
        var param_type = symbol_type(param_sym);
        if param_type then
            printf(": ");
            tt_print_type_name(g_TypeTable, param_type);
        end
        i += 1;
        if i < len then
            printf(",");
        end
    end
    var def_type = symbol_type(def_sym);
    if def_type then
        assert(type_is_def(def_type), "def_type not def.\n");
        var ret_type = type_def_return_type(def_type);
        printf(" -> ");
        tt_print_type_name(g_TypeTable, ret_type);
    end
    printf(" in\n");
    _print_ast_body(ast.u.def_.body, indent + 1);
    _print_indent(indent); printf("end\n");
end

def _print_ast_if_else ast, indent, print_if in
    if print_if then
        printf("if ");
    end
    _print_ast(ast.u.if_else.test, indent);
    printf(" then\n");
    var conseq = ast.u.if_else.consequence;
    var altern = ast.u.if_else.alternative;
    _print_ast_body(conseq, indent+1);
    if altern.length > 0 then
        if altern.length == 1 and AstK::IfElse == altern.get(0).kind then
            _print_indent(indent); printf("elif ");
            _print_ast_if_else(altern.get(0), indent, false);
            return;
        else
            _print_indent(indent); printf("else\n");
            _print_ast_body(altern, indent+1);
        end
    end
    _print_indent(indent); printf("end");
end

def _print_ast_while ast, indent in
    printf("while ");
    _print_ast(ast.u.while_.test, indent);
    printf(" do\n");
    _print_ast_body(ast.u.while_.body, indent+1);
    _print_indent(indent); printf("end");
end

def _print_ast_pointer_op ast, indent in
    printf("%s(", ast.token.cstr);
    _print_args(ast.u.ptr_op.args, indent);
    printf(")");
end

def _print_ast_prefix ast, indent in
    var token = ast.token;
    // FIXME == TK::KW_assert is a hack.
    if token.kind == TK::KW_not or token.kind == TK::KW_assert then
        printf("not ");
    else
        printf("%s", token.cstr);
    end
    var expr = ast.u.prefix.expr;
    if expr.kind == AstK::BinOp then
        printf("(");
    end
    _print_ast(expr, indent);
    if expr.kind == AstK::BinOp then
        printf(")");
    end
end

def _print_ast_const ast, indent in
    printf("const %s = ", ast.u.const_.ident);
    _print_ast(ast.u.const_.expr, indent);
end

def _print_ast_global ast, indent in
    printf("global %s = ", ast.u.global_.ident);
    _print_ast(ast.u.global_.expr, indent);
end

def _print_ast_extern ast, indent in
    printf("extern %s: ", ast.u.extern_.ident);
    tt_print_type_name(g_TypeTable, ast.u.extern_.type);
end

def _print_ast_inline_asm ast, indent in
    printf("asm %s in\n", ast.u.inline_asm.ident);
    printf("\"%s\"\n", ast.u.inline_asm.asmcode);
    printf("end\n");
end

def _print_ast_break ast, indent in
    printf("break");
end

def _print_ast_continue ast, indent in
    printf("continue");
end

def _print_ast_static_assert ast, indent in
    printf("static_assert(");
    _print_args(ast.u.static_assert_, indent);
    printf(")");
end

def _print_ast_tuple_literal ast, indent in
    printf("{ ");
    _print_args(ast.u.tuple_literal.args, indent);
    printf(" }");
end

def _print_ast_tuple_length ast, indent in
    _print_ast(ast.u.tuple_length.expr, indent);
    printf(".length");
end

def _print_ast_tuple_get ast, indent in
    _print_ast(ast.u.tuple_get.expr, indent);
    printf(".get(");
    if ast.u.tuple_get.idx then
        _print_ast(ast.u.tuple_get.idx, indent);
    else
        printf("{null}");
    end
    printf(")");
end

def _print_ast_cast ast, indent in
    printf("cast(");
    _print_ast(ast.u.cast_.expr, indent);
    printf(", ");
    tt_print_type_name(g_TypeTable, ast.u.cast_.type);
    printf(")");
end

def _print_ast_struct ast, indent in
    printf("struct ");
    tt_print_type_name(g_TypeTable, ast.u.struct_.type);
    printf(" in\n");
    var fields = ast.u.struct_.fields;
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        _print_indent(indent+1);
        printf("%s: ", field.name);
        tt_print_type_name(g_TypeTable, field.type);
        printf(";\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

def _print_ast_union ast, indent in
    printf("union ");
    tt_print_type_name(g_TypeTable, ast.u.union_.type);
    printf(" in\n");
    var fields = ast.u.union_.fields;
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        _print_indent(indent+1);
        printf("%s: ", field.name);
        tt_print_type_name(g_TypeTable, field.type);
        printf(";\n");
        i += 1;
    end
    _print_indent(indent); printf("end\n");
end

def _print_ast_member_access ast, indent in
    var expr = ast.u.member_access.expr;
    printf("(");
    var member = ast.u.member_access.member;
    _print_ast(expr, indent);
    printf(".%s)", member);
end

def _print_ast_assign_member ast, indent in
    _print_ast(ast.u.assign_member.lhs, indent);
    var op = ast.u.assign_member.op;
    var op_str = "FIXME in ast.randy";
    if op == TK::Assign      then op_str = "=";
    elif op == TK::PlusEq    then op_str = "+=";
    elif op == TK::MinusEq   then op_str = "-=";
    elif op == TK::StarEq    then op_str = "*=";
    elif op == TK::SlashEq   then op_str = "/=";
    elif op == TK::PercentEq then op_str = "%=";
    elif op == TK::LShiftEq  then op_str = "<<=";
    elif op == TK::RShiftEq  then op_str = ">>=";
    elif op == TK::AmperEq   then op_str = "&=";
    elif op == TK::CaretEq   then op_str = "^=";
    elif op == TK::BarEq     then op_str = "|=";
    end
    printf(" %s ", op_str);
    _print_ast(ast.u.assign_member.rhs, indent);
end

def _print_ast_sizeof_expr ast, indent in
    printf("__sizeof(");
    _print_ast(ast.u.sizeof.expr, indent);
    printf(")");
end

def _print_ast_sizeof_type ast, indent in
    printf("__sizeof(");
    tt_print_type_name(g_TypeTable, ast.u.sizeof.type);
    printf(")");
end

def _print_ast_enum ast, indent in
    var enum_name = ast.u.enum_.ident;
    var enum_vals = ast.u.enum_.values;

    printf("enum %s in\n", enum_name);
    var i = 0; var len = enum_vals.length;
    while i < len do
        _print_indent(indent + 1);
        var ev = enum_vals.get(i);
        printf("%s = %d;\n", ev.name, ev.value);
        i += 1;
    end
    _print_indent(indent);
    printf("end\n");
end

def _print_ast_type ast, indent in
    tt_print_type_name(g_TypeTable, ast.u.type);
end

def _print_ast_scope_resolve ast, indent in
    // _print_ast(ast.u.scope_resolve.lhs, indent);
    // printf("::");
    _print_ast(ast.u.scope_resolve.rhs, indent);
end

def _print_ast_get_reference ast, indent in
    printf("#REF(");
    _print_ast(ast.u.get_reference, indent);
    printf(")");
end

def _print_ast_offsetof ast, indent in
    printf("__offsetof(");
    _print_ast(ast.u.offsetof, indent);
    printf(")");
end

def _print_ast ast, indent in
    var k = ast.kind;
    if k == AstK::Ident then _print_ast_ident(ast, indent);
    elif k == AstK::Integer then _print_ast_integer(ast, indent);
    elif k == AstK::String then _print_ast_string(ast, indent);
    elif k == AstK::Call then _print_ast_call(ast, indent);
    elif k == AstK::BinOp then _print_ast_binop(ast, indent);
    elif k == AstK::Return then _print_ast_return(ast, indent);
    elif k == AstK::VarDecl then _print_ast_var_decl(ast, indent);
    elif k == AstK::VarAssign then _print_ast_var_assign(ast, indent);
    elif k == AstK::Def then _print_ast_def(ast, indent);
    elif k == AstK::IfElse then _print_ast_if_else(ast, indent, true);
    elif k == AstK::While then _print_ast_while(ast, indent);
    elif k == AstK::PointerRead then _print_ast_pointer_op(ast, indent);
    elif k == AstK::PointerWrite then _print_ast_pointer_op(ast, indent);
    elif k == AstK::Prefix then _print_ast_prefix(ast, indent);
    elif k == AstK::Const then _print_ast_const(ast, indent);
    elif k == AstK::Extern then _print_ast_extern(ast, indent);
    elif k == AstK::InlineAsm then _print_ast_inline_asm(ast, indent);
    elif k == AstK::Global then _print_ast_global(ast, indent);
    elif k == AstK::Break then _print_ast_break(ast, indent);
    elif k == AstK::Continue then _print_ast_continue(ast, indent);
    elif k == AstK::AssignOp then _print_ast_assign_op(ast, indent);
    elif k == AstK::Cast then _print_ast_cast(ast, indent);
    elif k == AstK::Struct then _print_ast_struct(ast, indent);
    elif k == AstK::MemberAccess then _print_ast_member_access(ast, indent);
    elif k == AstK::AssignMember then _print_ast_assign_member(ast, indent);
    elif k == AstK::SizeofExpr then _print_ast_sizeof_expr(ast, indent);
    elif k == AstK::SizeofType then _print_ast_sizeof_type(ast, indent);
    elif k == AstK::Enum then _print_ast_enum(ast, indent);
    elif k == AstK::Type then _print_ast_type(ast, indent);
    elif k == AstK::ScopeResolve then _print_ast_scope_resolve(ast, indent);
    elif k == AstK::GetReference then _print_ast_get_reference(ast, indent);
    elif k == AstK::Union then _print_ast_union(ast, indent);
    elif k == AstK::StaticAssert then _print_ast_static_assert(ast, indent);
    elif k == AstK::OffsetOf then _print_ast_offsetof(ast, indent);
    elif k == AstK::TupleLiteral then _print_ast_tuple_literal(ast, indent);
    elif k == AstK::TupleLength then _print_ast_tuple_length(ast, indent);
    elif k == AstK::TupleGet then _print_ast_tuple_get(ast, indent);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end

def print_ast ast: Ast& in
    _print_ast(ast, 0);
    if ast_requires_semi(ast.kind) then
        printf(";\n");
    else
        printf("\n");
    end
end

def check_ast_kind expect: AstK, ast: Ast& in
    var actual = ast.kind;
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end

def print_whole_ast roots in
    var i = 0; var len = roots.length;
    while i < len do
        print_ast(roots.get(i));
        i += 1;
    end
end

def _ast_deep_copy_vector vector, tt, st in
    var i = 0; var len = vector.length;
    var copy = Vector[Ast&]::new(len);
    while i < len do
        copy.push(_ast_deep_copy(vector.get(i), tt, st));
        i += 1;
    end
    return copy;
end


// these copy functions don't create copies of the tokens

def _ast_deep_copy_ident ast, tt, st in
    var sym = st_get_symbol(st, ast.u.ident);
    return Ast::new_ident(ast.token, symbol_name(sym));
end

def _ast_deep_copy_integer ast, tt, st in
    return Ast::new_integer(ast.token, ast.u.integer);
end

def _ast_deep_copy_string ast, tt, st in
    return Ast::new_string(ast.token, ast.u.string.duplicate());
end

def _ast_deep_copy_call ast, tt, st in
    var copy_expr = _ast_deep_copy(ast.u.call.expr, tt, st);
    var copy_args = _ast_deep_copy_vector(ast.u.call.args, tt, st);
    return Ast::new_call(ast.token, copy_expr, copy_args);
end

def _ast_deep_copy_binop ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast.u.binop.lhs, tt, st);
    var rhs_copy = _ast_deep_copy(ast.u.binop.rhs, tt, st);
    return Ast::new_binop(ast.token, lhs_copy, ast.u.binop.op, rhs_copy);
end

def _ast_deep_copy_return ast, tt, st in
    if ast.u.return_ then
        return Ast::new_return(ast.token, _ast_deep_copy(ast.u.return_, tt, st));
    else
        return Ast::new_return(ast.token, NULL);
    end
end

def _ast_deep_copy_var_decl ast, tt, st in
    var ident = ast.u.var_decl;
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    return Ast::new_var_decl(ast.token, symbol_name(copy_sym));
end

def _ast_deep_copy_var_assign ast, tt, st in
    var ident = ast.u.var_assign.ident;
    var ident_sym = st_get_exact_symbol(st, ident);
    assert(ident_sym);
    var copy_ident = strdup(ident);
    var copy_sym = st_make_local(st, copy_ident, ident_sym.token);
    copy_sym.type = tt_substitute_type(tt, ident_sym.type);
    var assign_expr_copy = _ast_deep_copy(ast.u.var_assign.expr, tt, st);
    return Ast::new_var_assign(ast.token, symbol_name(copy_sym), assign_expr_copy);
end

def _ast_deep_copy_def ast, tt, st in
    var def_ident = ast.u.def_.ident;
    var def_sym = st_get_exact_symbol(st, def_ident);
    var def_params = ast.u.def_.params;
    var def_copy_ident = strdup(def_ident);
    var def_copy_sym = st_make_def(st, def_copy_ident, def_sym.token);
    st_push_scope(st);
    var def_copy_params = Vector[cstr]::new(def_params.length);
    var def_copy_params_types = Vector[Type&]::new(def_params.length);
    var i = 0; var len = def_params.length;
    while i < len do
        var param = def_params.get(i);
        var param_sym = st_get_exact_symbol(st, param);
        assert(param_sym);
        var param_copy = strdup(param);
        var param_copy_sym = st_make_param(st, param_copy, param_sym.token);
        param_copy_sym.type = tt_substitute_type(tt, param_sym.type);
        def_copy_params_types.push(param_copy_sym.type);
        def_copy_params.push(param_copy); // push the cstr not the symbol!
        i += 1;
    end
    var return_type = tt_substitute_type(tt, type_def_return_type(def_sym.type));
    def_copy_sym.type = tt_make_anon_def(tt,
                            return_type, def_copy_params_types, type_def_varargs(def_sym.type));
    var def_copy_body = _ast_deep_copy_vector(ast.u.def_.body, tt, st);
    st_pop_scope(st);
    var copy_ast = Ast::new_def(ast.token, def_copy_ident, def_copy_params, def_copy_body);
    type_set_ast(def_copy_sym.type, copy_ast);
    return copy_ast;
end

def _ast_deep_copy_if_else ast, tt, st in
    var test_copy = _ast_deep_copy(ast.u.if_else.test, tt, st);
    var conseq_copy = _ast_deep_copy_vector(ast.u.if_else.consequence, tt, st);
    var altern_copy = _ast_deep_copy_vector(ast.u.if_else.alternative, tt, st);
    return Ast::new_if_else(ast.token, test_copy, conseq_copy, altern_copy);
end

def _ast_deep_copy_while ast, tt, st in
    var test_copy = _ast_deep_copy(ast.u.while_.test, tt, st);
    var body_copy = _ast_deep_copy_vector(ast.u.while_.body, tt, st);
    return Ast::new_while(ast.token, test_copy, body_copy);
end

def _ast_deep_copy_pointer_op ast, tt, st in
    var args_copy = _ast_deep_copy_vector(ast.u.ptr_op.args, tt, st);
    return Ast::new_pointer_op(ast.token, ast.u.ptr_op.size, ast.u.ptr_op.op, args_copy);
end

def _ast_deep_copy_prefix ast, tt, st in
    var expr_copy = _ast_deep_copy(ast.u.prefix.expr, tt, st);
    return Ast::new_prefix(ast.token, ast.u.prefix.op, expr_copy);
end

def _ast_deep_copy_const ast, tt, st in
    // here is a place where types would be replaced
    assert(false, "TODO: deep copy const\n");
    return cast(NULL, Ast&);
end

def _ast_deep_copy_extern ast, tt, st in
    assert(false, "TODO: deep copy extern\n");
    return cast(NULL, Ast&);
end

def _ast_deep_copy_inline_asm ast, tt, st in
    assert(false, "TODO: deep copy inline asm\n");
    return cast(NULL, Ast&);
end

def _ast_deep_copy_global ast, tt, st in
    assert(false, "TODO: deep copy global\n");
    return cast(NULL, Ast&);
end

def _ast_deep_copy_break ast, tt, st in
    return Ast::new_break(ast.token);
end

def _ast_deep_copy_continue ast, tt, st in
    return Ast::new_continue(ast.token);
end

def _ast_deep_copy_assign_op ast, tt, st in
    var sym = st_get_symbol(st, ast.u.assign_op.ident);
    var rhs_copy = _ast_deep_copy(ast.u.assign_op.expr, tt, st);
    return Ast::new_assign_op(ast.token, sym.name, ast.u.assign_op.op, rhs_copy);
end

def _ast_deep_copy_cast ast, tt, st in
    var expr_copy = _ast_deep_copy(ast.u.cast_.expr, tt, st);
    var type = tt_substitute_type(tt, ast.u.cast_.type);
    return Ast::new_cast(ast.token, expr_copy, type);
end

def _ast_deep_copy_struct ast, tt, st in
    st_push_scope(st);
    var fields = ast.u.struct_.fields;
    var fields_copy = Vector[Field&]::new(fields.length);
    var i = 0; var len = fields.length;
    while i < len do
        // fields aren't actually resolved with symbols so no need to create a copy of those
        var field_copy = field_make_copy(fields.get(i));
        field_copy.type = tt_substitute_type(tt, field_copy.type);
        fields_copy.push(field_copy);
        i += 1;
    end
    var struct_type = tt_substitute_type(tt, ast.u.struct_.type);
    var struct_changed = struct_type != ast.u.struct_.type;
    var defs = ast.u.struct_.body;
    var defs_copy = Vector[Ast&]::new(defs.length);
    var defs_copy_symbols = Vector[Symbol&]::new(defs.length);
    i = 0; len = defs.length;
    while i < len do
        var def_ = defs.get(i);
        assert(def_.kind == AstK::Def);
        var def_copy = _ast_deep_copy_def(def_, tt, st);
        var def_copy_sym = st_get_symbol(st, def_copy.u.def_.ident);
        assert(def_copy_sym);
        def_copy_sym.owned_by = struct_type;
        defs_copy.push(def_copy);
        defs_copy_symbols.push(def_copy_sym);
        i += 1;
    end
    var struct_copy = Ast::new_struct(ast.token, struct_type, fields_copy, defs_copy);
    if struct_changed then
        type_set_ast(struct_type, struct_copy);
        type_set_struct_fields(struct_type, fields_copy);
        type_set_struct_defs(struct_type, defs_copy_symbols);
    end
    st_pop_scope(st);
    return struct_copy;
end

def _ast_deep_copy_union ast, tt, st in
    st_push_scope(st);
    var fields = ast.u.union_.fields;
    var fields_copy = Vector[Field&]::new(fields.length);
    var i = 0; var len = fields.length;
    while i < len do
        // fields aren't actually resolved with symbols so no need to create a copy of those
        var field_copy = field_make_copy(fields.get(i));
        field_copy.type = tt_substitute_type(tt, field_copy.type);
        fields_copy.push(field_copy);
        i += 1;
    end
    var union_type = tt_substitute_type(tt, ast.u.union_.type);
    var union_changed = union_type != ast.u.union_.type;
    var union_copy = Ast::new_union(ast.token, union_type, fields_copy);
    if union_changed then
        type_set_ast(union_type, union_copy);
        type_set_union_fields(union_type, fields_copy);
    end
    st_pop_scope(st);
    return union_copy;
end

def _ast_deep_copy_member_access ast, tt, st in
    var expr_copy = _ast_deep_copy(ast.u.member_access.expr, tt, st);
    return Ast::new_member_access(ast.token, expr_copy, ast.u.member_access.member);
end

def _ast_deep_copy_assign_member ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast.u.assign_member.lhs, tt, st);
    var rhs_copy = _ast_deep_copy(ast.u.assign_member.rhs, tt, st);
    return Ast::new_assign_member(ast.token, lhs_copy, ast.u.assign_member.op, rhs_copy);
end

def _ast_deep_copy_sizeof_expr ast, tt, st in
    var expr = ast.u.sizeof.expr;
    if expr.kind == AstK::Ident then
        var type = tt_get_type_or_null(tt, expr.u.ident);
        if type then
            type = tt_substitute_type(tt, type);
            return Ast::new_sizeof_type(ast.token, type);
        end
    end
    var expr_copy = _ast_deep_copy(expr, tt, st);
    return Ast::new_sizeof_expr(ast.token, expr_copy);
end

def _ast_deep_copy_sizeof_type ast, tt, st in
    var type = tt_substitute_type(tt, ast.u.sizeof.type);
    return Ast::new_sizeof_type(ast.token, type);
end

def _ast_deep_copy_enum ast, tt, st in
    assert(false, "TODO: deep copy enum\n");
    return cast(NULL, Ast&);
end

def _ast_deep_copy_type ast, tt, st in
    var type = tt_substitute_type(tt, ast.u.type);
    return Ast::new_type(ast.token, type);
end

def _ast_deep_copy_scope_resolve ast, tt, st in
    var lhs_copy = _ast_deep_copy(ast.u.scope_resolve.lhs, tt, st);
    var rhs_copy = _ast_deep_copy(ast.u.scope_resolve.rhs, tt, st);
    return Ast::new_scope_resolve(ast.token, lhs_copy, rhs_copy);
end

def _ast_deep_copy_get_reference ast, tt, st in
    var expr_copy = _ast_deep_copy(ast.u.get_reference, tt, st);
    return Ast::new_get_reference(ast.token, expr_copy);
end

def _ast_deep_copy_static_assert ast, tt, st in
    var args_copy = _ast_deep_copy_vector(ast.u.static_assert_, tt, st);
    return Ast::new_static_assert(ast.token, args_copy);
end

def _ast_deep_copy_offsetof ast, tt, st in
    var expr_copy = _ast_deep_copy(ast.u.offsetof, tt, st);
    return Ast::new_offsetof(ast.token, expr_copy);
end

def _ast_deep_copy_tuple_literal ast, tt, st in
    var args = _ast_deep_copy_vector(ast.u.tuple_literal.args, tt, st);
    var ast_copy = Ast::new_tuple_literal(ast.token, args);
    ast_copy.u.tuple_literal.type = tt_substitute_type(tt, ast.u.tuple_literal.type);
    return ast_copy;
end

def _ast_deep_copy_tuple_length ast, tt, st in
    var expr = _ast_deep_copy(ast.u.tuple_length.expr, tt, st);
    return Ast::new_tuple_length(ast.token, expr);
end

def _ast_deep_copy_tuple_get ast, tt, st in
    var expr = _ast_deep_copy(ast.u.tuple_get.expr, tt, st);
    var idx: Ast& = NULL;
    if ast.u.tuple_get.idx then
        idx = _ast_deep_copy(ast.u.tuple_get.idx, tt, st);
    end
    return Ast::new_tuple_get(ast.token, expr, idx);
end

def _ast_deep_copy ast, tt, st in
    var k = ast.kind;
    if k == AstK::Ident then return _ast_deep_copy_ident(ast, tt, st);
    elif k == AstK::Integer then return _ast_deep_copy_integer(ast, tt, st);
    elif k == AstK::String then return _ast_deep_copy_string(ast, tt, st);
    elif k == AstK::Call then return _ast_deep_copy_call(ast, tt, st);
    elif k == AstK::BinOp then return _ast_deep_copy_binop(ast, tt, st);
    elif k == AstK::Return then return _ast_deep_copy_return(ast, tt, st);
    elif k == AstK::VarDecl then return _ast_deep_copy_var_decl(ast, tt, st);
    elif k == AstK::VarAssign then return _ast_deep_copy_var_assign(ast, tt, st);
    elif k == AstK::Def then return _ast_deep_copy_def(ast, tt, st);
    elif k == AstK::IfElse then return _ast_deep_copy_if_else(ast, tt, st);
    elif k == AstK::While then return _ast_deep_copy_while(ast, tt, st);
    elif k == AstK::PointerRead then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK::PointerWrite then return _ast_deep_copy_pointer_op(ast, tt, st);
    elif k == AstK::Prefix then return _ast_deep_copy_prefix(ast, tt, st);
    elif k == AstK::Const then return _ast_deep_copy_const(ast, tt, st);
    elif k == AstK::Extern then return _ast_deep_copy_extern(ast, tt, st);
    elif k == AstK::InlineAsm then return _ast_deep_copy_inline_asm(ast, tt, st);
    elif k == AstK::Global then return _ast_deep_copy_global(ast, tt, st);
    elif k == AstK::Break then return _ast_deep_copy_break(ast, tt, st);
    elif k == AstK::Continue then return _ast_deep_copy_continue(ast, tt, st);
    elif k == AstK::AssignOp then return _ast_deep_copy_assign_op(ast, tt, st);
    elif k == AstK::Cast then return _ast_deep_copy_cast(ast, tt, st);
    elif k == AstK::Struct then return _ast_deep_copy_struct(ast, tt, st);
    elif k == AstK::MemberAccess then return _ast_deep_copy_member_access(ast, tt, st);
    elif k == AstK::AssignMember then return _ast_deep_copy_assign_member(ast, tt, st);
    elif k == AstK::SizeofExpr then return _ast_deep_copy_sizeof_expr(ast, tt, st);
    elif k == AstK::SizeofType then return _ast_deep_copy_sizeof_type(ast, tt, st);
    elif k == AstK::Enum then return _ast_deep_copy_enum(ast, tt, st);
    elif k == AstK::Type then return _ast_deep_copy_type(ast, tt, st);
    elif k == AstK::ScopeResolve then return _ast_deep_copy_scope_resolve(ast, tt, st);
    elif k == AstK::GetReference then return _ast_deep_copy_get_reference(ast, tt, st);
    elif k == AstK::Union then return _ast_deep_copy_union(ast, tt, st);
    elif k == AstK::StaticAssert then return _ast_deep_copy_static_assert(ast, tt, st);
    elif k == AstK::TupleLiteral then return _ast_deep_copy_tuple_literal(ast, tt, st);
    elif k == AstK::TupleLength then return _ast_deep_copy_tuple_length(ast, tt, st);
    elif k == AstK::TupleGet then return _ast_deep_copy_tuple_get(ast, tt, st);
    else
        printf("`_print_ast` at File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        exit(1);
    end
end
