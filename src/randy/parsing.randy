
def parse_args_until ts, st, tt, into, until in
    var arg;
    while true do
        if ts.peekk(until) then
            return;
        end
        arg = parse_expression(ts, st, tt);
        if not arg then
            return;
        end
        into.push(arg);
        if ts.peekk(until) then
            return;
        end
        if ts.expect(TK::Comma) then
            if ts.peekk(until) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts.peek());
                exit(1);
            end
        end
    end
end

def parse_def_type ts, st, tt, is_instance in
    ts.expect(TK::LParen);
    var param_types = Vector[type]::new(0);
    var ret_type = tt_void_type(tt);
    var varargs = false;
    while true do
        if ts.peekk(TK::RParen) then
            break;
        end
        if ts.peekk(TK::Ellipsis) then
            break;
        end
        var type = parse_type(ts, st, tt, is_instance);
        assert(type);
        param_types.push(type);
        if ts.peekk(TK::RightArrow) then
            break;
        end
        if ts.accept(TK::Comma) then
            if ts.peekk(TK::RParen) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts.peek());
                exit(1);
            elif ts.peekk(TK::RightArrow) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts.peek());
                exit(1);
            end
        end
    end
    if ts.accept(TK::Ellipsis) then
        varargs = true;
    end
    if ts.accept(TK::RightArrow) then
        ret_type = parse_type(ts, st, tt, is_instance);
    end
    ts.expect(TK::RParen);
    return tt_make_anon_def(tt, ret_type, param_types, varargs);
end

def parse_type ts, st, tt, is_instance in
    if ts.peekk(TK::LParen) then
        return parse_def_type(ts, st, tt, is_instance);
    end
    var type_ident = ts.expect(TK::Ident);
    var type = tt_get_type_or_make_undefined(tt, type_ident.value);
    var generic_params: Vector[type]& = NULL;
    if ts.accept(TK::LSquare) then
        if not is_instance and tt.type_scope.parent == NULL then
            printf("type_ident = %s\n", type_ident.value);
            print_token_loc(type_ident);
            assert(false, "Compiler bug? type_scope depth should probably be >1 when parsing a generic.");
        end
        generic_params = Vector[type]::new(0);
        while ts.peekk(TK::Ident) do
            var type = parse_type(ts, st, tt, true);
            generic_params.push(type);
            if not is_instance and type_is_undefined(type) then
                type_set_kind(type, TyK_generic_param);
            end
            if ts.peekk(TK::RSquare) then
                break;
            end
            ts.expect(TK::Comma);
        end
        ts.expect(TK::RSquare);
    end

    if type_is_generic(type) and not generic_params then
        assert(type_params(type));
        printf("ERROR: type `%s` expects %d type parameters.\n",
               type_ident.value, type_params(type).length);
        print_token_loc(type_ident);
        exit(1);
    end

    if generic_params then
        if is_instance then
            type = tt_get_type_instance_of(tt, st, type, generic_params);
        else
            type_set_is_generic(type, true);
            type_set_params(type, generic_params);
        end
    end

    assert(type);

    if ts.accept(TK::Amper) then
        type = tt_reference_to_type(tt, type);
    end
    return type;
end

def parse_var ts, st, tt in
    var var_ = ts.expect(TK::KW_var);
    var ident = ts.expect(TK::Ident);
    var type = NULL;
    var expr = NULL;
    if ts.accept(TK::Colon) then
        type = parse_type(ts, st, tt, true);
    end
    if ts.accept(TK::Assign) then
        expr = parse_expression(ts, st, tt);
        if not expr then
            printf("ERROR: Expected expression after '='\n");
            print_token_loc(ident);
            exit(1);
        end
    end
    var symbol = st_get_symbol_here(st, ident.value);
    if symbol then
        printf("ERROR: var `%s` already defined.\n", ident.value);
        print_token_loc(ident);
        printf("NOTE: It was previously defined here:\n");
        print_token_loc(symbol_token(symbol));
        exit(1);
    end
    symbol = st_make_local(st, ident.value, ident);
    symbol_set_type(symbol, type); // OK if type is NULL
    if expr then
        return make_ast_var_assign(var_, symbol_name(symbol), expr);
    end
    return make_ast_var_decl(var_, symbol_name(symbol));
end

def parse_if_else ts, st, tt, expect in
    var if_ = ts.expect(expect);
    st_push_scope(st);
    var test = parse_expression(ts, st, tt);
    if not test then
        printf("ERROR: Expected expression after 'if'\n");
        print_token_loc(if_);
        exit(1);
    end
    ts.expect(TK::KW_then);
    var conseq = Vector[ast]::new(0);
    var altern = Vector[ast]::new(0);
    parse_statements_until_one_of(ts, st, tt, conseq, TK::KW_elif, TK::KW_end, TK::KW_elif);
    // early end
    if ts.accept(TK::KW_end) then
        st_pop_scope(st);
        return make_ast_if_else(if_, test, conseq, altern);
    end
    // elif ... then
    if ts.peekk(TK::KW_elif) then
        st_pop_scope(st);
        altern.push(parse_if_else(ts, st, tt, TK::KW_elif));
        return make_ast_if_else(if_, test, conseq, altern);
    end
    // else
    ts.expect(TK::KW_else);
    st_pop_scope(st); // discard the scope of the previous if/elif
    st_push_scope(st);
    parse_statements_until(ts, st, tt, altern, TK::KW_end);
    // end
    ts.next();
    st_pop_scope(st);
    return make_ast_if_else(if_, test, conseq, altern);
end

def parse_while ts, st, tt in
    var while_ = ts.expect(TK::KW_while);
    st_push_scope(st);
    var test = parse_expression(ts, st, tt);
    if not test then
        printf("ERROR: Expected expression after 'while'\n");
        print_token_loc(while_);
        exit(1);
    end
    var body = Vector[ast]::new(0);
    ts.expect(TK::KW_do);
    parse_statements_until(ts, st, tt, body, TK::KW_end);
    ts.expect(TK::KW_end);
    st_pop_scope(st);
    return make_ast_while(while_, test, body);
end

def parse_return ts, st, tt in
    var return_ = ts.expect(TK::KW_return);
    if ts.peekk(TK::Semicolon) then
        return make_ast_return(return_, NULL);
    end
    // no need to handle NULL here because return with null expr is a void return.
    var expr = parse_expression(ts, st, tt);
    return make_ast_return(return_, expr);
end

def parse_assign_op ts, st, tt, lhs, op in
    var op_tk = ts.expect(op);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '%s'\n", op_tk.value);
        print_token_loc(op_tk);
        exit(1);
    end
    var k = ast_kind(lhs);
    if k == AstK_Ident then
        // LEAK: I think this ends up leaking the LHS AST node
        var symbol = st_get_symbol(st, ast_ident(lhs));
        if not symbol then
            symbol = st_prepare_undef(st, ast_ident(lhs), ast_token(lhs));
        end
        return make_ast_assign_op(op_tk, symbol_name(symbol), op, expr);
    elif k == AstK_MemberAccess then
        return make_ast_assign_member(op_tk, lhs, op, expr);
    else
        assert(false, "parse_assign_op for %s (%d) not implemented.\n", ast_kind_cstr(k), k);
    end
end

def parse_pointer_op ts, st, tt in
    var token = ts.peek();
    var size;
    var op;
    if ts.accept(TK::KW_u!) then
        size = 0;
        op = PointerOp::Write;
    elif ts.accept(TK::KW_u8!) then
        size = 8;
        op = PointerOp::Write;
    elif ts.accept(TK::KW_u16!) then
        size = 16;
        op = PointerOp::Write;
    elif ts.accept(TK::KW_u32!) then
        size = 32;
        op = PointerOp::Write;
    elif ts.accept(TK::KW_u64!) then
        size = 64;
        op = PointerOp::Write;
    elif ts.accept(TK::KW_u@) then
        size = 0;
        op = PointerOp::Read;
    elif ts.accept(TK::KW_u8@) then
        size = 8;
        op = PointerOp::Read;
    elif ts.accept(TK::KW_u16@) then
        size = 16;
        op = PointerOp::Read;
    elif ts.accept(TK::KW_u32@) then
        size = 32;
        op = PointerOp::Read;
    elif ts.accept(TK::KW_u64@) then
        size = 64;
        op = PointerOp::Read;
    else
        printf("ERROR: Unexpected token: %s\n", token_kind_cstr(token.kind));
        print_token_loc(token);
        exit(1);
    end

    ts.expect(TK::LParen);
    var args = Vector[ast]::new(0);
    if op == PointerOp::Read then
        var arg = parse_expression(ts, st, tt);
        args.push(arg);
        if size == 0 then
            ts.expect(TK::Comma);
            var peek = ts.peek();
            var type = parse_type(ts, st, tt, true);
            args.push(make_ast_type(peek, type));
        end
    else
        var arg = parse_expression(ts, st, tt);
        args.push(arg);
        ts.expect(TK::Comma);
        arg = parse_expression(ts, st, tt);
        args.push(arg);
        if size == 0 then
            ts.expect(TK::Comma);
            var peek = ts.peek();
            var type = parse_type(ts, st, tt, true);
            args.push(make_ast_type(peek, type));
        end
    end
    ts.expect(TK::RParen);
    return make_ast_pointer_op(token, size, op, args);
end

def parse_cast ts, st, tt in
    var cast_ = ts.expect(TK::KW_cast);
    ts.expect(TK::LParen);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '('\n");
        print_token_loc(cast_);
        exit(1);
    end
    ts.expect(TK::Comma);
    var type = parse_type(ts, st, tt, true);
    ts.expect(TK::RParen);
    return make_ast_cast(cast_, expr, type);
end

def parse_sizeof ts, st, tt in
    var sizeof_ = ts.expect(TK::KW__sizeof);
    ts.expect(TK::LParen);
    var idx = ts.idx;
    var expr = parse_expression(ts, st, tt);
    if not expr then
        ts.idx = idx;
        var type = parse_type(ts, st, tt, true);
        ts.expect(TK::RParen);
        return make_ast_sizeof_type(sizeof_, type);
    end
    ts.expect(TK::RParen);
    return make_ast_sizeof_expr(sizeof_, expr);
end

def parse_offsetof ts, st, tt in
    NYI_ERR(__FILE__, __LINE__, "parse_offsetof");
    return NULL;
end

def parse_assert ts, st, tt in
    var assert_ = ts.expect(TK::KW_assert);
    ts.expect(TK::LParen);
    var assert_args = Vector[ast]::new(0);
    parse_args_until(ts, st, tt, assert_args, TK::RParen);
    ts.expect(TK::RParen);
    if assert_args.length == 0 then
        printf("ERROR: Expected expression to test in 'assert'\n");
        print_token_loc(assert_);
        exit(1);
    end
    var test = assert_args.get(0);
    var body = Vector[ast]::new(0);
    var printf_args = Vector[ast]::new(0);
    var printf_symbol = st_get_symbol(st, "printf");
    assert(printf_symbol, "`printf` not defined for assert.");
    var abort_symbol = st_get_symbol(st, "abort");
    assert(abort_symbol, "`abort` not defined for assert.");

    printf_args.push(make_ast_string(assert_, string_from_cstr("Assertion failed:\n")));
    body.push(make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(printf_symbol)),
                        printf_args));

    var len = assert_args.length;
    if len > 1 then
        printf_args = Vector[ast]::new(0);
        var i = 1;
        while i < len do
            printf_args.push(assert_args.get(i));
            i += 1;
        end
        body.push(make_ast_call(assert_,
                            make_ast_ident(assert_, symbol_name(printf_symbol)),
                            printf_args));
    end

    printf_args = Vector[ast]::new(1);
    var string = string_from_cstr("  File \"");
    string_append_cstr(string, assert_.src_loc.filename);
    string_append_cstr(string, "\", line ");
    string_append_int(string, assert_.src_loc.line);
    string_push(string, '\n');
    printf_args.push(make_ast_string(assert_, string));
    body.push(make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(printf_symbol)),
                        printf_args));
    body.push(make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(abort_symbol)), Vector[ast]::new(0)));

    test = make_ast_prefix(assert_, TK::KW_not, test);
    var ast = make_ast_if_else(assert_, test, body, Vector[ast]::new(0));
    assert_args.delete();
    return ast;
end

def parse_primary ts, st, tt in
    var peek = ts.peek();
    if not peek then
        return NULL;
    end
    if ts.accept(TK::LParen) then
        var expr = parse_expression(ts, st, tt);
        if not expr then
            printf("ERROR: Expected expression after '('\n");
            print_token_loc(peek);
            exit(1);
        end
        ts.expect(TK::RParen);
        return expr;
    end
    var k = peek.kind;
    if k == TK::Ident then
        var idx = ts.idx;
        var ident = ts.next();
        if ts.peekk(TK::LSquare) then
            ts.idx = idx;
            var type = parse_type(ts, st, tt, true);
            return make_ast_type(ident, type);
        end
        var symbol = st_get_symbol(st, ident.value);
        if not symbol then
            symbol = st_prepare_undef(st, ident.value, ident);
        end
        return make_ast_ident(peek, symbol_name(symbol));
    elif k == TK::Integer or k == TK::Char then
        return make_ast_integer(peek, cast(ts.next().value, int));
    elif k == TK::String then
        return make_ast_string(peek, cast(ts.next().value, String&));
    elif k == TK::KW__FILE__ then
        return make_ast_string(peek, string_from_cstr(ts.next().src_loc.filename));
    elif k == TK::KW__LINE__ then
        return make_ast_integer(peek, ts.next().src_loc.line);
    elif k == TK::KW_u@ or
        k == TK::KW_u8@ or k == TK::KW_u16@ or k == TK::KW_u32@ or k == TK::KW_u64@ then
        return parse_pointer_op(ts, st, tt);
    elif k == TK::KW_cast then
        return parse_cast(ts, st, tt);
    elif k == TK::KW__offsetof then
        return parse_offsetof(ts, st, tt);
    elif k == TK::KW__sizeof then
        return parse_sizeof(ts, st, tt);
    end
    return NULL;
end

def parse_scope_resolve ts, st, tt, lhs in
    var tk = ts.expect(TK::ColonColon);
    if ast_kind(lhs) == AstK_Ident then
        var type = tt_get_type_or_make_undefined(tt, ast_ident(lhs));
        lhs = make_ast_type(ast_token(lhs), type);
    elif ast_kind(lhs) != AstK_ScopeResolve and ast_kind(lhs) != AstK_Type then
        printf("ERROR: expected type name on lhs of '::'\n");
        print_token_loc(tk);
        exit(1);
    end
    var rhs = parse_primary(ts, st, tt);
    if not rhs or (ast_kind(rhs) != AstK_Ident and ast_kind(rhs) != AstK_Type) then
        printf("ERROR: expected identifier on rhs of '::'\n");
        print_token_loc(tk);
        print_ast(rhs);
        exit(1);
    end

    if ts.accept(TK::LParen) then
        var args = Vector[ast]::new(0);
        parse_args_until(ts, st, tt, args, TK::RParen);
        ts.expect(TK::RParen);
        lhs = make_ast_scope_resolve(tk, lhs, rhs);
        return make_ast_call(tk, lhs, args);
    end

    lhs = make_ast_scope_resolve(tk, lhs, rhs);
    while ts.accept(TK::ColonColon) do
        var rhs = parse_primary(ts, st, tt);
        if not rhs or (ast_kind(rhs) != AstK_Ident and ast_kind(rhs) != AstK_Type) then
            printf("ERROR: expected identifier on rhs of '::'\n");
            print_token_loc(tk);
            exit(1);
        end
        lhs = make_ast_scope_resolve(tk, lhs, rhs);
        if ts.accept(TK::LParen) then
            var args = Vector[ast]::new(0);
            parse_args_until(ts, st, tt, args, TK::RParen);
            ts.expect(TK::RParen);
            return make_ast_call(tk, lhs, args);
        end
    end
    return lhs;
end

def parse_postfix ts, st, tt in
    var expr = parse_primary(ts, st, tt);
    if not expr then
        return NULL;
    end

    if ts.peekk(TK::ColonColon) then
        expr = parse_scope_resolve(ts, st, tt, expr);
    end

    while ts.peekk_one_of_2(TK::LParen, TK::Dot) do
        var tk = ts.next();
        var k = tk.kind;
        if k == TK::LParen then
            var args = Vector[ast]::new(0);
            parse_args_until(ts, st, tt, args, TK::RParen);
            ts.expect(TK::RParen);
            expr = make_ast_call(tk, expr, args);
        elif k == TK::Dot then
            var member = ts.expect(TK::Ident);
            expr = make_ast_member_access(tk, expr, member.value);
        end
    end

    return expr;
end

def parse_prefix ts, st, tt in
    var postfix = parse_postfix(ts, st, tt);
    if postfix then
        return postfix;
    end

    if ts.peekk_one_of_3(TK::Tilde, TK::KW_not, TK::Minus) then
        var tok = ts.next();
        var expr = parse_prefix(ts, st, tt);
        return make_ast_prefix(tok, tok.kind, expr);
    end
    return NULL;
end

def parse_binary_multiplicative ts, st, tt in
    var lhs = parse_prefix(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk_one_of_3(TK::Star, TK::Slash, TK::Percent) do
        tok = ts.next();
        rhs = parse_prefix(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_additive ts, st, tt in
    var lhs = parse_binary_multiplicative(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk_one_of_2(TK::Plus, TK::Minus) do
        tok = ts.next();
        rhs = parse_binary_multiplicative(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_shift ts, st, tt in
    var lhs = parse_binary_additive(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk_one_of_2(TK::LShift, TK::RShift) do
        tok = ts.next();
        rhs = parse_binary_additive(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_relational ts, st, tt in
    var lhs = parse_binary_shift(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk_one_of_4(TK::Less, TK::Greater, TK::LessEq, TK::GreaterEq) do
        tok = ts.next();
        rhs = parse_binary_shift(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_equality ts, st, tt in
    var lhs = parse_binary_relational(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk_one_of_2(TK::EqEq, TK::NotEq) do
        tok = ts.next();
        rhs = parse_binary_relational(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_bit_and ts, st, tt in
    var lhs = parse_binary_equality(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk(TK::Amper) do
        tok = ts.next();
        rhs = parse_binary_equality(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_bit_xor ts, st, tt in
    var lhs = parse_binary_bit_and(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk(TK::Caret) do
        tok = ts.next();
        rhs = parse_binary_bit_and(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_bit_or ts, st, tt in
    var lhs = parse_binary_bit_xor(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk(TK::Bar) do
        tok = ts.next();
        rhs = parse_binary_bit_xor(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_land ts, st, tt in
    var lhs = parse_binary_bit_or(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk(TK::KW_and) do
        tok = ts.next();
        rhs = parse_binary_bit_or(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_binary_lor ts, st, tt in
    var lhs = parse_binary_land(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts.peekk(TK::KW_or) do
        tok = ts.next();
        rhs = parse_binary_land(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, tok.kind, rhs);
    end
    return lhs;
end

def parse_expression ts: TokenStream&, st: SymbolTable&, tt: TypeTable& -> ast in
    return parse_binary_lor(ts, st, tt);
end

def parse_statement ts: TokenStream&, st: SymbolTable&, tt: TypeTable& -> ast in
    var stmt: ast;
    var expect_semi = true;
    if ts.peekk(TK::KW_var) then
        stmt = parse_var(ts, st, tt);
        expect_semi = true;
    elif ts.peekk(TK::KW_if) then
        stmt = parse_if_else(ts, st, tt, TK::KW_if);
        expect_semi = false;
    elif ts.peekk(TK::KW_while) then
        stmt = parse_while(ts, st, tt);
        expect_semi = false;
    elif ts.peekk(TK::KW_return) then
        stmt = parse_return(ts, st, tt);
        expect_semi = true;
    elif ts.peekk(TK::KW_break) then
        stmt = make_ast_break(ts.next());
        expect_semi = true;
    elif ts.peekk(TK::KW_continue) then
        stmt = make_ast_continue(ts.next());
        expect_semi = true;
    elif ts.peekk(TK::KW_assert) then
        stmt = parse_assert(ts, st, tt);
        expect_semi = true;
    elif ts.peekk_one_of_5(TK::KW_u!, TK::KW_u8!, TK::KW_u16!, TK::KW_u32!, TK::KW_u64!) then
        stmt = parse_pointer_op(ts, st, tt);
        expect_semi = true;
    else
        expect_semi = true;
        stmt = parse_expression(ts, st, tt);
        if stmt and (ast_kind(stmt) == AstK_Ident or ast_kind(stmt) == AstK_MemberAccess) then
            if ts.peekk(TK::Assign) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::Assign);
            elif ts.peekk(TK::PlusEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::PlusEq);
            elif ts.peekk(TK::MinusEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::MinusEq);
            elif ts.peekk(TK::StarEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::StarEq);
            elif ts.peekk(TK::SlashEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::SlashEq);
            elif ts.peekk(TK::PercentEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::PercentEq);
            elif ts.peekk(TK::LShiftEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::LShiftEq);
            elif ts.peekk(TK::RShiftEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::RShiftEq);
            elif ts.peekk(TK::AmperEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::AmperEq);
            elif ts.peekk(TK::CaretEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::CaretEq);
            elif ts.peekk(TK::BarEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK::BarEq);
            end
        end
    end

    if not stmt then
        return NULL;
    end
    if expect_semi then
        ts.expect(TK::Semicolon);
    end
    return stmt;
end

def parse_statements_until ts, st, tt, into, kind in
    if ts.peekk(kind) then
        return;
    end
    var stmt = parse_statement(ts, st, tt);
    while stmt do
        into.push(stmt);
        if ts.peekk(kind) then
            stmt = NULL;
        else
            stmt = parse_statement(ts, st, tt);
        end
    end
end

def parse_statements_until_one_of ts, st, tt, into, k1, k2, k3 in
    if ts.peekk_one_of_3(k1, k2, k3) then
        return;
    end
    var stmt = parse_statement(ts, st, tt);
    while stmt do
        into.push(stmt);
        if ts.peekk_one_of_3(k1, k2, k3) then
            stmt = NULL;
        else
            stmt = parse_statement(ts, st, tt);
        end
    end
end

def parse_def ts, st, tt in
    var def_ = ts.expect(TK::KW_def);
    var ident = ts.expect(TK::Ident);
    var def_symbol = st_get_symbol_here(st, ident.value);
    if def_symbol then
        if symbol_is_undef(def_symbol) then
            symbol_set_kind(def_symbol, SymbolKind::Def);
        else
            printf("ERROR: def `%s` already defined.\n", ident.value);
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(def_symbol));
            exit(1);
        end
    else
        def_symbol = st_make_def(st, ident.value, ident);
    end

    st_push_scope(st);
    var body = Vector[ast]::new(0);
    var params = Vector[cstr]::new(0);
    var param_symbols = Vector[Symbol&]::new(0);
    var any_type = tt_any_type(tt);
    while ts.peekk(TK::Ident) do
        var param_id = ts.next();
        var param_symbol = st_get_symbol_here(st, param_id.value);
        if param_symbol then
            printf("ERROR: param `%s` already defined.\n", param_id.value);
            print_token_loc(param_id);
            exit(1);
        end
        param_symbol = st_make_param(st, param_id.value, param_id);
        params.push(symbol_name(param_symbol));
        param_symbols.push(param_symbol);
        if ts.peekk(TK::KW_in) then
            symbol_set_type(param_symbol, any_type);
            break;
        elif ts.accept(TK::Colon) then
            symbol_set_type(param_symbol, parse_type(ts, st, tt, true));
            if ts.peekk(TK::KW_in) then
                break;
            end
            if ts.peekk(TK::RightArrow) then
                break;
            end
            ts.expect(TK::Comma);
        elif ts.peekk(TK::RightArrow) then
            symbol_set_type(param_symbol, any_type);
            break;
        else
            symbol_set_type(param_symbol, any_type);
            ts.expect(TK::Comma);
        end
    end
    var return_type = any_type;
    if ts.accept(TK::RightArrow) then
        return_type = parse_type(ts, st, tt, true);
    end
    ts.expect(TK::KW_in);

    var param_types = Vector[type]::new(param_symbols.length);
    var i = 0; var len = param_symbols.length;
    while i < len do
        param_types.push(symbol_type(param_symbols.get(i)));
        i += 1;
    end
    param_symbols.delete();
    var def_type = tt_make_anon_def(tt, return_type, param_types, false);
    symbol_set_type(def_symbol, def_type);

    parse_statements_until(ts, st, tt, body, TK::KW_end);
    ts.expect(TK::KW_end);
    st_pop_scope(st);
    var ast = make_ast_def(def_, symbol_name(def_symbol), params, body);
    type_set_ast(def_type, ast);
    return ast;
end

def parse_const ts, st, tt in
    var const_ = ts.expect(TK::KW_const);
    var ident = ts.expect(TK::Ident);
    var type = NULL;
    if ts.accept(TK::Colon) then
        type = parse_type(ts, st, tt, true);
    end
    ts.expect(TK::Assign);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '='\n");
        print_token_loc(const_);
        exit(1);
    end
    var symbol = st_get_symbol_here(st, ident.value);
    // No error here because we allow you to have multiple definitions of `const`
    // if they share the same value and that won't be checked until IR generation.
    if not symbol then
        symbol = st_make_const(st, ident.value, ident);
    end
    symbol_set_type(symbol, type);
    return make_ast_const(const_, symbol_name(symbol), expr);
end

def parse_extern ts, st, tt in
    var extern_ = ts.expect(TK::KW_extern);
    var ident = ts.expect(TK::Ident);
    ts.expect(TK::Colon);
    var type = parse_type(ts, st, tt, true);
    var is_varargs = false;
    var extern_symbol = st_get_symbol_here(st, ident.value);
    if extern_symbol then
        if symbol_is_undef(extern_symbol) then
            symbol_set_kind(extern_symbol, SymbolKind::Extern);
        else
            printf("ERROR: extern `%s` already defined.\n", ident.value);
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(extern_symbol));
            exit(1);
        end
    else
        extern_symbol = st_make_extern(st, ident.value, ident);
    end
    symbol_set_type(extern_symbol, type);
    return make_ast_extern(extern_, symbol_name(extern_symbol), type);
end

def parse_asm ts, st, tt in
    var asm_ = ts.expect(TK::KW_asm);
    var ident = ts.expect(TK::Ident);
    ts.expect(TK::KW_in);
    var asmcode = ts.expect(TK::String);
    ts.expect(TK::KW_end);
    var symbol = st_get_symbol_here(st, ident.value);
    if symbol then
        if symbol_is_undef(symbol) then
            symbol_set_kind(symbol, SymbolKind::Asm);
        else
            printf("ERROR: asm `%s` already defined.\n", ident.value);
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(symbol));
            exit(1);
        end
    else
        symbol = st_make_asm(st, ident.value, ident);
    end

    var def_type = tt_make_anon_def(tt, tt_ptr_type(tt), Vector[type]::new(0), true);
    symbol_set_type(symbol, def_type);
    return make_ast_inline_asm(asm_, symbol_name(symbol), string_cstr(asmcode.value));
end

def parse_global ts, st, tt in
    var global_ = ts.expect(TK::KW_global);
    var ident = ts.expect(TK::Ident);
    var type = NULL;
    if ts.accept(TK::Colon) then
        type = parse_type(ts, st, tt, true);
    end
    ts.expect(TK::Assign);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '='\n");
        print_token_loc(global_);
        exit(1);
    end
    var symbol = st_get_symbol_here(st, ident.value);
    if symbol then
        if symbol_is_undef(symbol) then
            symbol_set_kind(symbol, SymbolKind::Global);
        else
            printf("ERROR: global `%s` already defined.\n", ident.value);
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(symbol));
            exit(1);
        end
    else
        symbol = st_make_global(st, ident.value, ident);
    end
    symbol_set_type(symbol, type);
    return make_ast_global(global_, symbol_name(symbol), expr);
end

def parse_struct ts, st, tt in
    tt_push_scope(tt);
    var struct_ = ts.expect(TK::KW_struct);
    var struct_type = NULL;
    if not ts.accept(TK::KW_in) then
        struct_type = parse_type(ts, st, tt, false);
        ts.expect(TK::KW_in);
    end
    var fields = Vector[Field&]::new(0);
    var defs = Vector[ast]::new(0);
    var def_symbols = Vector[Symbol&]::new(0);
    st_push_scope(st);
    while not ts.peekk(TK::KW_end) do
        if ts.peekk(TK::KW_def) then
            st_push_scope(st);
            var def_ = parse_def(ts, st, tt);
            defs.push(def_);
            def_symbols.push(st_get_symbol(st, ast_ident(def_)));
            st_pop_scope(st);
        elif ts.peekk(TK::Ident) then
            var field_ident = ts.next();
            ts.expect(TK::Colon);
            var field_type = parse_type(ts, st, tt, true);
            ts.expect(TK::Semicolon);
            fields.push(make_field(field_type, field_ident.value, -1, field_ident));
        else
            var tk = ts.peek();
            printf("ERROR: Unexpected token in struct: %s\n", token_kind_cstr(tk.kind));
            print_token(tk);
            print_token_loc(tk);
            exit(1);
        end
    end
    st_pop_scope(st);
    ts.expect(TK::KW_end);

    if not struct_type then
        struct_type = tt_make_anon_struct(tt, fields, def_symbols);
    elif not type_is_undefined(struct_type) then
        printf("ERROR: type `%s` already defined.", tt_get_type_name(tt, struct_type));
    end

    type_set_kind(struct_type, TyK_struct);
    type_set_struct_fields(struct_type, fields);
    type_set_struct_defs(struct_type, def_symbols);

    var i = 0; var len = def_symbols.length;
    while i < len do
        var def_sym = def_symbols.get(i);
        assert(not def_sym.owned_by);
        def_sym.owned_by = struct_type;

        var def_ = defs.get(i);
        var def_type = def_sym.type;
        var def_params = ast_params(def_);
        if def_params.length > 0 and cstr_eq("self", def_params.front()) then
            var first_param = def_params.front();
            var param_types = type_def_parameters(def_type);
            var first_param_type = param_types.front();
            var ref_type = type_ref_to_this(struct_type);
            if first_param_type == tt.any_type then
                param_types.set(0, ref_type);
                var sym = st_get_symbol(st, first_param);
                sym.type = ref_type;
            elif first_param_type != ref_type then
                printf("WARN: type of `self` is `");
                tt_print_type_name(tt, first_param_type);
                printf("`, but it usually `");
                tt_print_type_name(tt, ref_type);
                printf(".`\n");
                print_token_loc(def_sym.token);
            end
        end
        i += 1;
    end

    var ast = make_ast_struct(struct_, struct_type, fields, defs);
    type_set_ast(struct_type, ast);
    tt_pop_scope(tt);
    tt_set_local_type(tt, struct_type);
    return ast;
end

def parse_enum ts, st, tt in
    var enum_ = ts.expect(TK::KW_enum);
    var ident = ts.expect(TK::Ident);
    ts.expect(TK::KW_in);
    var enum_type = tt_get_type_or_make_undefined(tt, ident.value);
    if not type_is_undefined(enum_type) then
        printf("ERROR: type `%s` already defined.", ident.value);
        print_token_loc(ident);
        exit(1);
    end
    var values = Vector[EnumValue&]::new(0);
    var cur_value = 0;
    while not ts.peekk(TK::KW_end) do
        var val_id = ts.expect(TK::Ident);
        var val = NULL;
        if ts.accept(TK::Assign) then
            val = parse_expression(ts, st, tt);
            if val and ast_kind(val) == AstK_Integer then
                cur_value = cast(ast_value(val), int);
            end
        end
        ts.expect(TK::Semicolon);
        if not val then
            val = make_ast_integer(val_id, cur_value);
        end
        values.push(make_enum_value(val_id, val_id.value, val));
        cur_value += 1;
    end
    ts.expect(TK::KW_end);

    type_set_kind(enum_type, TyK_enum);
    type_set_enum_values(enum_type, values);
    type_set_size(enum_type, PTR_BITS);
    return make_ast_enum(enum_, ident.value, enum_type, values);
end

def parse ts: TokenStream&, st: SymbolTable&, tt: TypeTable& in
    var roots = Vector[ast]::new(0);
    var parsed: ast = NULL; var tk: Token&;
    while ts.peek() do
        tk = ts.peek();
        if ts.peekk(TK::KW_def) then
            parsed = parse_def(ts, st, tt);
        elif ts.peekk(TK::KW_const) then
            parsed = parse_const(ts, st, tt);
            ts.expect(TK::Semicolon);
        elif ts.peekk(TK::KW_extern) then
            parsed = parse_extern(ts, st, tt);
            ts.expect(TK::Semicolon);
        elif ts.peekk(TK::KW_asm) then
            parsed = parse_asm(ts, st, tt);
        elif ts.peekk(TK::KW_global) then
            parsed = parse_global(ts, st, tt);
            ts.expect(TK::Semicolon);
        elif ts.peekk(TK::KW_struct) then
            parsed = parse_struct(ts, st, tt);
        elif ts.peekk(TK::KW_enum) then
            parsed = parse_enum(ts, st, tt);
        else
            tk = ts.peek();
            printf("ERROR: Unexpected token in top-level: %s\n", token_kind_cstr(tk.kind));
            print_token(tk);
            print_token_loc(tk);
            exit(1);
        end

        if not parsed then
            printf("ERROR: Unhandled parse error for %s\n", token_kind_cstr(tk.kind));
            print_token_loc(tk);
            exit(1);
        end
        roots.push(parsed);
        parsed = NULL;
    end
    return roots;
end
