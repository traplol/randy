
proc parse_var ts in
    NYI_ERR("parse var");
end

proc parse_if_else ts in
    NYI_ERR("parse if / else");
end

proc parse_while ts in
    NYI_ERR("parse while");
end

proc parse_return ts in
    var return_ = ts_expect(ts, TK_KW_return);
    if ts_peekk(ts, TK_Semicolon) then
        return make_ast_return(return_, NULL);
    end
    var expr = parse_expression(ts);
    return make_ast_return(return_, expr);
end

proc parse_assign ts in
    NYI_ERR("parse assignment");
end

proc parse_pointer_op ts in
    NYI_ERR("parse pointer op");
end

proc parse_primary ts in
    if ts_accept(ts, TK_LParen) then
        var expr = parse_expression(ts);
        ts_expect(ts, TK_RParen);
        return expr;
    end
    var peek = ts_peek(ts);
    var k = token_kind(peek);
    if k == TK_Ident then
        return make_ast_ident(peek, token_value(ts_next(ts)));
    else if k == TK_Integer or k == TK_Char then
        return make_ast_integer(peek, token_value(ts_next(ts)));
    else if k == TK_String then
        return make_ast_string(peek, token_value(ts_next(ts)));
    else if k == TK_KW_u8@ or k == TK_KW_u8@ or k == TK_KW_u8@ or k == TK_KW_u8@ then
        return parse_pointer_op(ts);
    end
    return NULL;
end

proc parse_postfix ts in
    var peek = ts_peek(ts);
    var expr = parse_primary(ts);
    if not expr then
        return NULL;
    end

    if not ts_accept(ts, TK_LParen) then
        return expr;
    end
    var args = make_vector(0);
    var breaking = false;
    var arg;
    while not breaking do
        if ts_peekk(ts, TK_RParen) then
            breaking = true;
        else
            arg = parse_expression(ts);
            if not arg then
                return NULL;
            end
            vector_push(args, arg);
            if ts_accept(ts, TK_Comma) then
                if ts_peekk(ts, TK_RParen) then
                    printf("ERROR: Unexpected ')' after ','\n");
                    print_token_loc(ts_peek(ts));
                end
            end
        end
    done
    ts_expect(ts, TK_RParen);
    return make_ast_call(peek, expr, args);
end

proc parse_prefix ts in
    var postfix = parse_postfix(ts);
    if postfix then
        return postfix;
    end

    if ts_peekk_one_of_2(ts, TK_Tilde, TK_KW_not) then
        var tok = ts_next(ts);
        var expr = parse_prefix(ts);
        return make_ast_prefix(tok, token_kind(tok), expr);
    end
    return NULL;
end

proc parse_binary_multiplicative ts in
    var lhs = parse_prefix(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_3(ts, TK_Star, TK_Slash, TK_Percent) do
        tok = ts_next(ts);
        rhs = parse_prefix(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_binary_additive ts in
    var lhs = parse_binary_multiplicative(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_2(ts, TK_Plus, TK_Minus) do
        tok = ts_next(ts);
        rhs = parse_binary_multiplicative(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_binary_relational ts in
    var lhs = parse_binary_additive(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_4(ts, TK_Less, TK_Greater, TK_LessEq, TK_GreaterEq) do
        tok = ts_next(ts);
        rhs = parse_binary_additive(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_binary_equality ts in
    var lhs = parse_binary_relational(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_2(ts, TK_EqEq, TK_NotEq) do
        tok = ts_next(ts);
        rhs = parse_binary_relational(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_binary_land ts in
    var lhs = parse_binary_equality(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_KW_and) do
        tok = ts_next(ts);
        rhs = parse_binary_equality(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_binary_lor ts in
    var lhs = parse_binary_land(ts);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_KW_or) do
        tok = ts_next(ts);
        rhs = parse_binary_land(ts);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    done
    return lhs;
end

proc parse_expression ts in
    return parse_binary_lor(ts);
end

proc parse_statement ts in
    var stmt;
    var expect_semi = true;
    if ts_peekk(ts, TK_KW_var) then
        stmt = parse_var(ts);
        expect_semi = true;
    else if ts_peekk(ts, TK_KW_if) then
        stmt = parse_if_else(ts);
        expect_semi = false;
    else if ts_peekk(ts, TK_KW_while) then
        stmt = parse_while(ts);
        expect_semi = false;
    else if ts_peekk(ts, TK_KW_return) then
        stmt = parse_return(ts);
        expect_semi = true;
    else if ts_peekk2(ts, TK_Ident, TK_Assign) then
        stmt = parse_assign(ts);
        expect_semi = true;
    else if ts_peekk_one_of_4(ts, TK_KW_u8!, TK_KW_u8!, TK_KW_u8!, TK_KW_u8!) then
        stmt = parse_pointer_op(ts);
        expect_semi = true;
    else
        stmt = parse_expression(ts);
        expect_semi = true;
    end

    if not stmt then
        return NULL;
    end
    if expect_semi then
        ts_expect(ts, TK_Semicolon);
    end
    return stmt;
end
    
proc parse_statements_until ts, into, kind in
    if ts_peekk(ts, kind) then
        return;
    end
    var stmt = parse_statement(ts);
    while stmt do
        vector_push(into, stmt);
        if ts_peekk(ts, kind) then
            stmt = NULL;
        else
            stmt = parse_statement(ts);
        end
    done
end

proc parse_proc ts in
    var proc_ = ts_expect(ts, TK_KW_proc);
    var ident = ts_expect(ts, TK_Ident);
    var body = make_vector(0);
    var params = make_vector(0);
    var breaking = false;
    while not breaking and ts_peekk(ts, TK_Ident) do
        vector_push(params, token_value(ts_next(ts)));
        if ts_peekk(ts, TK_KW_in) then
            breaking = true;
        else
            ts_expect(ts, TK_Comma);
        end
    done
    ts_expect(ts, TK_KW_in);
    parse_statements_until(ts, body, TK_KW_end);
    ts_expect(ts, TK_KW_end);
    return make_ast_procedure(proc_, token_value(ident), params, body);
end

proc parse_const ts in
    var const_ = ts_expect(ts, TK_KW_const);
    var ident = ts_expect(ts, TK_Ident);
    ts_expect(ts, TK_Assign);
    if not ts_peekk_one_of_4(ts, TK_Ident, TK_Integer, TK_Char, TK_String) then
        printf("ERROR: Expected one of [TK_Ident, TK_Integer, TK_Char, TK_String] for 'const.'\n");
        print_token_loc(const_);
        exit(1);
    end
    var val_tok = ts_next(ts);
    return make_ast_const(const_, token_value(ident), val_tok);
end

proc parse_extern ts in
    var extern_ = ts_expect(ts, TK_KW_extern);
    var ident = ts_expect(ts, TK_Ident);
    var is_varargs = false;
    var params = make_vector(0);
    var breaking = false;
    while not breaking and ts_peekk(ts, TK_Ident) do
        vector_push(params, token_value(ts_next(ts)));
        if ts_peekk(ts, TK_Semicolon) then
            breaking = true;
        else
            ts_expect(ts, TK_Comma);
        end
    done
    if ts_accept(ts, TK_Ellipsis) then
        is_varargs = true;
    end
    return make_ast_extern(extern_, token_value(ident), params, is_varargs);
end

proc parse_asm ts in
    var asm_ = ts_expect(ts, TK_KW_asm);
    var ident = ts_expect(ts, TK_Ident);
    ts_expect(ts, TK_KW_in);
    var asmcode = ts_expect(ts, TK_String);
    ts_expect(ts, TK_KW_end);
    return make_ast_inline_asm(asm_, token_value(ident), string_cstr(token_value(asmcode)));
end

proc parse ts in
    var roots = make_vector(0);
    var parsed; var tk;
    while ts_peek(ts) do
        tk = ts_peek(ts);
        if ts_peekk(ts, TK_KW_proc) then
            parsed = parse_proc(ts);
        else if ts_peekk(ts, TK_KW_const) then
            parsed = parse_const(ts);
            ts_expect(ts, TK_Semicolon);
        else if ts_peekk(ts, TK_KW_extern) then
            parsed = parse_extern(ts);
            ts_expect(ts, TK_Semicolon);
        else if ts_peekk(ts, TK_KW_asm) then
            parsed = parse_asm(ts);
        else
            tk = ts_peek(ts);
            printf("ERROR: Unexpected token in top-level: %s\n", token_kind_cstr(token_kind(tk)));
            print_token_loc(tk);
            exit(1);
        end

        if not parsed then
            printf("ERROR: Unhandled parse error for %s\n", token_kind_cstr(token_kind(tk)));
            print_token_loc(tk);
            exit(1);
        end
        vector_push(roots, parsed);
    done
    return roots;
end