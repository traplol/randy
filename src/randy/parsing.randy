
proc parse_args_until ts, st, tt, into, until in
    var arg;
    while true do
        if ts_peekk(ts, until) then
            return;
        end
        arg = parse_expression(ts, st, tt);
        if not arg then
            return;
        end
        vector_push(into, arg);
        if ts_peekk(ts, until) then
            return;
        end
        if ts_expect(ts, TK_Comma) then
            if ts_peekk(ts, until) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts_peek(ts));
                exit(1);
            end
        end
    end
end

proc parse_proc_type ts, st, tt, is_instance in
    ts_expect(ts, TK_LParen);
    var param_types = make_vector(0);
    var ret_type = tt_void_type(tt);
    var varargs = false;
    while true do
        if ts_peekk(ts, TK_RParen) then
            break;
        end
        if ts_peekk(ts, TK_Ellipsis) then
            break;
        end
        var type = parse_type(ts, st, tt, is_instance);
        assert(type);
        vector_push(param_types, type);
        if ts_peekk(ts, TK_RightArrow) then
            break;
        end
        if ts_accept(ts, TK_Comma) then
            if ts_peekk(ts, TK_RParen) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts_peek(ts));
                exit(1);
            elif ts_peekk(ts, TK_RightArrow) then
                printf("ERROR: Unexpected token after ','\n");
                print_token_loc(ts_peek(ts));
                exit(1);
            end
        end
    end
    if ts_accept(ts, TK_Ellipsis) then
        varargs = true;
    end
    if ts_accept(ts, TK_RightArrow) then
        ret_type = parse_type(ts, st, tt, is_instance);
    end
    ts_expect(ts, TK_RParen);
    return tt_make_anon_proc(tt, ret_type, param_types, varargs);
end

proc parse_type ts, st, tt, is_instance in
    if ts_peekk(ts, TK_LParen) then
        return parse_proc_type(ts, st, tt, is_instance);
    end
    var type_ident = ts_expect(ts, TK_Ident);
    var inst_params = NULL;
    var generic_params = NULL;
    if ts_accept(ts, TK_LSquare) then
        if is_instance then
            inst_params = make_vector(0);
            while ts_peekk(ts, TK_Ident) do
                var inst_type = parse_type(ts, st, tt, true);
                vector_push(inst_params, inst_type);
                if ts_peekk(ts, TK_RSquare) then
                    break;
                end
                ts_expect(ts, TK_Comma);
            end
        else
            generic_params = make_vector(0);
            while ts_peekk(ts, TK_Ident) do
                vector_push(generic_params, token_value(ts_next(ts)));
                if ts_peekk(ts, TK_RSquare) then
                    break;
                end
                ts_expect(ts, TK_Comma);
            end
        end
        ts_expect(ts, TK_RSquare);
    end
    if inst_params or generic_params then
        NYI_ERR(__FILE__, __LINE__, "generic types");
    end

    var type = tt_get_type_or_make_undefined(tt, token_value(type_ident));
    if ts_accept(ts, TK_Amper) then
        type = tt_get_reference_to_type(tt, type);
    end
    return type;
end

proc parse_var ts, st, tt in
    var var_ = ts_expect(ts, TK_KW_var);
    var ident = ts_expect(ts, TK_Ident);
    var type = NULL;
    var expr = NULL;
    if ts_accept(ts, TK_Colon) then
        type = parse_type(ts, st, tt, true);
    end
    if ts_accept(ts, TK_Assign) then
        expr = parse_expression(ts, st, tt);
        if not expr then
            printf("ERROR: Expected expression after '='\n");
            print_token_loc(ident);
            exit(1);
        end
    end
    var symbol = st_get_symbol_here(st, token_value(ident));
    if symbol then
        printf("ERROR: var `%s` already defined.\n", token_value(ident));
        print_token_loc(ident);
        printf("NOTE: It was previously defined here:\n");
        print_token_loc(symbol_token(symbol));
        exit(1);
    end
    symbol = st_make_local(st, token_value(ident), ident);
    symbol_set_type(symbol, type); // OK if type is NULL
    if expr then
        return make_ast_var_assign(var_, symbol_name(symbol), expr);
    end
    return make_ast_var_decl(var_, symbol_name(symbol));
end

proc parse_if_else ts, st, tt, expect in
    var if_ = ts_expect(ts, expect);
    st_push_scope(st);
    var test = parse_expression(ts, st, tt);
    if not test then
        printf("ERROR: Expected expression after 'if'\n");
        print_token_loc(if_);
        exit(1);
    end
    ts_expect(ts, TK_KW_then);
    var conseq = make_vector(0);
    var altern = make_vector(0);
    parse_statements_until_one_of(ts, st, tt, conseq, TK_KW_elif, TK_KW_end, TK_KW_elif);
    // early end
    if ts_accept(ts, TK_KW_end) then
        st_pop_scope(st);
        return make_ast_if_else(if_, test, conseq, altern);
    end
    // elif ... then
    if ts_peekk(ts, TK_KW_elif) then
        st_pop_scope(st);
        vector_push(altern, parse_if_else(ts, st, tt, TK_KW_elif));
        return make_ast_if_else(if_, test, conseq, altern);
    end
    // else
    ts_expect(ts, TK_KW_else);
    st_pop_scope(st); // discard the scope of the previous if/elif
    st_push_scope(st);
    parse_statements_until(ts, st, tt, altern, TK_KW_end);
    // end
    ts_next(ts);
    st_pop_scope(st);
    return make_ast_if_else(if_, test, conseq, altern);
end

proc parse_while ts, st, tt in
    var while_ = ts_expect(ts, TK_KW_while);
    st_push_scope(st);
    var test = parse_expression(ts, st, tt);
    if not test then
        printf("ERROR: Expected expression after 'while'\n");
        print_token_loc(while_);
        exit(1);
    end
    var body = make_vector(0);
    ts_expect(ts, TK_KW_do);
    parse_statements_until(ts, st, tt, body, TK_KW_end);
    ts_expect(ts, TK_KW_end);
    st_pop_scope(st);
    return make_ast_while(while_, test, body);
end

proc parse_return ts, st, tt in
    var return_ = ts_expect(ts, TK_KW_return);
    if ts_peekk(ts, TK_Semicolon) then
        return make_ast_return(return_, NULL);
    end
    // no need to handle NULL here because return with null expr is a void return.
    var expr = parse_expression(ts, st, tt);
    return make_ast_return(return_, expr);
end

proc parse_assign_op ts, st, tt, lhs, op in
    var op_tk = ts_expect(ts, op);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '%s'\n", token_value(op_tk));
        print_token_loc(op_tk);
        exit(1);
    end
    var k = ast_kind(lhs);
    if k == AstK_Ident then
        // LEAK: I think this ends up leaking the LHS AST node
        var symbol = st_get_symbol(st, ast_ident(lhs));
        if not symbol then
            symbol = st_prepare_undef(st, ast_ident(lhs), ast_token(lhs));
        end
        return make_ast_assign_op(op_tk, symbol_name(symbol), op, expr);
    elif k == AstK_MemberAccess then
        return make_ast_assign_member(op_tk, lhs, op, expr);
    else
        assert(false, "parse_assign_op for %s (%d) not implemented.\n", ast_kind_cstr(k), k);
    end
end

proc parse_pointer_op ts, st, tt in
    var token = ts_peek(ts);
    var size;
    var op;
    if ts_accept(ts, TK_KW_u8!) then
        size = 8;
        op = PointerOp_Write;
    elif ts_accept(ts, TK_KW_u16!) then
        size = 16;
        op = PointerOp_Write;
    elif ts_accept(ts, TK_KW_u32!) then
        size = 32;
        op = PointerOp_Write;
    elif ts_accept(ts, TK_KW_u64!) then
        size = 64;
        op = PointerOp_Write;
    elif ts_accept(ts, TK_KW_u8@) then
        size = 8;
        op = PointerOp_Read;
    elif ts_accept(ts, TK_KW_u16@) then
        size = 16;
        op = PointerOp_Read;
    elif ts_accept(ts, TK_KW_u32@) then
        size = 32;
        op = PointerOp_Read;
    elif ts_accept(ts, TK_KW_u64@) then
        size = 64;
        op = PointerOp_Read;
    else
        printf("ERROR: Unexpected token: %s\n", token_kind_cstr(token_kind(token)));
        print_token_loc(token);
        exit(1);
    end

    ts_expect(ts, TK_LParen);
    var args = make_vector(0);
    parse_args_until(ts, st, tt, args, TK_RParen);
    ts_expect(ts, TK_RParen);

    if op == PointerOp_Read and vector_len(args) != 1 then
        printf("ERROR: Expected pointer read (%s) to have exactly one argument but got %d\n",
                token_cstr(token), vector_len(args));
        print_token_loc(token);
        exit(1);
    elif op == PointerOp_Write and vector_len(args) != 2 then
        printf("ERROR: Expected pointer write (%s) to have exactly two arguments but got %d\n",
                token_cstr(token), vector_len(args));
        print_token_loc(token);
        exit(1);
    end

    return make_ast_pointer_op(token, size, op, args);
end

proc parse_cast ts, st, tt in
    var cast_ = ts_expect(ts, TK_KW_cast);
    ts_expect(ts, TK_LParen);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '('\n");
        print_token_loc(cast_);
        exit(1);
    end
    ts_expect(ts, TK_Comma);
    var type = parse_type(ts, st, tt, true);
    ts_expect(ts, TK_RParen);
    return make_ast_cast(cast_, expr, type);
end

proc parse_sizeof ts, st, tt in
    var sizeof_ = ts_expect(ts, TK_KW__sizeof);
    ts_expect(ts, TK_LParen);
    var idx = ts_idx(ts);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        ts_revert(ts, idx);
        var type = parse_type(ts, st, tt, true);
        ts_expect(ts, TK_RParen);
        return make_ast_sizeof_type(sizeof_, type);
    end
    ts_expect(ts, TK_RParen);
    return make_ast_sizeof_expr(sizeof_, expr);
end

proc parse_offsetof ts, st, tt in
    NYI_ERR(__FILE__, __LINE__, "parse_offsetof");
    return NULL;
end

proc parse_assert ts, st, tt in
    var assert_ = ts_expect(ts, TK_KW_assert);
    ts_expect(ts, TK_LParen);
    var assert_args = make_vector(0);
    parse_args_until(ts, st, tt, assert_args, TK_RParen);
    ts_expect(ts, TK_RParen);
    if vector_len(assert_args) == 0 then
        printf("ERROR: Expected expression to test in 'assert'\n");
        print_token_loc(assert_);
        exit(1);
    end
    var test = vector_get(assert_args, 0);
    var body = make_vector(0);
    var printf_args = make_vector(0);
    var printf_symbol = st_get_symbol(st, "printf");
    assert(printf_symbol, "`printf` not defined for assert.");
    var abort_symbol = st_get_symbol(st, "abort");
    assert(abort_symbol, "`abort` not defined for assert.");

    vector_push(printf_args, make_ast_string(assert_, string_from_cstr("Assertion failed:\n")));
    vector_push(body, make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(printf_symbol)),
                        printf_args));

    var len = vector_len(assert_args);
    if len > 1 then
        printf_args = make_vector(0);
        var i = 1;
        while i < len do
            vector_push(printf_args, vector_get(assert_args, i));
            i += 1;
        end
        vector_push(body, make_ast_call(assert_,
                            make_ast_ident(assert_, symbol_name(printf_symbol)),
                            printf_args));
    end

    printf_args = make_vector(1);
    var string = string_from_cstr("  File \"");
    string_append_cstr(string, token_filename(assert_));
    string_append_cstr(string, "\", line ");
    string_append_int(string, token_line(assert_));
    string_push(string, '\n');
    vector_push(printf_args, make_ast_string(assert_, string));
    vector_push(body, make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(printf_symbol)),
                        printf_args));
    vector_push(body, make_ast_call(assert_,
                        make_ast_ident(assert_, symbol_name(abort_symbol)), make_vector(0))); 

    test = make_ast_prefix(assert_, TK_KW_not, test);
    var ast = make_ast_if_else(assert_, test, body, make_vector(0));
    free_vector(assert_args);
    return ast;
end

proc parse_primary ts, st, tt in
    var peek = ts_peek(ts);
    if not peek then
        return NULL;
    end
    if ts_accept(ts, TK_LParen) then
        var expr = parse_expression(ts, st, tt);
        if not expr then
            printf("ERROR: Expected expression after '('\n");
            print_token_loc(peek);
            exit(1);
        end
        ts_expect(ts, TK_RParen);
        return expr;
    end
    var k = token_kind(peek);
    if k == TK_Ident then
        var ident = ts_next(ts);
        var symbol = st_get_symbol(st, token_value(ident));
        if not symbol then
            symbol = st_prepare_undef(st, token_value(ident), ident);
        end
        return make_ast_ident(peek, symbol_name(symbol));
    elif k == TK_Integer or k == TK_Char then
        return make_ast_integer(peek, cast(token_value(ts_next(ts)), int));
    elif k == TK_String then
        return make_ast_string(peek, token_value(ts_next(ts)));
    elif k == TK_KW__FILE__ then
        return make_ast_string(peek, string_from_cstr(token_filename(ts_next(ts))));
    elif k == TK_KW__LINE__ then
        return make_ast_integer(peek, token_line(ts_next(ts)));
    elif k == TK_KW_u8@ or k == TK_KW_u16@ or k == TK_KW_u32@ or k == TK_KW_u64@ then
        return parse_pointer_op(ts, st, tt);
    elif k == TK_KW_cast then
        return parse_cast(ts, st, tt);
    elif k == TK_KW__offsetof then
        return parse_offsetof(ts, st, tt);
    elif k == TK_KW__sizeof then
        return parse_sizeof(ts, st, tt);
    end
    return NULL;
end

proc parse_postfix ts, st, tt in
    var peek = ts_peek(ts);
    var expr = parse_primary(ts, st, tt);
    if not expr then
        return NULL;
    end

    while ts_peekk_one_of_2(ts, TK_LParen, TK_Dot) do
        var tk = ts_next(ts);
        var k = token_kind(tk);
        if k == TK_LParen then
            var args = make_vector(0);
            parse_args_until(ts, st, tt, args, TK_RParen);
            ts_expect(ts, TK_RParen);
            expr = make_ast_call(peek, expr, args);
        elif k == TK_Dot then
            var member = ts_expect(ts, TK_Ident);
            expr = make_ast_member_access(tk, expr, token_value(member));
        end
    end

    return expr;
end

proc parse_prefix ts, st, tt in
    var postfix = parse_postfix(ts, st, tt);
    if postfix then
        return postfix;
    end

    if ts_peekk_one_of_3(ts, TK_Tilde, TK_KW_not, TK_Minus) then
        var tok = ts_next(ts);
        var expr = parse_prefix(ts, st, tt);
        return make_ast_prefix(tok, token_kind(tok), expr);
    end
    return NULL;
end

proc parse_binary_multiplicative ts, st, tt in
    var lhs = parse_prefix(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_3(ts, TK_Star, TK_Slash, TK_Percent) do
        tok = ts_next(ts);
        rhs = parse_prefix(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_additive ts, st, tt in
    var lhs = parse_binary_multiplicative(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_2(ts, TK_Plus, TK_Minus) do
        tok = ts_next(ts);
        rhs = parse_binary_multiplicative(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_shift ts, st, tt in
    var lhs = parse_binary_additive(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_2(ts, TK_LShift, TK_RShift) do
        tok = ts_next(ts);
        rhs = parse_binary_additive(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_relational ts, st, tt in
    var lhs = parse_binary_shift(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_4(ts, TK_Less, TK_Greater, TK_LessEq, TK_GreaterEq) do
        tok = ts_next(ts);
        rhs = parse_binary_shift(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_equality ts, st, tt in
    var lhs = parse_binary_relational(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk_one_of_2(ts, TK_EqEq, TK_NotEq) do
        tok = ts_next(ts);
        rhs = parse_binary_relational(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_bit_and ts, st, tt in
    var lhs = parse_binary_equality(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_Amper) do
        tok = ts_next(ts);
        rhs = parse_binary_equality(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_bit_xor ts, st, tt in
    var lhs = parse_binary_bit_and(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_Caret) do
        tok = ts_next(ts);
        rhs = parse_binary_bit_and(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_bit_or ts, st, tt in
    var lhs = parse_binary_bit_xor(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_Bar) do
        tok = ts_next(ts);
        rhs = parse_binary_bit_xor(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_land ts, st, tt in
    var lhs = parse_binary_bit_or(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_KW_and) do
        tok = ts_next(ts);
        rhs = parse_binary_bit_or(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_binary_lor ts, st, tt in
    var lhs = parse_binary_land(ts, st, tt);
    if not lhs then
        return NULL;
    end

    var tok; var rhs;
    while ts_peekk(ts, TK_KW_or) do
        tok = ts_next(ts);
        rhs = parse_binary_land(ts, st, tt);
        if not rhs then
            return NULL;
        end
        lhs = make_ast_binop(tok, lhs, token_kind(tok), rhs);
    end
    return lhs;
end

proc parse_expression ts: token_stream, st: symbol_table, tt: type_table -> ast in
    return parse_binary_lor(ts, st, tt);
end

proc parse_statement ts: token_stream, st: symbol_table, tt: type_table -> ast in
    var stmt: ast;
    var expect_semi = true;
    if ts_peekk(ts, TK_KW_var) then
        stmt = parse_var(ts, st, tt);
        expect_semi = true;
    elif ts_peekk(ts, TK_KW_if) then
        stmt = parse_if_else(ts, st, tt, TK_KW_if);
        expect_semi = false;
    elif ts_peekk(ts, TK_KW_while) then
        stmt = parse_while(ts, st, tt);
        expect_semi = false;
    elif ts_peekk(ts, TK_KW_return) then
        stmt = parse_return(ts, st, tt);
        expect_semi = true;
    elif ts_peekk(ts, TK_KW_break) then
        stmt = make_ast_break(ts_next(ts));
        expect_semi = true;
    elif ts_peekk(ts, TK_KW_continue) then
        stmt = make_ast_continue(ts_next(ts));
        expect_semi = true;
    elif ts_peekk(ts, TK_KW_assert) then
        stmt = parse_assert(ts, st, tt);
        expect_semi = true;
    elif ts_peekk_one_of_4(ts, TK_KW_u8!, TK_KW_u16!, TK_KW_u32!, TK_KW_u64!) then
        stmt = parse_pointer_op(ts, st, tt);
        expect_semi = true;
    else
        expect_semi = true;
        stmt = parse_expression(ts, st, tt);
        if stmt and (ast_kind(stmt) == AstK_Ident or ast_kind(stmt) == AstK_MemberAccess) then
            if ts_peekk(ts, TK_Assign) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_Assign);
            elif ts_peekk(ts, TK_PlusEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_PlusEq);
            elif ts_peekk(ts, TK_MinusEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_MinusEq);
            elif ts_peekk(ts, TK_StarEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_StarEq);
            elif ts_peekk(ts, TK_SlashEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_SlashEq);
            elif ts_peekk(ts, TK_PercentEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_PercentEq);
            elif ts_peekk(ts, TK_LShiftEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_LShiftEq);
            elif ts_peekk(ts, TK_RShiftEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_RShiftEq);
            elif ts_peekk(ts, TK_AmperEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_AmperEq);
            elif ts_peekk(ts, TK_CaretEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_CaretEq);
            elif ts_peekk(ts, TK_BarEq) then
                stmt = parse_assign_op(ts, st, tt, stmt, TK_BarEq);
            end
        end
    end

    if not stmt then
        return NULL;
    end
    if expect_semi then
        ts_expect(ts, TK_Semicolon);
    end
    return stmt;
end
    
proc parse_statements_until ts, st, tt, into, kind in
    if ts_peekk(ts, kind) then
        return;
    end
    var stmt = parse_statement(ts, st, tt);
    while stmt do
        vector_push(into, stmt);
        if ts_peekk(ts, kind) then
            stmt = NULL;
        else
            stmt = parse_statement(ts, st, tt);
        end
    end
end

proc parse_statements_until_one_of ts, st, tt, into, k1, k2, k3 in
    if ts_peekk_one_of_3(ts, k1, k2, k3) then
        return;
    end
    var stmt = parse_statement(ts, st, tt);
    while stmt do
        vector_push(into, stmt);
        if ts_peekk_one_of_3(ts, k1, k2, k3) then
            stmt = NULL;
        else
            stmt = parse_statement(ts, st, tt);
        end
    end
end

proc parse_proc ts, st, tt in
    var proc_ = ts_expect(ts, TK_KW_proc);
    var ident = ts_expect(ts, TK_Ident);
    var proc_symbol = st_get_symbol_here(st, token_value(ident));
    if proc_symbol then
        if symbol_is_undef(proc_symbol) then
            symbol_set_kind(proc_symbol, SK_proc);
        else
            printf("ERROR: proc `%s` already defined.\n", token_value(ident));
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(proc_symbol));
            exit(1);
        end
    else
        proc_symbol = st_make_proc(st, token_value(ident), ident);
    end

    st_push_scope(st);
    var body = make_vector(0);
    var params = make_vector(0);
    var param_symbols = make_vector(0);
    var any_type = tt_any_type(tt);
    while ts_peekk(ts, TK_Ident) do
        var param_id = ts_next(ts);
        var param_symbol = st_get_symbol_here(st, token_value(param_id));
        if param_symbol then
            printf("ERROR: param `%s` already defined.\n", token_value(param_id));
            print_token_loc(param_id);
            exit(1);
        end
        param_symbol = st_make_param(st, token_value(param_id), param_id);
        vector_push(params, symbol_name(param_symbol));
        vector_push(param_symbols, param_symbol);
        if ts_peekk(ts, TK_KW_in) then
            symbol_set_type(param_symbol, any_type);
            break;
        elif ts_accept(ts, TK_Colon) then
            symbol_set_type(param_symbol, parse_type(ts, st, tt, true));
            if ts_peekk(ts, TK_KW_in) then
                break;
            end
            if ts_peekk(ts, TK_RightArrow) then
                break;
            end
            ts_expect(ts, TK_Comma);
        elif ts_peekk(ts, TK_RightArrow) then
            symbol_set_type(param_symbol, any_type);
            break;
        else
            symbol_set_type(param_symbol, any_type);
            ts_expect(ts, TK_Comma);
        end
    end
    var return_type = any_type;
    if ts_accept(ts, TK_RightArrow) then
        return_type = parse_type(ts, st, tt, true);
    end
    ts_expect(ts, TK_KW_in);

    var param_types = make_vector(vector_len(param_symbols));
    var i = 0; var len = vector_len(param_symbols);
    while i < len do
        vector_push(param_types, symbol_type(vector_get(param_symbols, i)));
        i += 1;
    end
    free_vector(param_symbols);
    var proc_type = tt_make_anon_proc(tt, return_type, param_types, false);
    symbol_set_type(proc_symbol, proc_type);

    parse_statements_until(ts, st, tt, body, TK_KW_end);
    ts_expect(ts, TK_KW_end);
    st_pop_scope(st);
    var ast = make_ast_procedure(proc_, symbol_name(proc_symbol), params, body);
    type_set_ast(proc_type, ast);
    return ast;
end

proc parse_const ts, st, tt in
    var const_ = ts_expect(ts, TK_KW_const);
    var ident = ts_expect(ts, TK_Ident);
    var type = NULL;
    if ts_accept(ts, TK_Colon) then
        type = parse_type(ts, st, tt, true);
    end
    ts_expect(ts, TK_Assign);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '='\n");
        print_token_loc(const_);
        exit(1);
    end
    var symbol = st_get_symbol_here(st, token_value(ident));
    // No error here because we allow you to have multiple definitions of `const`
    // if they share the same value and that won't be checked until IR generation.
    if not symbol then
        symbol = st_make_const(st, token_value(ident), ident);
    end
    symbol_set_type(symbol, type);
    return make_ast_const(const_, symbol_name(symbol), expr);
end

proc parse_extern ts, st, tt in
    var extern_ = ts_expect(ts, TK_KW_extern);
    var ident = ts_expect(ts, TK_Ident);
    var is_varargs = false;
    var proc_symbol = st_get_symbol_here(st, token_value(ident));
    if proc_symbol then
        if symbol_is_undef(proc_symbol) then
            symbol_set_kind(proc_symbol, SK_extern);
        else
            printf("ERROR: extern `%s` already defined.\n", token_value(ident));
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(proc_symbol));
            exit(1);
        end
    else
        proc_symbol = st_make_extern(st, token_value(ident), ident);
    end
    st_push_scope(st);
    var body = make_vector(0);
    var params = make_vector(0);
    var param_symbols = make_vector(0);
    var any_type = tt_any_type(tt);
    var return_type = NULL;
    while ts_peekk(ts, TK_Ident) do
        var param_id = ts_next(ts);
        var param_symbol = st_get_symbol_here(st, token_value(param_id));
        if param_symbol then
            printf("ERROR: param `%s` already defined.\n", token_value(param_id));
            print_token_loc(param_id);
            exit(1);
        end
        param_symbol = st_make_param(st, token_value(param_id), param_id);
        vector_push(params, symbol_name(param_symbol));
        vector_push(param_symbols, param_symbol);
        if ts_peekk(ts, TK_Semicolon) then
            symbol_set_type(param_symbol, any_type);
            break;
        elif ts_accept(ts, TK_Colon) then
            var peek = ts_peek(ts);
            var type = parse_type(ts, st, tt, false);
            var ty_params = type_params(type);
            if ty_params and vector_len(ty_params) != 0 then
                printf("ERROR: 'extern' does not support generics.\n");
                print_token_loc(peek);
                exit(1);
            end
            symbol_set_type(param_symbol, type);
            if ts_accept(ts, TK_RightArrow) then
                return_type = parse_type(ts, st, tt, false);
                break;
            end
            ts_expect(ts, TK_Comma);
        elif ts_peekk(ts, TK_RightArrow) then
            symbol_set_type(param_symbol, any_type);
            break;
        else
            symbol_set_type(param_symbol, any_type);
            ts_expect(ts, TK_Comma);
        end
    end
    st_pop_scope(st);
    if not return_type then
        if ts_accept(ts, TK_Ellipsis) then
            is_varargs = true;
        end
        if ts_accept(ts, TK_RightArrow) then
            return_type = parse_type(ts, st, tt, true);
        else
            return_type = any_type;
        end
    end
    var rty_params = type_params(return_type);
    if rty_params and vector_len(rty_params) != 0 then
        printf("ERROR: 'extern' does not support generics.\n");
        print_token_loc(extern_);
        exit(1);
    end

    var param_types = make_vector(vector_len(param_symbols));
    var i = 0; var len = vector_len(param_symbols);
    while i < len do
        vector_push(param_types, symbol_type(vector_get(param_symbols, i)));
        i += 1;
    end
    free_vector(param_symbols);
    var proc_type = tt_make_anon_proc(tt, return_type, param_types, is_varargs);
    symbol_set_type(proc_symbol, proc_type);
    return make_ast_extern(extern_, symbol_name(proc_symbol), params, is_varargs);
end

proc parse_asm ts, st, tt in
    var asm_ = ts_expect(ts, TK_KW_asm);
    var ident = ts_expect(ts, TK_Ident);
    ts_expect(ts, TK_KW_in);
    var asmcode = ts_expect(ts, TK_String);
    ts_expect(ts, TK_KW_end);
    var symbol = st_get_symbol_here(st, token_value(ident));
    if symbol then
        if symbol_is_undef(symbol) then
            symbol_set_kind(symbol, SK_asm);
        else
            printf("ERROR: asm `%s` already defined.\n", token_value(ident));
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(symbol));
            exit(1);
        end
    else
        symbol = st_make_asm(st, token_value(ident), ident);
    end

    var proc_type = tt_make_anon_proc(tt, tt_ptr_type(tt), make_vector(0), true);
    symbol_set_type(symbol, proc_type);
    return make_ast_inline_asm(asm_, symbol_name(symbol), string_cstr(token_value(asmcode)));
end

proc parse_global ts, st, tt in
    var global_ = ts_expect(ts, TK_KW_global);
    var ident = ts_expect(ts, TK_Ident);
    var type = NULL;
    if ts_accept(ts, TK_Colon) then
        type = parse_type(ts, st, tt, true);
    end
    ts_expect(ts, TK_Assign);
    var expr = parse_expression(ts, st, tt);
    if not expr then
        printf("ERROR: Expected expression after '='\n");
        print_token_loc(global_);
        exit(1);
    end
    var symbol = st_get_symbol_here(st, token_value(ident));
    if symbol then
        if symbol_is_undef(symbol) then
            symbol_set_kind(symbol, SK_global);
        else
            printf("ERROR: global `%s` already defined.\n", token_value(ident));
            print_token_loc(ident);
            printf("NOTE: It was previously defined here:\n");
            print_token_loc(symbol_token(symbol));
            exit(1);
        end
    else
        symbol = st_make_global(st, token_value(ident), ident);
    end
    symbol_set_type(symbol, type);
    return make_ast_global(global_, symbol_name(symbol), expr);
end

proc parse_struct ts, st, tt in
    // TODO need to push/pop a "type" scope for generics.
    var struct_ = ts_expect(ts, TK_KW_struct);
    var struct_type = NULL;
    if not ts_accept(ts, TK_KW_in) then
        struct_type = parse_type(ts, st, tt, false);
        ts_expect(ts, TK_KW_in);
    end
    var fields = make_vector(0);
    var procs = make_vector(0);
    var proc_symbols = make_vector(0);
    var field_names = make_set(0, cstr_eq, cstr_hash);
    while not ts_peekk(ts, TK_KW_end) do
        var field_name;
        if ts_peekk(ts, TK_KW_proc) then
            var proc_ = parse_proc(ts, st, tt);
            vector_push(procs, proc_);
            vector_push(proc_symbols, st_get_symbol(st, ast_ident(proc_)));
            field_name = ast_ident(proc_);
            if set_contains(field_names, field_name) then
                printf("ERROR: struct `%s` already contains a member named `%s.`\n",
                    tt_get_type_name(tt, struct_type), field_name);
                print_ast_src_loc(proc_);
                exit(1);
            end
        elif ts_peekk(ts, TK_Ident) then
            var field_ident = ts_next(ts);
            ts_expect(ts, TK_Colon);
            var field_type = parse_type(ts, st, tt, true);
            ts_expect(ts, TK_Semicolon);
            vector_push(fields, make_field(field_type, token_value(field_ident), -1, field_ident));
            field_name = token_value(field_ident);
            if set_contains(field_names, field_name) then
                printf("ERROR: struct `%s` already contains a member named `%s.`\n",
                    tt_get_type_name(tt, struct_type), field_name);
                print_token_loc(field_ident);
                exit(1);
            end
        else
            var tk = ts_peek(ts);
            printf("ERROR: Unexpected token in struct: %s\n", token_kind_cstr(token_kind(tk)));
            print_token(tk);
            print_token_loc(tk);
            exit(1);
        end
        set_add(field_names, field_name);
    end
    ts_expect(ts, TK_KW_end);

    assert(vector_len(proc_symbols) == 0, "Struct procs not implemented yet.\n");

    if not struct_type then
        struct_type = tt_make_anon_struct(tt, fields, proc_symbols);
    elif not type_is_undefined(struct_type) then
        printf("ERROR: type `%s` already defined.", tt_get_type_name(tt, struct_type));
    else
        type_set_kind(struct_type, TyK_struct);
        type_set_struct_fields(struct_type, fields);
        type_set_struct_procs(struct_type, proc_symbols);
    end

    var ast = make_ast_struct(struct_, struct_type, fields, procs);
    type_set_ast(struct_type, ast);
    return ast;
end

proc parse ts: token_stream, st: symbol_table, tt: type_table in
    var roots = make_vector(0);
    var parsed: ast = NULL; var tk: token;
    while ts_peek(ts) do
        tk = ts_peek(ts);
        if ts_peekk(ts, TK_KW_proc) then
            parsed = parse_proc(ts, st, tt);
        elif ts_peekk(ts, TK_KW_const) then
            parsed = parse_const(ts, st, tt);
            ts_expect(ts, TK_Semicolon);
        elif ts_peekk(ts, TK_KW_extern) then
            parsed = parse_extern(ts, st, tt);
            ts_expect(ts, TK_Semicolon);
        elif ts_peekk(ts, TK_KW_asm) then
            parsed = parse_asm(ts, st, tt);
        elif ts_peekk(ts, TK_KW_global) then
            parsed = parse_global(ts, st, tt);
            ts_expect(ts, TK_Semicolon);
        elif ts_peekk(ts, TK_KW_struct) then
            parsed = parse_struct(ts, st, tt);
        else
            tk = ts_peek(ts);
            printf("ERROR: Unexpected token in top-level: %s\n", token_kind_cstr(token_kind(tk)));
            print_token(tk);
            print_token_loc(tk);
            exit(1);
        end

        if not parsed then
            printf("ERROR: Unhandled parse error for %s\n", token_kind_cstr(token_kind(tk)));
            print_token_loc(tk);
            exit(1);
        end
        vector_push(roots, parsed);
        parsed = NULL;
    end
    return roots;
end
