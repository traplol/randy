#include std/core
#include std/string
#include std/vector
#include std/queue
#include std/set
#include std/map
#include std/time
#include std/process

global g_SymbolTable = NULL;
global g_TypeTable = NULL;
global g_SpecialFlag = false;

#include utils
#include token
#include lexer
#include token_stream
#include ast
#include symbol_table
#include type_table
#include parsing
#include type_infer
#include type_checker
#include ir_context
#include compiler_context
#include x86_64_backend

proc print_timespan msg, starttime, endtime in
    var elap_s = timespec_sec(endtime) - timespec_sec(starttime);
    var elap_ns = timespec_nsec(endtime) - timespec_nsec(starttime);
    var elap_ms = (elap_s * 1000) + (elap_ns / 1000000);
    printf("%s%dms\n", msg, elap_ms);
end

proc print_usage in
    printf("usage: randy -c file -o path [flags]\n");
    printf("Options and arguments:\n");
    printf("-h            : Show this message\n");
    printf("-c file       : Compile file\n");
    printf("-o path       : The path to compile the file provided by the -c flag.\n");
    printf("-I path       : Specify a path to search for #include directives.\n");
    printf("-g            : Enable debug info\n");
    printf("-ld flags...  : Everything after -ld will be passed to the linker directly.\n");
    printf("                see 'man ld' for linker flags.\n");
    printf("-v -vv -vvv   : Compiler verbosity level\n");
end

proc assemble_and_link asm_path, obj_path, exe_path, ld_flags in
    var as_args = make_vector(0);
    vector_push(as_args, "as");
    vector_push(as_args, "-c");
    vector_push(as_args, asm_path);
    vector_push(as_args, "-o");
    vector_push(as_args, obj_path);
    vector_push(as_args, NULL); // argv is required to be null terminated.
    subprocess_blocking("/usr/bin/as", vector_buf(as_args), NULL);

    var ld_args = make_vector(0);
    vector_push(ld_args, "ld");
    vector_push(ld_args, "-o");
    vector_push(ld_args, exe_path);
    vector_push(ld_args, obj_path);
    var i = 0; var len = vector_len(ld_flags);
    while i < len do
        vector_push(ld_args, vector_get(ld_flags, i));
        i += 1;
    end
    vector_push(ld_args, NULL);
    subprocess_blocking("/usr/bin/ld", vector_buf(ld_args), NULL);

    free_vector(as_args);
    free_vector(ld_args);
end

proc main argc, argv in
    var i = 0;
    if argc < 2 then
        printf("No input file.\n");
        return 1;
    else
        var true_starttime = make_empty_timespec();
        var true_endtime = make_empty_timespec();
        time(true_starttime);

        var include_paths = make_vector(8);
        vector_push(include_paths, getcwd());

        var in_path = NULL;
        var out_path = NULL;
        var verbosity = 0;
        var debug = 0;
        var do_print_ir = false;
        var do_print_ast = false;
        var will_compile = true;
        var ld_flags = make_vector(0);
        
        i = 1; var p;
        while i < argc do
            if cstr_eq("-h", u64@(argv + i*sizeof_PTR)) then
                print_usage();
                return 1;
            else if cstr_eq("-c", u64@(argv + i*sizeof_PTR)) then
                i += 1;
                if in_path then
                    printf("More than one input file not supported.\n");
                    return 1;
                end
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No input file supplied with -c flag.\n");
                    return 1;
                end
                in_path = p;
            else if cstr_eq("-o", u64@(argv + i*sizeof_PTR)) then
                    i += 1;
                if out_path then
                    printf("More than one output file not supported.\n");
                    return 1;
                end
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No output file supplied with -o flag.\n");
                    return 1;
                end
                out_path = p;
            else if cstr_eq("-I", u64@(argv + i*sizeof_PTR)) then
                    i += 1;
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No path supplied with -I flag.\n");
                    return 1;
                end
                vector_push(include_paths, string_from_cstr(p));
            else if cstr_eq("-v", u64@(argv + i*sizeof_PTR)) then
                verbosity = 1;
            else if cstr_eq("-vv", u64@(argv + i*sizeof_PTR)) then
                verbosity = 2;
            else if cstr_eq("-vvv", u64@(argv + i*sizeof_PTR)) then
                verbosity = 3;
            else if cstr_eq("-g", u64@(argv + i*sizeof_PTR)) then
                debug = 1;
            else if cstr_eq("-ir", u64@(argv + i*sizeof_PTR)) then
                do_print_ir = true;
                will_compile = false;
            else if cstr_eq("-ast", u64@(argv + i*sizeof_PTR)) then
                do_print_ast = true;
                will_compile = false;
            else if cstr_eq("-special", u64@(argv + i*sizeof_PTR)) then
                g_SpecialFlag = true;
            else if cstr_eq("-ld", u64@(argv + i*sizeof_PTR)) then
                i += 1;
                while i < argc do
                    vector_push(ld_flags, u64@(argv + i*sizeof_PTR));
                    i += 1;
                end
            end
            i += 1;
        end

        if g_SpecialFlag then
            printf("special enabled\n");
        end

        if not in_path then
            printf("No input file.\n");
            return 1;
        end
        if not out_path and will_compile then
            printf("No output path.\n");
            return 1;
        end

        var source_dir = getcwd();
        string_push(source_dir, '/');
        string_append_cstr(source_dir, in_path);
        var abspath = string_duplicate(source_dir);
        while string_len(source_dir) > 0 and string_back(source_dir) != '/' do
            string_pop(source_dir);
        end
        if string_len(source_dir) > 1 then
            string_pop(source_dir);
        end
        vector_push(include_paths, source_dir);

        var starttime = make_empty_timespec();
        var endtime = make_empty_timespec();

        time(starttime);
        var tokens = lex_file(string_cstr(abspath), include_paths);
        if not tokens then
            return 1;
        end
        var token_stream = make_token_stream(tokens);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Lexing took: ", starttime, endtime);
        end

        time(starttime);
        var type_table = make_type_table();
        g_TypeTable = type_table;
        var symbol_table = make_symbol_table();
        g_SymbolTable = symbol_table;
        st_push_scope(symbol_table);
        var roots = parse(token_stream, symbol_table, type_table);
        st_pop_scope(symbol_table);
        assert(st_depth(symbol_table) == 0, "Compiler bug: Didn't pop symbol table scope somewhere.\n");
        time(endtime);
        if verbosity > 0 then
            print_timespan("Parsing took: ", starttime, endtime);
        end

        if do_print_ast then
            print_whole_ast(roots);
        end

        time(starttime);
        tt_calculate_structs(type_table);
        type_infer(type_table, symbol_table, roots);
        type_check(type_table, symbol_table, roots);
        time(endtime);
        //tc_print_types(type_table);
        //tc_print_symbols(type_table, symbol_table);
        if verbosity > 0 then
            print_timespan("Typechecking took: ", starttime, endtime);
        end

        time(starttime);
        var irctx = make_ir_context();
        ir_compile_roots(irctx, roots, symbol_table, type_table);
        time(endtime);
        if verbosity > 0 then
            print_timespan("IR compile took: ", starttime, endtime);
        end

        if do_print_ir then
            ir_print_whole_ir(irctx);
        end

        if not will_compile then
            return 0;
        end

        var main_proc = NULL;
        var exit_proc = NULL;
        if ir_is_proc(irctx, "main") then
            main_proc = proc_info_label(ir_get_proc(irctx, "main"));
        else if ir_is_label(irctx, "_proc_main") then
            main_proc = "_proc_main";
        else
            printf("ERROR: no `main` procedure.\n");
            return 1;
        end
        if ir_is_proc(irctx, "exit") then
            exit_proc = proc_info_label(ir_get_proc(irctx, "exit"));
        end

        time(starttime);
        var cctx = make_compiler_context(debug);
        cc_out(cctx, ".text");
        cc_out_files(irctx, cctx);
        cc_out_instructions(irctx, cctx);
        cc_out_start(cctx, main_proc, exit_proc);
        cc_out_externs(irctx, cctx);
        cc_out_data_section(irctx, cctx);
        time(endtime);
        if verbosity > 0 then
            print_timespan("ASM compile took: ", starttime, endtime);
        end

        time(starttime);
        var out_asm_path = string_from_cstr(out_path);
        string_append_cstr(out_asm_path, ".s");
        var out_obj_path = string_from_cstr(out_path);
        string_append_cstr(out_obj_path, ".o");
        cc_lines_to_file(cctx, string_cstr(out_asm_path));
        assemble_and_link(string_cstr(out_asm_path), string_cstr(out_obj_path), out_path, ld_flags);
        free_string(out_asm_path);
        free_string(out_obj_path);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Assemble and Link took: ", starttime, endtime);
        end

        time(true_endtime);
        if verbosity > 0 then
            print_timespan("Total elapsed: ", true_starttime, true_endtime);
        end
        return 0;
    end
end
