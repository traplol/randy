#include std/core
#include std/string
#include std/vector
#include std/set
#include std/map
#include std/time
#include std/process

#include utils
#include token
#include lexer
#include token_stream
#include ast
#include parsing
#include typechecking
#include ir_context
#include compiler_context
#include x86_64_backend

proc cc_out_files irctx, cctx in
    var files = ir_files(irctx);
    var i = 0;
    while i < vector_len(files) do
        cc_out_file(cctx, i, vector_get(files, i));
        compiler_context_add_file(cctx, vector_get(files, i), i);
        i = i + 1;
    done
end

proc cc_out_instructions irctx, cctx in
    var instructions = ir_instructions(irctx);
    var i = 0;
    while i < vector_len(instructions) do
        x86_64_emit_instruction(cctx, vector_get(instructions, i));
        i = i + 1;
    done
end

proc cc_out_externs irctx, cctx in
    var externs = ir_externs(irctx);
    var cur_extern = map_begin(externs);
    var end_extern = map_end(externs);
    while cur_extern != end_extern do
        cc_out_extern(cctx, map_pair_key(cur_extern));
        cur_extern = map_next(externs, cur_extern);
    done
end

proc cc_out_data_section irctx, cctx in
    cc_out(cctx, ".data");
    cc_out(cctx, ".align 8");
    cc_out(cctx, "__argc__: .quad 0");
    cc_out(cctx, "__argv__: .quad 0");

    var globals = ir_globals(irctx);
    var i = 0; var len = vector_len(globals);
    var str = make_string(0);
    while i < len do
        string_reset(str);
        var gi = vector_get(globals, i);
        var kind = global_info_kind(gi);
        var label = global_info_label(gi);
        var value = global_info_value(gi);
        if kind == GIK_String then
            string_append_cstr(str, label);
            string_append_cstr(str, ": .quad ");
            string_append_cstr(str, value);
            cc_out(cctx, string_cstr(str));
        else if kind == GIK_Integer then
            string_append_cstr(str, label);
            string_append_cstr(str, ": .quad ");
            string_append_int(str, value);
            cc_out(cctx, string_cstr(str));
        else
            NYI_ERR("cc_out_data_section: unknown global kind");
        end
        i = i + 1;
    done

    cc_out(cctx, ".section .rodata, \"a\"");
    var strings = ir_strings(irctx);
    var cur_string = map_begin(strings);
    var end_string = map_end(strings);
    while cur_string != end_string do
        cc_out(cctx, ".align 8");
        cc_out_label(cctx, map_pair_val(cur_string));
        cc_out_string(cctx, map_pair_key(cur_string));
        cur_string = map_next(strings, cur_string);
    done
end

proc cc_out_start cctx, main_proc, exit_proc in
    cc_out(cctx, "    .global _start");
    cc_out(cctx, "    .align 16");
    cc_out(cctx, "_start:");
    cc_out(cctx, "    movq (%rsp), %rdi");
    cc_out(cctx, "    movq %rsp, %rsi");
    cc_out(cctx, "    addq $8, %rsi");
    cc_out(cctx, "    movq %rdi, (__argc__)");
    cc_out(cctx, "    movq %rsi, (__argv__)");
    var str = make_string(0);
    string_append_cstr(str, "    call ");
    string_append_cstr(str, main_proc);
    cc_out(cctx, string_cstr(str));
    cc_out(cctx, "    movq %rax, %rdi");
    if exit_proc then
        string_reset(str);
        string_append_cstr(str, "    call ");
        string_append_cstr(str, exit_proc);
        cc_out(cctx, string_cstr(str));
    end
    cc_out(cctx, "    movq $60, %rax");
    cc_out(cctx, "    syscall");
    cc_out(cctx, "    int3");
end

proc cc_lines_to_file cctx, path in
    var fd = open_for_write(path);
    if fd < 0 then
        printf("Open for write failed with (%d), path was: '%s'\n", fd, path);
        return false;
    end
    var i = 0; var j = 0;
    var BUFLEN = 4096;
    var buffer = malloc(BUFLEN);
    var buffer_end = buffer + BUFLEN;
    var p = buffer;

    var lines = compiler_context_lines(cctx);
    var num_lines = vector_len(lines);
    var line; var line_len;
    while i < num_lines do
        line = vector_get(lines, i);
        j = 0; line_len = string_len(line);
        while j < line_len do
            if p == buffer_end then
                write_file(fd, buffer, BUFLEN);
                p = buffer;
            end
            u8!(p, string_get(line, j));
            p = p + 1;
            j = j + 1;
        done
        if p == buffer_end then
            write_file(fd, buffer, BUFLEN);
            p = buffer;
        end
        u8!(p, '\n');
        p = p + 1;
        i = i + 1;
    done
    if p != buffer then
        write_file(fd, buffer, p - buffer);
    end
    close(fd);
    free(buffer);
    return true;
end

proc print_timespan msg, starttime, endtime in
    var elap_s = timespec_sec(endtime) - timespec_sec(starttime);
    var elap_ns = timespec_nsec(endtime) - timespec_nsec(starttime);
    var elap_ms = (elap_s * 1000) + (elap_ns / 1000000);
    printf("%s%dms\n", msg, elap_ms);
end

proc print_usage in
    printf("usage: randy -c file -o path [flags]\n");
    printf("Options and arguments:\n");
    printf("-h            : Show this message\n");
    printf("-c file       : Compile file\n");
    printf("-o path       : The path to compile the file provided by the -c flag.\n");
    printf("-I path       : Specify a path to search for #include directives.\n");
    printf("TODO:-ld flags...  : Everything after -ld will be passed to the linker directly.\n");
    printf("                see 'man ld' for linker flags.\n");
    printf("-v -vv -vvv   : Compiler verbosity level\n");
end

proc assemble_and_link asm_path, obj_path, exe_path, ld_flags in
    var as_args = make_vector(0);
    vector_push(as_args, "as");
    vector_push(as_args, "-c");
    vector_push(as_args, asm_path);
    vector_push(as_args, "-o");
    vector_push(as_args, obj_path);
    vector_push(as_args, NULL); // argv is required to be null terminated.
    subprocess_blocking("/usr/bin/as", vector_buf(as_args), NULL);

    var ld_args = make_vector(0);
    vector_push(ld_args, "ld");
    vector_push(ld_args, "-o");
    vector_push(ld_args, exe_path);
    vector_push(ld_args, obj_path);
    var i = 0; var len = vector_len(ld_flags);
    while i < len do
        vector_push(ld_args, vector_get(ld_flags, i));
        i = i + 1;
    done
    vector_push(ld_args, NULL);
    subprocess_blocking("/usr/bin/ld", vector_buf(ld_args), NULL);

    free_vector(as_args);
    free_vector(ld_args);
end

proc main argc, argv in
    var i = 0;
    if argc < 2 then
        printf("No input file.\n");
        return 1;
    else
        var true_starttime = make_empty_timespec();
        var true_endtime = make_empty_timespec();
        time(true_starttime);

        var include_paths = make_vector(8);
        vector_push(include_paths, getcwd());

        var in_path = NULL;
        var out_path = NULL;
        var verbosity = 0;
        var ld_flags = make_vector(0);
        
        i = 1; var p;
        while i < argc do
            if cstr_eq("-h", u64@(argv + i*sizeof_PTR)) then
                print_usage();
                return 1;
            else if cstr_eq("-c", u64@(argv + i*sizeof_PTR)) then
                i = i + 1;
                if in_path then
                    printf("More than one input file not supported.\n");
                    return 1;
                end
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No input file supplied with -c flag.\n");
                    return 1;
                end
                in_path = p;
            else if cstr_eq("-o", u64@(argv + i*sizeof_PTR)) then
                i = i + 1;
                if out_path then
                    printf("More than one output file not supported.\n");
                    return 1;
                end
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No output file supplied with -o flag.\n");
                    return 1;
                end
                out_path = p;
            else if cstr_eq("-I", u64@(argv + i*sizeof_PTR)) then
                i = i + 1;
                p = u64@(argv + i*sizeof_PTR);
                if not p then
                    printf("No path supplied with -I flag.\n");
                    return 1;
                end
                vector_push(include_paths, string_from_cstr(p));
            else if cstr_eq("-v", u64@(argv + i*sizeof_PTR)) then
                verbosity = 1;
            else if cstr_eq("-vv", u64@(argv + i*sizeof_PTR)) then
                verbosity = 2;
            else if cstr_eq("-vvv", u64@(argv + i*sizeof_PTR)) then
                verbosity = 3;
            else if cstr_eq("-ld", u64@(argv + i*sizeof_PTR)) then
                i = i + 1;
                while i < argc do
                    vector_push(ld_flags, u64@(argv + i*sizeof_PTR));
                    i = i + 1;
                done
            end
            i = i + 1;
        done

        if not in_path then
            printf("No input file.\n");
            return 1;
        end
        if not out_path then
            printf("No output path.\n");
            return 1;
        end

        var source_dir = getcwd();
        string_push(source_dir, '/');
        string_append_cstr(source_dir, in_path);
        var abspath = string_duplicate(source_dir);
        while string_len(source_dir) > 0 and string_back(source_dir) != '/' do
            string_pop(source_dir);
        done
        if string_len(source_dir) > 1 then
            string_pop(source_dir);
        end
        vector_push(include_paths, source_dir);

        var starttime = make_empty_timespec();
        var endtime = make_empty_timespec();

        time(starttime);
        var tokens = lex_file(string_cstr(abspath), include_paths);
        if not tokens then
            return 1;
        end
        var token_stream = make_token_stream(tokens);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Lexing took: ", starttime, endtime);
        end

        time(starttime);
        var roots = parse(token_stream);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Parsing took: ", starttime, endtime);
        end

        time(starttime);
        typecheck(roots);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Typechecking took: ", starttime, endtime);
        end

        time(starttime);
        var irctx = make_ir_context();
        ir_compile_roots(irctx, roots);
        time(endtime);
        if verbosity > 0 then
            print_timespan("IR compile took: ", starttime, endtime);
        end

        var main_proc = NULL;
        var exit_proc = NULL;
        if ir_is_proc(irctx, "main") then
            main_proc = proc_info_label(ir_get_proc(irctx, "main"));
        else
            printf("ERROR: no `main` procedure.\n");
            return 1;
        end
        if ir_is_proc(irctx, "exit") then
            exit_proc = proc_info_label(ir_get_proc(irctx, "exit"));
        end

        time(starttime);
        var cctx = make_compiler_context();
        cc_out(cctx, ".text");
        cc_out_files(irctx, cctx);
        cc_out_instructions(irctx, cctx);
        cc_out_start(cctx, main_proc, exit_proc);
        cc_out_externs(irctx, cctx);
        cc_out_data_section(irctx, cctx);
        time(endtime);
        if verbosity > 0 then
            print_timespan("ASM compile took: ", starttime, endtime);
        end

        time(starttime);
        var out_asm_path = string_from_cstr(out_path);
        string_append_cstr(out_asm_path, ".s");
        var out_obj_path = string_from_cstr(out_path);
        string_append_cstr(out_obj_path, ".o");
        cc_lines_to_file(cctx, string_cstr(out_asm_path));
        assemble_and_link(string_cstr(out_asm_path), string_cstr(out_obj_path), out_path, ld_flags);
        free_string(out_asm_path);
        free_string(out_obj_path);
        time(endtime);
        if verbosity > 0 then
            print_timespan("Assemble and Link took: ", starttime, endtime);
        end

        time(true_endtime);
        if verbosity > 0 then
            print_timespan("Total elapsed: ", true_starttime, true_endtime);
        end
        return 0;
    end
end

