
const TyK_undefined = 0;
const TyK_void      = 1;
const TyK_any       = 2;
const TyK_primitive = 3;
const TyK_reference = 4; // NYI
const TyK_procedure = 5;
const TyK_struct    = 6; // NYI
const TyK_enum      = 7; // NYI
const TyK_union     = 8; // NYI
const TyK_array     = 9; // NYI

const TTYPE_kind      = 0;  // TyK
const TTYPE_id        = 8;  // int
const TTYPE_params    = 16; // type vector
const TTYPE_ast       = 24; // ast
// reference
const TTYPE_ref_type  = 32; // type
// procedure
const TTYPE_proc_return_type = 32; // type
const TTYPE_proc_parameters  = 40; // symbol vector
// struct
const TTYPE_struct_names = 32; // cstr vector
const TTYPE_struct_types = 40; // type vector
// enum
const TTYPE_enum_names  = 32; // cstr vector
const TTYPE_enum_values = 40; // int vector
// union
const TTYPE_union_names = 32; // cstr vector
const TTYPE_union_types = 40; // type vector
// array
const TTYPE_array_count = 32; // number of elems in array
const TTYPE_array_type  = 40; // type of each elem in array

const sizeof_TTYPE = 48;

proc make_type kind, id in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_kind, kind);
    u64!(self + TTYPE_id, id);
    return self;
end

proc make_type_undefined id in
    return make_type(TyK_undefined, id);
end

proc make_type_reference id, type in
    var self = make_type(TyK_reference, id);
    u64!(self + TTYPE_ref_type, type);
    return self;
end

proc make_type_procedure id, return_type, parameters in
    var self = make_type(TyK_procedure, id);
    u64!(self + TTYPE_proc_return_type, return_type);
    u64!(self + TTYPE_proc_parameters, parameters);
    return self;
end

proc make_type_struct id, field_names, field_types in
    var self = make_type(TyK_struct, id);
    u64!(self + TTYPE_struct_names, field_names);
    u64!(self + TTYPE_struct_types, field_types);
    return self;
end

proc make_type_enum id, enum_names, enum_values in
    var self = make_type(TyK_enum, id);
    u64!(self + TTYPE_enum_names, enum_names);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

proc make_type_union id, union_names, union_types in
    var self = make_type(TyK_union, id);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

proc make_type_array id, count, type in
    var self = make_type(TyK_array, id);
    u64!(self + TTYPE_array_count, count);
    u64!(self + TTYPE_array_type, type);
    return self;
end

proc type_kind self in return u64@(self + TTYPE_kind); end
proc type_id self in return u64@(self + TTYPE_id); end
proc type_params self in return u64@(self + TTYPE_params); end
proc type_ast self in return u64@(self + TTYPE_ast); end
proc type_ref_type self in return u64@(self + TTYPE_ref_type); end
proc type_proc_return_type self in return u64@(self + TTYPE_proc_return_type); end
proc type_proc_parameters self in return u64@(self + TTYPE_proc_parameters); end
proc type_struct_names self in return u64@(self + TTYPE_struct_names); end
proc type_struct_types self in return u64@(self + TTYPE_struct_types); end
proc type_enum_names self in return u64@(self + TTYPE_enum_names); end
proc type_enum_values self in return u64@(self + TTYPE_enum_values); end
proc type_union_names self in return u64@(self + TTYPE_union_names); end
proc type_union_types self in return u64@(self + TTYPE_union_types); end
proc type_array_count self in return u64@(self + TTYPE_array_count); end
proc type_array_type self in return u64@(self + TTYPE_array_type); end

proc type_set_kind self, kind in u64!(self + TTYPE_kind, kind); end
proc type_set_params self, params in u64!(self + TTYPE_params, params); end
proc type_set_ast self, ast in u64!(self + TTYPE_ast, ast); end
proc type_set_ref_type self, type in u64!(self + TTYPE_ref_type, type); end
proc type_set_proc_return_type self, type in u64!(self + TTYPE_proc_return_type, type); end
proc type_set_proc_parameters self, params in u64!(self + TTYPE_proc_parameters, params); end
proc type_set_struct_names self, names in u64!(self + TTYPE_struct_names, names); end
proc type_set_struct_types self, types in u64!(self + TTYPE_struct_types, types); end
proc type_set_enum_names self, names in u64!(self + TTYPE_enum_names, names); end
proc type_set_enum_values self, values in u64!(self + TTYPE_enum_values, values); end
proc type_set_union_names self, names in u64!(self + TTYPE_union_names, names); end
proc type_set_union_types self, types in u64!(self + TTYPE_union_types, types); end
proc type_set_array_count self, count in u64!(self + TTYPE_array_count, count); end
proc type_set_array_type self, type in u64!(self + TTYPE_array_type, type); end

proc type_is_undefined self in return type_kind(self) == TyK_undefined; end
proc type_is_void self in return type_kind(self) == TyK_void; end
proc type_is_any self in return type_kind(self) == TyK_any; end
proc type_is_primitive self in return type_kind(self) == TyK_primitive; end
proc type_is_reference self in return type_kind(self) == TyK_reference; end
proc type_is_struct self in return type_kind(self) == TyK_struct; end
proc type_is_procedure self in return type_kind(self) == TyK_procedure; end
proc type_is_enum self in return type_kind(self) == TyK_enum; end
proc type_is_union self in return type_kind(self) == TyK_union; end
proc type_is_array self in return type_kind(self) == TyK_array; end

proc types_eq a, b in
    if a == b then
        return true;
    end
    if type_is_procedure(a) and type_is_procedure(b) then
        var a_ret = type_proc_return_type(a);
        var b_ret = type_proc_return_type(b);
        if not types_eq(a_ret, b_ret) then
            return false;
        end
        var a_params = type_proc_parameters(a);
        var b_params = type_proc_parameters(b);
        if vector_len(a_params) != vector_len(b_params) then
            return false;
        end
        var i = 0; var len = vector_len(a_params);
        while i < len do
            var ap = vector_get(a_params, i);
            var bp = vector_get(b_params, i);
            if not types_eq(ap, bp) then
                return false;
            end
            i += 1;
        end
        return true;
    end
    return a == b;
end

proc types_assignable tt, a, b in
    if types_eq(a, b) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    if a == ptr and b == cstr then
        return true;
    end
    if a == cstr and b == ptr then
        return true;
    end
    return false;
end

proc print_type self in
    var kind = type_kind(self);
    var id = type_id(self);
    printf("kind=%d, id=%d\n", kind, id);
end

const TTYPE_TABLE_type_ids  = 0;  // (cstr, int) map : name -> type_id
const TTYPE_TABLE_types     = 8;  // type vector : type_id is index into this vector
const TTYPE_TABLE_names     = 16; // cstr vector : type_id is index into this vector, may have NULLs
const TTYPE_TABLE_ast_types = 24; // (ast, type) map : ast -> type
const TTYPE_TABLE_void_type = 32; // fast ref to `void` type
const TTYPE_TABLE_any_type  = 40; // fast ref to `any` type
const TTYPE_TABLE_int_type  = 48; // fast ref to `int` type
const TTYPE_TABLE_ptr_type  = 56; // fast ref to `ptr` type
const TTYPE_TABLE_cstr_type = 64; // fast ref to `cstr` type
const sizeof_TTYPE_TABLE    = 72;

proc make_type_table in
    var self = malloc(sizeof_TTYPE_TABLE);
    var type_ids = make_map(0, cstr_eq, cstr_hash);
    var types = make_vector(0);
    var names = make_vector(0);
    u64!(self + TTYPE_TABLE_type_ids, type_ids);
    u64!(self + TTYPE_TABLE_types, types);
    u64!(self + TTYPE_TABLE_names, names);
    u64!(self + TTYPE_TABLE_ast_types, make_map(0, NULL, NULL));

    var t; var type_idx;
    
    type_idx = vector_len(types);
    t = make_type(TyK_void, type_idx);
    u64!(self + TTYPE_TABLE_void_type, t);
    map_set(type_ids, "void", type_idx);
    vector_push(types, t);
    vector_push(names, "void");

    type_idx = vector_len(types);
    t = make_type(TyK_any, type_idx);
    u64!(self + TTYPE_TABLE_any_type, t);
    map_set(type_ids, "any", type_idx);
    vector_push(types, t);
    vector_push(names, "any");

    type_idx = vector_len(types);
    t = make_type(TyK_primitive, type_idx);
    u64!(self + TTYPE_TABLE_int_type, t);
    map_set(type_ids, "int", type_idx);
    vector_push(types, t);
    vector_push(names, "int");

    type_idx = vector_len(types);
    t = make_type(TyK_primitive, type_idx);
    u64!(self + TTYPE_TABLE_ptr_type, t);
    map_set(type_ids, "ptr", type_idx);
    vector_push(types, t);
    vector_push(names, "ptr");

    type_idx = vector_len(types);
    t = make_type(TyK_primitive, type_idx);
    u64!(self + TTYPE_TABLE_cstr_type, t);
    map_set(type_ids, "cstr", type_idx);
    vector_push(types, t);
    vector_push(names, "cstr");

    return self;
end

proc type_table_type_ids self in return u64@(self + TTYPE_TABLE_type_ids); end
proc type_table_types self in return u64@(self + TTYPE_TABLE_types); end
proc type_table_names self in return u64@(self + TTYPE_TABLE_names); end
proc type_table_ast_types self in return u64@(self + TTYPE_TABLE_ast_types); end
proc tt_any_type self in return u64@(self + TTYPE_TABLE_any_type); end
proc tt_void_type self in return u64@(self + TTYPE_TABLE_void_type); end
proc tt_int_type self in return u64@(self + TTYPE_TABLE_int_type); end
proc tt_ptr_type self in return u64@(self + TTYPE_TABLE_ptr_type); end
proc tt_cstr_type self in return u64@(self + TTYPE_TABLE_cstr_type); end

proc tt_get_ast_type self, ast in
    var found = map_find(type_table_ast_types(self), ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc tt_set_ast_type self, ast, type in
    map_set(type_table_ast_types(self), ast, type);
end

proc tt_get_type_name self, type in
    return vector_get(type_table_names(self), type_id(type));
end

proc tt_get_type_or_null self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, map_pair_val(found));
    end
    return NULL;
end

proc tt_get_type_or_make_undefined self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, map_pair_val(found));
    end
    var type_idx = vector_len(types);
    var type = make_type_undefined(type_idx);
    map_set(type_ids, name, type_idx);
    vector_push(types, type);
    vector_push(type_table_names(self), name);
    return type;
end

proc tt_make_anon_proc self, return_type, params in
    var types = type_table_types(self);
    var type = make_type_procedure(vector_len(types), return_type, params);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc tt_make_anon_struct self, field_names, field_types in
    var types = type_table_types(self);
    var type = make_type_struct(vector_len(types), field_names, field_types);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc tt_make_anon_union self, field_names, field_types in
    var types = type_table_types(self);
    var type = make_type_union(vector_len(types), field_names, field_types);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc _tt_append_proc_type_repr self, string, type in
    if not type then
        string_append_cstr(string, "{null}");
    else if type_is_procedure(type) then
        var ptn = tt_get_proc_type_name(self, type);
        string_append_string(string, ptn);
        free_string(ptn);
    else
        var tn = tt_get_type_name(self, type);
        if tn then
            string_append_cstr(string, tn);
        else
            string_append_cstr(string, "{no type}");
        end
    end
end

proc tt_get_proc_type_name self, type in
    if not type_is_procedure(type) then
        return NULL;
    end

    var string = make_string(20);
    string_push(string, '(');
    var params = type_proc_parameters(type);
    var ret_ty = type_proc_return_type(type);

    var i = 0; var len = vector_len(params);
    while i < len do
        var symbol = vector_get(params, i);
        _tt_append_proc_type_repr(self, string, symbol_type(symbol));
        i += 1;
        if i < len then
            string_append_cstr(string, ", ");
        end
    end

    string_append_cstr(string, " -> ");
    _tt_append_proc_type_repr(self, string, ret_ty);
    string_push(string, ')');
    return string;
end
