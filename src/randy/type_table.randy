
const TFIELD_type       = 0;  // type
const TFIELD_name       = 8;  // cstr
const TFIELD_bit_offset = 16; // int
const TFIELD_token      = 24; // Token&
const sizeof_TFIELD = 32;

def make_field type, name, bit_offset, token -> field in
    var self = malloc(sizeof_TFIELD);
    u64!(self + TFIELD_type, type);
    u64!(self + TFIELD_name, name);
    u64!(self + TFIELD_bit_offset, bit_offset);
    u64!(self + TFIELD_token, token);
    return cast(self, field);
end

def field_type self: field -> type in return cast(u64@(self + TFIELD_type), type); end
def field_name self: field -> cstr in return cast(u64@(self + TFIELD_name), cstr); end
def field_bit_offset self: field -> int in return cast(u64@(self + TFIELD_bit_offset), int); end
def field_token self: field -> Token& in return cast(u64@(self + TFIELD_token), Token&); end

def field_set_bit_offset self: field, bit_offset: int in
    u64!(self + TFIELD_bit_offset, bit_offset);
end

struct EnumValue in
    token: Token&;
    name: cstr;
    value: ast;
    cache_value: ptr;
end

def make_enum_value token: Token&, name: cstr, value: ast -> EnumValue& in
    var self = cast(malloc(__sizeof(EnumValue)), EnumValue&);
    self.token = token;
    self.name = name;
    self.value = value;
    self.cache_value = NULL;
    return self;
end

const TyK_undefined = 0;
const TyK_void      = 1;
const TyK_any       = 2;
const TyK_int_like  = 3;
const TyK_reference = 4; // NYI
const TyK_def       = 5;
const TyK_struct    = 6;
const TyK_enum      = 7;
const TyK_union     = 8; // NYI

const TTYPE_id        = 0;  // int
const TTYPE_kind      = 8;  // TyK
const TTYPE_size      = 12; // uint32
const TTYPE_params    = 16; // type Vector&
const TTYPE_ast       = 24; // ast
const TTYPE_ref_to_this = 32; // type
// reference
const TTYPE_deref_type  = 40; // type
// def
const TTYPE_def_return_type = 40; // type
const TTYPE_def_parameters  = 48; // symbol Vector&
const TTYPE_def_varargs     = 56; // bool
// struct
const TTYPE_struct_fields = 40; // field Vector&
const TTYPE_struct_defs   = 48; // def_symbol Vector&
// enum
const TTYPE_enum_values = 40; // EnumValue& Vector&
// union
const TTYPE_union_names = 40; // cstr Vector&
const TTYPE_union_types = 48; // type Vector&

const sizeof_TTYPE = 64;
const TYPE_NEEDS_SIZING = (1<<32)-1;

def make_type kind: int, id: int -> type in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_id, id);
    u32!(self + TTYPE_kind, kind);
    u32!(self + TTYPE_size, TYPE_NEEDS_SIZING);
    return cast(self, type);
end

def make_type_undefined id: int in
    return make_type(TyK_undefined, id);
end

def make_type_reference id: int, type: type in
    var self = make_type(TyK_reference, id);
    u64!(self + TTYPE_deref_type, type);
    return self;
end

def make_type_def id: int, return_type: type, param_types: Vector&, varargs: bool in
    var self = make_type(TyK_def, id);
    u64!(self + TTYPE_def_return_type, return_type);
    u64!(self + TTYPE_def_parameters, param_types);
    u8!(self + TTYPE_def_varargs, varargs);
    return self;
end

def make_type_struct id: int, fields: Vector&, defs: Vector& in
    var self = make_type(TyK_struct, id);
    u64!(self + TTYPE_struct_fields, fields);
    u64!(self + TTYPE_struct_defs, defs);
    return self;
end

def make_type_enum id: int, enum_values: Vector& in
    var self = make_type(TyK_enum, id);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

def make_type_union id: int, union_names: Vector&, union_types: Vector& in
    var self = make_type(TyK_union, id);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

def type_kind self: type in return cast(u32@(self + TTYPE_kind), int); end
def type_size self: type in return cast(u32@(self + TTYPE_size), int); end
def type_id self: type in return cast(u64@(self + TTYPE_id), int); end
def type_params self: type in return cast(u64@(self + TTYPE_params), Vector&); end
def type_ast self: type in return cast(u64@(self + TTYPE_ast), ast); end
def type_deref_type self: type in return cast(u64@(self + TTYPE_deref_type), type); end
def type_ref_to_this self: type in return cast(u64@(self + TTYPE_ref_to_this), type); end
def type_def_return_type self: type in
    return cast(u64@(self + TTYPE_def_return_type), type);
end
def type_def_parameters self: type in
    return cast(u64@(self + TTYPE_def_parameters), Vector&);
end
def type_def_varargs self: type in
    return cast(u8@(self + TTYPE_def_varargs), bool);
end
def type_struct_fields self: type in
    return cast(u64@(self + TTYPE_struct_fields), Vector&);
end
def type_struct_defs self: type in
    return cast(u64@(self + TTYPE_struct_defs), Vector&);
end
def type_enum_values self: type in return cast(u64@(self + TTYPE_enum_values), Vector&); end
def type_union_names self: type in return cast(u64@(self + TTYPE_union_names), Vector&); end
def type_union_types self: type in return cast(u64@(self + TTYPE_union_types), Vector&); end

def type_set_kind self: type, kind: int in u32!(self + TTYPE_kind, kind); end
def type_set_size self: type, size: int in u32!(self + TTYPE_size, size); end
def type_set_params self: type, params: Vector& in u64!(self + TTYPE_params, params); end
def type_set_ast self: type, ast: ast in u64!(self + TTYPE_ast, ast); end
def type_set_deref_type self: type, type: type in u64!(self + TTYPE_deref_type, type); end
def type_set_ref_to_this self: type, type: type in u64!(self + TTYPE_ref_to_this, type); end
def type_set_def_return_type self: type, type: type in
    u64!(self + TTYPE_def_return_type, type);
end
def type_set_def_parameters self: type, params: Vector& in
    u64!(self + TTYPE_def_parameters, params);
end
def type_set_def_varargs self: type, varargs: bool in
    u8!(self + TTYPE_def_varargs, varargs);
end
def type_set_struct_fields self: type, fields: Vector& in u64!(self + TTYPE_struct_fields, fields); end
def type_set_struct_defs self: type, defs: Vector& in u64!(self + TTYPE_struct_defs, defs); end
def type_set_enum_values self: type, values: Vector& in u64!(self + TTYPE_enum_values, values); end
def type_set_union_names self: type, names: Vector& in u64!(self + TTYPE_union_names, names); end
def type_set_union_types self: type, types: Vector& in u64!(self + TTYPE_union_types, types); end

def type_is_undefined self: type in return type_kind(self) == TyK_undefined; end
def type_is_void self: type in return type_kind(self) == TyK_void; end
def type_is_any self: type in return type_kind(self) == TyK_any; end
def type_is_int_like self: type in return type_kind(self) == TyK_int_like; end
def type_is_reference self: type in return type_kind(self) == TyK_reference; end
def type_is_struct self: type in return type_kind(self) == TyK_struct; end
def type_is_def self: type in return type_kind(self) == TyK_def; end
def type_is_enum self: type in return type_kind(self) == TyK_enum; end
def type_is_union self: type in return type_kind(self) == TyK_union; end

def type_is_scalar self: type in
    if type_is_int_like(self) then
        return true;
    elif type_is_reference(self) then
        return true;
    elif type_is_def(self) then
        return true;
    end
    return false;
end

def types_eq a: type, b: type in
    if a == b then
        return true;
    end
    if type_is_def(a) and type_is_def(b) then
        var a_ret = type_def_return_type(a);
        var b_ret = type_def_return_type(b);
        if not types_eq(a_ret, b_ret) then
            return false;
        end
        var a_params = type_def_parameters(a);
        var b_params = type_def_parameters(b);
        if a_params.length != b_params.length then
            return false;
        end
        var i = 0; var len = a_params.length;
        while i < len do
            var ap = vector_get(a_params, i);
            var bp = vector_get(b_params, i);
            if not types_eq(ap, bp) then
                return false;
            end
            i += 1;
        end
        return true;
    end
    return a == b;
end

def _basic_def_type_match tt, lhs, rhs in
    if type_def_varargs(lhs) != type_def_varargs(rhs) then
        return false;
    elif not types_assignable(tt, type_def_return_type(lhs), type_def_return_type(rhs)) then
        return false;
    end
    var lhs_params = type_def_parameters(lhs);
    var rhs_params = type_def_parameters(rhs);
    if lhs_params.length != rhs_params.length then
        return false;
    end

    var i = 0; var len = lhs_params.length;
    while i < len do
        var a = vector_get(lhs_params, i);
        var b = vector_get(rhs_params, i);
        if not types_assignable(tt, a, b) then
            return false;
        end
        i += 1;
    end
    return true;
end

def types_assignable tt: TypeTable&, lhs: type, rhs: type in
    if types_eq(lhs, rhs) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    var char = tt_char_type(tt);
    var int = tt_int_type(tt);
    var bool = tt_bool_type(tt);
    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        // ensure the rhs can fit into the lhs.
        if type_size(lhs) >= type_size(rhs) then
            return true;
        end
    end

    if lhs == ptr and rhs == cstr then
        return true;
    elif lhs == cstr and rhs == ptr then
        return true;
    elif lhs == ptr and type_is_int_like(rhs) then
        return true;
    elif lhs == ptr and type_is_reference(rhs) then
        return true;
    elif type_is_reference(lhs) and rhs == ptr then
        return true;
    elif type_is_def(lhs) and type_is_def(rhs) then
        return _basic_def_type_match(tt, lhs, rhs);
    elif lhs == ptr and type_is_def(rhs) then
        return true;
    elif type_is_def(lhs) and rhs == ptr then
        return true;
    elif lhs == char and rhs == int then
        return true;
    elif lhs == int and rhs == char then
        return true;
    elif lhs == int and rhs == bool then
        return true;
    elif lhs == bool and type_is_int_like(rhs) then
        return true;
    elif lhs == bool and type_is_scalar(rhs) then
        return true;
    end
    return false;
end

struct TypeTable in
    type_ids: map;   // (cstr, int) map : name -> type_id
    types: Vector&;  // type Vector& : type_id is index into this Vector&
    names: Vector&;  // cstr Vector& : type_id is index into this Vector&, may have NULLs
    ast_types: map;  // (ast, type) map : ast -> type
    void_type: type; // fast ref to `void` type
    any_type: type;  // fast ref to `any` type
    int_type: type;  // fast ref to `int` type
    char_type: type; // fast ref to `char` type
    ptr_type: type;  // fast ref to `ptr` type
    cstr_type: type; // fast ref to `cstr` type
    bool_type: type; // fast ref to `bool` type
end

def _tt_make_type tyk, name, size, type_ids, types, names in
    var type_idx = types.length;
    var t = make_type(tyk, type_idx);
    type_set_size(t, size);
    map_set(type_ids, name, type_idx);
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

def _tt_make_ref_type type, name, type_ids, types, names in
    assert(not type_ref_to_this(type));
    var type_idx = types.length;
    var t = make_type_reference(type_idx, type);
    type_set_size(t, PTR_BITS);
    type_set_ref_to_this(type, t);
    if name then
        map_set(type_ids, name, type_idx);
    end
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

def _tt_make_type_alias type, name, type_ids, types, names in
    map_set(type_ids, name, types.length);
    vector_push(types, type);
    vector_push(names, name);
end

def make_type_table -> TypeTable& in
    var self: TypeTable& = malloc(__sizeof(TypeTable));
    var type_ids = make_map(0, cstr_eq, cstr_hash);
    var types = make_vector(0);
    var names = make_vector(0);
    self.type_ids = type_ids;
    self.types = types;
    self.names = names;
    self.ast_types = make_map(0, NULL, NULL);

    var void_t = _tt_make_type(TyK_void, "void", 0, type_ids, types, names);
    self.void_type = void_t;

    var any_t = _tt_make_type(TyK_any, "any", 0, type_ids, types, names);
    self.any_type = any_t;

    var bool_t = _tt_make_type(TyK_int_like, "bool", BOOL_BITS, type_ids, types, names);
    self.bool_type = bool_t;

    var int_t = _tt_make_type(TyK_int_like, "int", INT_BITS, type_ids, types, names);
    self.int_type = int_t;

    var char_t = _tt_make_type(TyK_int_like, "char", CHAR_BITS, type_ids, types, names);
    self.char_type = char_t;

    var ptr_t = _tt_make_ref_type(void_t, "ptr", type_ids, types, names);
    self.ptr_type = ptr_t;

    var cstr_t = _tt_make_ref_type(char_t, "cstr", type_ids, types, names);
    self.cstr_type = cstr_t;

    _tt_make_type_alias(char_t, "int8", type_ids, types, names);
    _tt_make_type_alias(int_t, "int64", type_ids, types, names);

    _tt_make_type(TyK_int_like, "int16", 16, type_ids, types, names);
    _tt_make_type(TyK_int_like, "int32", 32, type_ids, types, names);

    return self;
end

def type_table_type_ids self: TypeTable& in return self.type_ids; end
def type_table_types self: TypeTable& in return self.types; end
def type_table_names self: TypeTable& in return self.names; end
def type_table_ast_types self: TypeTable& in return self.ast_types; end
def tt_any_type self: TypeTable& in return self.any_type; end
def tt_void_type self: TypeTable& in return self.void_type; end
def tt_int_type self: TypeTable& in return self.int_type; end
def tt_ptr_type self: TypeTable& in return self.ptr_type; end
def tt_cstr_type self: TypeTable& in return self.cstr_type; end
def tt_bool_type self: TypeTable& in return self.bool_type; end
def tt_char_type self: TypeTable& in return self.char_type; end

def tt_get_ast_type self, ast in
    var found = map_find(type_table_ast_types(self), ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def tt_set_ast_type self, ast, type in
    map_set(type_table_ast_types(self), ast, type);
end

def tt_get_type_name self, type in
    return vector_get(type_table_names(self), type_id(type));
end

def tt_get_type_or_null self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, cast(map_pair_val(found), int));
    end
    return NULL;
end

def tt_get_type_or_make_undefined self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, cast(map_pair_val(found), int));
    end
    var type_idx = types.length;
    var type = make_type_undefined(type_idx);
    map_set(type_ids, name, type_idx);
    vector_push(types, type);
    vector_push(type_table_names(self), name);
    return type;
end

def tt_get_reference_to_type self, type in
    var ref = type_ref_to_this(type);
    if not ref then
        ref = _tt_make_ref_type(type, NULL,
                    type_table_type_ids(self),
                    type_table_types(self),
                    type_table_names(self));
    end
    return ref;
end

def tt_make_generic_undefined self, name, generic_params -> type in
    assert(false, "Not implemented\n");
end

def tt_make_generic_instance self, name, inst_params -> type in
    assert(false, "Not implemented\n");
end

def tt_make_anon_def self, return_type, param_types, varargs in
    var types = type_table_types(self);
    var type = make_type_def(types.length, return_type, param_types, varargs);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

def tt_make_anon_struct self, fields, defs in
    var types = type_table_types(self);
    var type = make_type_struct(types.length, fields, defs);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

def tt_make_anon_union self, field_names, field_types in
    var types = type_table_types(self);
    var type = make_type_union(types.length, field_names, field_types);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

def _tt_append_def_type_repr self, string, type in
    if not type then
        string_append_cstr(string, "{null}");
    elif type_is_def(type) then
        var ptn = tt_get_def_type_name(self, type);
        string_append_string(string, ptn);
        free_string(ptn);
    else
        var tn = tt_get_type_name(self, type);
        if tn then
            string_append_cstr(string, tn);
        else
            string_append_cstr(string, "{no type}");
        end
    end
end

def tt_get_def_type_name self, type in
    if not type_is_def(type) then
        return NULL;
    end

    var string = make_string(20);
    string_push(string, '(');
    var params = type_def_parameters(type);
    var ret_ty = type_def_return_type(type);

    var i = 0; var len = params.length;
    while i < len do
        var param_type = vector_get(params, i);
        _tt_append_def_type_repr(self, string, param_type);
        i += 1;
        if i < len then
            string_append_cstr(string, ", ");
        end
    end
    if i == 0 then
        string_append_cstr(string, "void");
    end

    string_append_cstr(string, " -> ");
    _tt_append_def_type_repr(self, string, ret_ty);
    string_push(string, ')');
    return string;
end

def tt_calculate_struct self, stype, again_q in
    if type_size(stype) != TYPE_NEEDS_SIZING then
        return;
    end
    var fields = type_struct_fields(stype);
    var bit_offs = 0;
    var i = 0; var len = fields.length;
    var ptr_align = false;
    while i < len do
        var field = vector_get(fields, i);
        var fname = field_name(field);
        var ftype = field_type(field);

        if type_is_reference(ftype) and not ptr_align then
            ptr_align = true;
        end

        var size = type_size(ftype);
        if size == TYPE_NEEDS_SIZING then
            queue_enqueue(again_q, stype);
            return;
        end
        if not type_is_struct(ftype) then
            bit_offs = (bit_offs + (size - 1)) & -size; // align to nearest boundary
        end
        field_set_bit_offset(field, bit_offs);
        bit_offs += size;
        i += 1;
    end
    if ptr_align then
        bit_offs = (bit_offs + (PTR_BITS-1)) & -PTR_BITS;
    end
    type_set_size(stype, bit_offs);
end

def tt_detect_cycles self, stype in
    // Breadth-first search for cycles.
    var q = make_queue(0);
    var explored = make_set(0, NULL, NULL);

    set_add(explored, stype);
    var fields = type_struct_fields(stype);
    var i = 0; var len = fields.length;
    while i < len do
        var field = vector_get(fields, i);
        var ftype = field_type(field);
        if ftype == stype then // immediate self-reference
            return true;
        end
        if type_is_struct(ftype) and not set_contains(explored, ftype) then
            set_add(explored, ftype);
            queue_enqueue(q, ftype);
        end
        i += 1;
    end

    while queue_len(q) != 0 do
        var v = queue_dequeue(q);
        if v == stype then
            return true;
        end
        fields = type_struct_fields(v);
        i = 0; len = fields.length;
        while i < len do
            var field = vector_get(fields, i);
            var ftype = field_type(field);
            if ftype == stype then
                return true;
            end
            if type_is_struct(ftype) and not set_contains(explored, ftype) then
                set_add(explored, ftype);
                queue_enqueue(q, ftype);
            end
            i += 1;
        end
    end
    free_queue(q);
    free_set(explored);
    return false;
end

def tt_check_struct_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = cast(vector_get(fields, i), field);
        var fname = field_name(field);
        var ftoke = field_token(field);
        var found = map_find(member_name_map, fname);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", fname);
            print_token_loc(ftoke);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, fname, ftoke);
        i += 1;
    end

    var defs = type_struct_defs(type);
    i = 0; len = defs.length;
    while i < len do
        var def_ = cast(vector_get(defs, i), Symbol&);
        var found = map_find(member_name_map, def_.name);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", def_.name);
            print_token_loc(def_.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, def_.name, def_.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_check_enum_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var enum_vals = type_enum_values(type);
    var i = 0; var len = enum_vals.length;
    while i < len do
        var ev = cast(vector_get(enum_vals, i), EnumValue&);
        var found = map_find(member_name_map, ev.name);
        if found then
            printf("ERROR: enum `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", ev.name);
            print_token_loc(ev.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, ev.name, ev.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_calculate_structs self in
    var to_calc = make_queue(0);
    var types = type_table_types(self);
    var i = 0; var len = types.length;
    var void = tt_void_type(self);
    while i < len do
        var type = vector_get(types, i);
        if type_is_undefined(type) then
            printf("WARN: type `%s` is still undefined!\n", tt_get_type_name(self, type));
            type_set_size(type, PTR_BITS);
            type_set_kind(type, TyK_reference);
            type_set_deref_type(type, void);
        elif type_is_struct(type) and type_size(type) == TYPE_NEEDS_SIZING then
            queue_enqueue(to_calc, type);
        end
        if type_is_struct(type) then
            tt_check_struct_for_field_name_collisions(self, type);
        elif type_is_enum(type) then
            tt_check_enum_for_field_name_collisions(self, type);
        end
        i += 1;
    end

    while queue_len(to_calc) != 0 do
        var type = queue_dequeue(to_calc);
        if tt_detect_cycles(self, type) then
            printf("ERROR: Detected cycles in struct `%s`\n", tt_get_type_name(self, type));
            exit(1);
        end
        tt_calculate_struct(self, type, to_calc);
    end
    free_queue(to_calc);
end

def tt_print_type_name self, type in
    if type then
        if type_is_def(type) then
            var string = tt_get_def_type_name(self, type);
            printf("%s", string_cstr(string));
            free_string(string);
        else
            var name = tt_get_type_name(self, type);
            if name then
                printf("%s", name);
            elif type_is_reference(type) then
                var refs = 0;
                while type_is_reference(type) do
                    if type_deref_type(type) then
                        type = type_deref_type(type);
                        refs += 1;
                    else
                        break;
                    end
                end
                printf("%s", tt_get_type_name(self, type));
                while refs != 0 do
                    printf("&");
                    refs -= 1;
                end
            else
                printf("<type id %d>", type_id(type));
            end
        end
    else
        printf("{no type}");
    end
end

def scope_resolve_type tt: TypeTable&, ast: ast, error: bool -> type in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = cast(vector_get(defs, i), Symbol&);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_type;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.`\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return tt_any_type(tt);
    elif type_is_enum(type) then
        return type;
    elif type_is_union(type) then
        assert(false, "scope resolve for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return tt_any_type(tt);
end

def scope_resolve_def tt: TypeTable&, ast: ast, error: bool -> Symbol& in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = cast(vector_get(defs, i), Symbol&);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.`\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return NULL;
    elif type_is_enum(type) then
        return NULL;
    elif type_is_union(type) then
        assert(false, "scope_resolve_def for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return NULL;
end
