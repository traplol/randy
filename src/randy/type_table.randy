
struct Field in
    type: type;
    name: cstr;
    bit_offset: int;
    token: Token&;
end

def make_field type, name, bit_offset, token -> Field& in
    var self: Field& = malloc(__sizeof(Field));
    self.type = type;
    self.name = name;
    self.bit_offset = bit_offset;
    self.token = token;
    return self;
end

def field_make_copy self: Field& in
    return make_field(self.type, self.name, self.bit_offset, self.token);
end

struct EnumValue in
    token: Token&;
    name: cstr;
    value: ast;
    cache_value: ptr;
end

def make_enum_value token: Token&, name: cstr, value: ast -> EnumValue& in
    var self = cast(malloc(__sizeof(EnumValue)), EnumValue&);
    self.token = token;
    self.name = name;
    self.value = value;
    self.cache_value = NULL;
    return self;
end

const TyK_undefined = 0;
const TyK_void      = 1;
const TyK_any       = 2;
const TyK_int_like  = 3;
const TyK_reference = 4;
const TyK_def       = 5;
const TyK_struct    = 6;
const TyK_enum      = 7;
const TyK_union     = 8; // NYI
const TyK_generic_param = 9;

const TTYPE_id          = 0;  // int
const TTYPE_kind        = 8;  // TyK
const TTYPE_is_generic  = 9;  // bool
const TTYPE_size        = 12; // uint32
const TTYPE_params      = 16; // type Vector&
const TTYPE_ast         = 24; // ast
const TTYPE_ref_to_this = 32; // type
const TTYPE_instances   = 40; // type Vector& : generic instances of this type
// reference
const TTYPE_deref_type  = 48; // type
// def
const TTYPE_def_return_type = 48; // type
const TTYPE_def_parameters  = 56; // symbol Vector&
const TTYPE_def_varargs     = 64; // bool
// struct
const TTYPE_struct_fields = 48; // Field& Vector&
const TTYPE_struct_defs   = 56; // def_symbol Vector&
// enum
const TTYPE_enum_values = 48; // EnumValue& Vector&
// union
const TTYPE_union_names = 48; // cstr Vector&
const TTYPE_union_types = 56; // type Vector&

const sizeof_TTYPE = 72;
const TYPE_NEEDS_SIZING = (1<<32)-1;

def make_type kind: int, id: int -> type in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_id, id);
    u8!(self + TTYPE_kind, kind);
    u8!(self + TTYPE_is_generic, false);
    u32!(self + TTYPE_size, TYPE_NEEDS_SIZING);
    return cast(self, type);
end

def make_type_undefined id: int in
    return make_type(TyK_undefined, id);
end

def make_type_reference id: int, type: type in
    var self = make_type(TyK_reference, id);
    u64!(self + TTYPE_deref_type, type);
    return self;
end

def make_type_def id: int, return_type: type, param_types: Vector[type]&, varargs: bool in
    var self = make_type(TyK_def, id);
    u64!(self + TTYPE_def_return_type, return_type);
    u64!(self + TTYPE_def_parameters, param_types);
    u8!(self + TTYPE_def_varargs, varargs);
    return self;
end

def make_type_struct id: int, fields: Vector[Field&]&, defs: Vector[Symbol&]& in
    var self = make_type(TyK_struct, id);
    u64!(self + TTYPE_struct_fields, fields);
    u64!(self + TTYPE_struct_defs, defs);
    return self;
end

def make_type_enum id: int, enum_values: Vector[EnumValue&]& in
    var self = make_type(TyK_enum, id);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

def make_type_union id: int, union_names: Vector[cstr]&, union_types: Vector[type]& in
    var self = make_type(TyK_union, id);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

def copy_type_with_id type: type, id: int in
    var copy = cast(malloc(sizeof_TTYPE), type);
    memcpy(copy, type, sizeof_TTYPE);
    u64!(copy + TTYPE_id, id);
    return copy;
end

def type_kind self: type in return cast(u8@(self + TTYPE_kind), int); end
def type_is_generic self: type in return cast(u8@(self + TTYPE_is_generic), bool); end
def type_size self: type in return cast(u32@(self + TTYPE_size), int); end
def type_id self: type in return cast(u64@(self + TTYPE_id), int); end
def type_params self: type in return cast(u64@(self + TTYPE_params), Vector[type]&); end
def type_instances self: type in return cast(u64@(self + TTYPE_instances), Vector[type]&); end
def type_ast self: type in return cast(u64@(self + TTYPE_ast), ast); end
def type_deref_type self: type in return cast(u64@(self + TTYPE_deref_type), type); end
def type_ref_to_this self: type in return cast(u64@(self + TTYPE_ref_to_this), type); end
def type_def_return_type self: type in
    return cast(u64@(self + TTYPE_def_return_type), type);
end
def type_def_parameters self: type in
    return cast(u64@(self + TTYPE_def_parameters), Vector[type]&);
end
def type_def_varargs self: type in
    return cast(u8@(self + TTYPE_def_varargs), bool);
end
def type_struct_fields self: type in
    return cast(u64@(self + TTYPE_struct_fields), Vector[Field&]&);
end
def type_struct_defs self: type in
    return cast(u64@(self + TTYPE_struct_defs), Vector[Symbol&]&);
end
def type_enum_values self: type in return cast(u64@(self + TTYPE_enum_values), Vector[EnumValue&]&); end
def type_union_names self: type in return cast(u64@(self + TTYPE_union_names), Vector[cstr]&); end
def type_union_types self: type in return cast(u64@(self + TTYPE_union_types), Vector[type]&); end

def type_set_kind self: type, kind: int in u8!(self + TTYPE_kind, kind); end
def type_set_is_generic self: type, val: bool in u8!(self + TTYPE_is_generic, val); end
def type_set_size self: type, size: int in u32!(self + TTYPE_size, size); end
def type_set_params self: type, params: Vector[type]& in u64!(self + TTYPE_params, params); end
def type_set_instances self: type, instances: Vector[type]& in
    u64!(self + TTYPE_instances, instances);
end
def type_set_ast self: type, ast: ast in u64!(self + TTYPE_ast, ast); end
def type_set_deref_type self: type, type: type in u64!(self + TTYPE_deref_type, type); end
def type_set_ref_to_this self: type, type: type in u64!(self + TTYPE_ref_to_this, type); end
def type_set_def_return_type self: type, type: type in
    u64!(self + TTYPE_def_return_type, type);
end
def type_set_def_parameters self: type, params: Vector[Symbol]& in
    u64!(self + TTYPE_def_parameters, params);
end
def type_set_def_varargs self: type, varargs: bool in
    u8!(self + TTYPE_def_varargs, varargs);
end
def type_set_struct_fields self: type, fields: Vector[Field&]& in u64!(self + TTYPE_struct_fields, fields); end
def type_set_struct_defs self: type, defs: Vector[Symbol&]& in u64!(self + TTYPE_struct_defs, defs); end
def type_set_enum_values self: type, values: Vector[EnumValue&]& in u64!(self + TTYPE_enum_values, values); end
def type_set_union_names self: type, names: Vector[cstr]& in u64!(self + TTYPE_union_names, names); end
def type_set_union_types self: type, types: Vector[type]& in u64!(self + TTYPE_union_types, types); end

def type_is_undefined self: type in return type_kind(self) == TyK_undefined; end
def type_is_void self: type in return type_kind(self) == TyK_void; end
def type_is_any self: type in return type_kind(self) == TyK_any; end
def type_is_int_like self: type in return type_kind(self) == TyK_int_like; end
def type_is_reference self: type in return type_kind(self) == TyK_reference; end
def type_is_struct self: type in return type_kind(self) == TyK_struct; end
def type_is_def self: type in return type_kind(self) == TyK_def; end
def type_is_enum self: type in return type_kind(self) == TyK_enum; end
def type_is_union self: type in return type_kind(self) == TyK_union; end
def type_is_generic_param self: type in return type_kind(self) == TyK_generic_param; end

def type_is_scalar self: type in
    if type_is_int_like(self) then
        return true;
    elif type_is_reference(self) then
        return true;
    elif type_is_def(self) then
        return true;
    end
    return false;
end

def types_eq a: type, b: type in
    if a == b then
        return true;
    end
    if type_id(a) == type_id(b) then
        return true;
    end
    if type_is_reference(a) and type_is_reference(b) then
        return types_eq(type_deref_type(a), type_deref_type(b));
    end
    return false;
end

def _basic_def_type_match tt, lhs, rhs in
    if type_def_varargs(lhs) != type_def_varargs(rhs) then
        return false;
    elif not types_assignable(tt, type_def_return_type(lhs), type_def_return_type(rhs)) then
        return false;
    end
    var lhs_params = type_def_parameters(lhs);
    var rhs_params = type_def_parameters(rhs);
    if lhs_params.length != rhs_params.length then
        return false;
    end

    var i = 0; var len = lhs_params.length;
    while i < len do
        var a = lhs_params.get(i);
        var b = rhs_params.get(i);
        if not types_assignable(tt, a, b) then
            return false;
        end
        i += 1;
    end
    return true;
end

def types_assignable tt: TypeTable&, lhs: type, rhs: type in
    if types_eq(lhs, rhs) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    var char = tt_char_type(tt);
    var int = tt_int_type(tt);
    var bool = tt_bool_type(tt);
    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        // ensure the rhs can fit into the lhs.
        if type_size(lhs) >= type_size(rhs) then
            return true;
        end
    end

    if lhs == ptr and rhs == cstr then
        return true;
    elif lhs == cstr and rhs == ptr then // TODO FIXME: cstr should not accept ptr
        return true;
    elif lhs == ptr and type_is_int_like(rhs) then // TODO FIXME: ptr should not accept int-like
        return true;
    elif lhs == ptr and type_is_reference(rhs) then
        return true;
    elif type_is_reference(lhs) and rhs == ptr then // TODO FIXME: ref should not accept ptr
        return true;
    elif type_is_def(lhs) and type_is_def(rhs) then
        return _basic_def_type_match(tt, lhs, rhs);
    elif lhs == ptr and type_is_def(rhs) then
        return true;
    elif type_is_def(lhs) and rhs == ptr then // TODO FIXME: function should not accept ptr
        return true;
    // TODO FIXME: this is a hack so int literals, which are `int`s can be assigned to chars.
    elif lhs == char and type_is_int_like(rhs) then
        return true;
    elif lhs == bool and type_is_scalar(rhs) then
        return true;
    end
    return false;
end

struct TypeScope in
    types: map; // (cstr, int) : the types within the current scope
    parent: TypeScope&;
end

def make_type_scope parent: TypeScope& -> TypeScope& in
    var self = cast(malloc(__sizeof(TypeScope)), TypeScope&);
    self.types = make_map(0, cstr_eq, cstr_hash);
    self.parent = parent;
    return self;
end

def type_scope_find self, name -> type in
    var cur = self;
    while cur do
        var found = map_find(cur.types, name);
        if found then
            return map_pair_val(found);
        end
        cur = cur.parent;
    end
    return NULL;
end

struct TypeTable in
    type_scope: TypeScope&;
    top_type_scope: map; // fast reference to the top-level type scope.
    all_types: Vector[type]&;  // type Vector& : all types; type_id is index into this Vector&
    names: Vector[cstr]&;  // cstr Vector& : type_id is index into this Vector&, may have NULLs
    ast_types: map;  // (ast, type) map : ast -> type
    type_substitutes: map; // (type, type) map : replace the key type with val type
    void_type: type; // fast ref to `void` type
    any_type: type;  // fast ref to `any` type
    int_type: type;  // fast ref to `int` type
    char_type: type; // fast ref to `char` type
    ptr_type: type;  // fast ref to `ptr` type
    cstr_type: type; // fast ref to `cstr` type
    bool_type: type; // fast ref to `bool` type
    made_change: bool;
end

def _tt_make_type tyk, name, size, type_ids, types, names in
    var type_idx = types.length;
    var t = make_type(tyk, type_idx);
    type_set_size(t, size);
    map_set(type_ids, name, type_idx);
    types.push(t);
    names.push(name);
    return t;
end

def _tt_make_ref_type type, name, type_ids, types, names in
    assert(not type_ref_to_this(type));
    var type_idx = types.length;
    var t = make_type_reference(type_idx, type);
    type_set_size(t, PTR_BITS);
    type_set_ref_to_this(type, t);
    if name then
        map_set(type_ids, name, type_idx);
    end
    types.push(t);
    names.push(name);
    return t;
end

def _tt_make_type_alias type, name, type_ids, types, names in
    map_set(type_ids, name, types.length);
    types.push(type);
    names.push(name);
end

def make_type_table -> TypeTable& in
    var self: TypeTable& = calloc(1, __sizeof(TypeTable));
    var types = Vector[type]::new(0);
    var names = Vector[cstr]::new(0);
    self.type_scope = make_type_scope(NULL);
    var type_ids = self.type_scope.types;
    self.top_type_scope = type_ids;
    self.all_types = types;
    self.names = names;
    self.ast_types = make_map(0, NULL, NULL);
    self.type_substitutes = NULL;

    var void_t = _tt_make_type(TyK_void, "void", 0, type_ids, types, names);
    self.void_type = void_t;

    var any_t = _tt_make_type(TyK_any, "any", 0, type_ids, types, names);
    self.any_type = any_t;

    var bool_t = _tt_make_type(TyK_int_like, "bool", BOOL_BITS, type_ids, types, names);
    self.bool_type = bool_t;

    var int_t = _tt_make_type(TyK_int_like, "int", INT_BITS, type_ids, types, names);
    self.int_type = int_t;

    var char_t = _tt_make_type(TyK_int_like, "char", CHAR_BITS, type_ids, types, names);
    self.char_type = char_t;

    var ptr_t = _tt_make_ref_type(void_t, "ptr", type_ids, types, names);
    self.ptr_type = ptr_t;

    var cstr_t = _tt_make_ref_type(char_t, "cstr", type_ids, types, names);
    self.cstr_type = cstr_t;

    _tt_make_type_alias(char_t, "int8", type_ids, types, names);
    _tt_make_type_alias(int_t, "int64", type_ids, types, names);

    _tt_make_type(TyK_int_like, "int16", 16, type_ids, types, names);
    _tt_make_type(TyK_int_like, "int32", 32, type_ids, types, names);

    return self;
end

def tt_any_type self: TypeTable& in return self.any_type; end
def tt_void_type self: TypeTable& in return self.void_type; end
def tt_int_type self: TypeTable& in return self.int_type; end
def tt_ptr_type self: TypeTable& in return self.ptr_type; end
def tt_cstr_type self: TypeTable& in return self.cstr_type; end
def tt_bool_type self: TypeTable& in return self.bool_type; end
def tt_char_type self: TypeTable& in return self.char_type; end

def tt_push_scope self in
    self.type_scope = make_type_scope(self.type_scope);
end

def tt_pop_scope self in
    assert(self.type_scope.parent);
    // don't free the map because places that push a type scope will hold onto that reference.
    self.type_scope = self.type_scope.parent;
end

def tt_cur_scope self -> map in
    return self.type_scope.types;
end

def tt_top_scope self -> map in
    return self.top_type_scope;
end

def tt_get_ast_type self, ast -> type in
    var found = map_find(self.ast_types, ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def tt_set_ast_type self, ast, type in
    var found = map_find(self.ast_types, ast);
    if not found then
        map_set(self.ast_types, ast, type);
        self.made_change = true;
    else
        var old_type = map_pair_val(found);
        if type != self.any_type and type != old_type then
            map_set(self.ast_types, ast, type);
            self.made_change = true;
        end
    end
end

def tt_get_type_name self, type -> cstr in
    while type_is_reference(type) and type_deref_type(type) do
        type = type_deref_type(type);
    end
    return self.names.get(type_id(type));
end

def tt_dump_cur_scope self in
    var types = tt_cur_scope(self);
    var cur = map_begin(types);
    while cur != map_end(types) do
        var key = map_pair_key(cur);
        var val = map_pair_val(cur);
        printf("key = %s, val = %d\n", key, val);
        cur = map_next(types, cur);
    end
end

def tt_get_type_or_null self, name -> type in
    var cur = self.type_scope;
    while cur do
        var found = map_find(cur.types, name);
        if found then
            return self.all_types.get(cast(map_pair_val(found), int));
        end
        cur = cur.parent;
    end
    return NULL;
end

def tt_get_type_or_make_undefined self, name -> type in
    var type = tt_get_type_or_null(self, name);
    if type then
        return type;
    end

    var type_idx = self.all_types.length;
    type = make_type_undefined(type_idx);

    // FIXME: We want to remove the need for forward declarations and to allow types which
    // haven't been defined yet to be referenced. In most scenarios this is probably fine
    // to make the type in the top scope but consider this code:
    // Fig 1.
    // struct Foo in
    //     bar: Bar&;
    //     struct Bar in
    //         ...
    //     end
    // end
    //
    // When parsing this code we parse the type of the `bar` field but no `Bar` type has
    // been defined yet, where do we define Bar? If we define it locally, which would be
    // correct, then we lose the ability to reference types that haven't been created yet
    // another example:
    // Fig 2.
    // struct Foo in
    //    bar: Bar&;
    // end
    // struct Bar in
    //    ...
    // end
    //
    // If we define Bar locally to Foo then this would result in an error because the
    // Bar local to Foo hasn't been defined yet. How do we fix this?
    // The current solution is to "catch" the local 'Bar' type in Fig 2 as being undefined
    // and overwrite the type "act" as the outer 'Bar' type
    map_set(tt_cur_scope(self), name, type_idx);
    self.all_types.push(type);
    self.names.push(name);
    return type;
end

def tt_reference_to_type self, type -> type in
    var ref = type_ref_to_this(type);
    if not ref then
        ref = _tt_make_ref_type(type, NULL, NULL, self.all_types, self.names);
        type_set_ref_to_this(type, ref);
    end
    return ref;
end

def tt_set_local_type self, type in
    var name = tt_get_type_name(self, type);
    if name then
        map_set(tt_cur_scope(self), name, type_id(type));
    end
end

def tt_substitute_type self, type -> type in
    if not type then
        return NULL;
    end
    if not self.type_substitutes then
        return type;
    end
    var deref_type = type;
    var is_ref_type = false;
    if type_is_reference(deref_type) then
        is_ref_type = true;
        deref_type = type_deref_type(type);
        assert(deref_type);
        assert(not type_is_reference(deref_type), "TODO: support substituting multiple dereferences\n");
    end

    var found = map_find(self.type_substitutes, deref_type);
    if found then
        type = map_pair_val(found);
        if is_ref_type then
            type = tt_reference_to_type(self, type);
        end
        return type;
    end

    var params = type_params(deref_type);
    if params and params.length > 0 then
        var i = 0; var len = params.length;
        var new_params = Vector[type]::new(len);
        var made_subst = false;
        while i < len do
            var orig = params.get(i);
            var subst = tt_substitute_type(self, orig);
            if subst != orig then
                made_subst = true;
            end
            new_params.push(subst);
            i += 1;
        end
        if made_subst then
            type = tt_get_type_instance_of(self, g_SymbolTable, deref_type, new_params);
            if is_ref_type then
                type = tt_reference_to_type(self, type);
            end
            return type;
        else
            new_params.delete();
        end
    end
    return type;
end

def _tt_copy_ast_replacing_types self, st, ast, src_params, dst_params, type, instance in
    // TODO: will also need a way of flagging all of the src_types as ignored when calculating below
    tt_push_scope(self);
    var type_sub_map = make_map(src_params.length, NULL, NULL);
    var i = 0; var len = src_params.length;
    while i < len do
        var src = src_params.get(i);
        map_set(type_sub_map, src, dst_params.get(i));
        tt_set_local_type(self, src);
        i += 1;
    end
    map_set(type_sub_map, type, instance);
    var prev = self.type_substitutes;
    self.type_substitutes = type_sub_map;
    var ast_copy = _ast_deep_copy(ast, self, st);
    self.type_substitutes = prev;
    free_map(type_sub_map);
    tt_pop_scope(self);
    return ast_copy;
end

def _tt_instantiate_generic_type_impl self, st, type, params, instance_type in
    assert(type_params(type));
    assert(params);
    assert(type_params(type).length == params.length, "forgot to verify type_params lengths match\n");
    assert(type_ast(type), "forgot to set type ast\n");
    var instance_ast = _tt_copy_ast_replacing_types(self, st, type_ast(type), type_params(type), params, type, instance_type);
end

def tt_get_type_instance_of self, st, type, params in
    if type_is_undefined(type) then
        // need to register for later instantiation.
        assert(type_is_generic(type));
        var generic_params = type_params(type);
        assert(params.length == generic_params.length, "forgot to verify params length\n");
        var same = true;
        var i = 0; var len = params.length;
        while i < len do
            var src_type = generic_params.get(i);
            var dst_type = params.get(i);
            if not types_eq(src_type, dst_type) then
                same = false;
                break;
            end
            i += 1;
        end
        if same then
            return type;
        end
        assert(false, "not implemented: need to register type instance for later instantiation\n");
    else
        var instances = type_instances(type);
        if not instances then
            instances = Vector[type]::new(8);
            type_set_instances(type, instances);
        else
            var i = 0; var len = instances.length;
            while i < len do
                var inst = instances.get(i);
                var inst_params = type_params(inst);
                assert(params.length == inst_params.length, "forgot to verify params.length\n");
                var j = 0; var jlen = inst_params.length;
                while j < jlen do
                    if types_eq(params.get(j), inst_params.get(j)) then
                        return inst;
                    end
                    j += 1;
                end
                i += 1;
            end
        end

        var id = self.all_types.length;
        var instance_type = copy_type_with_id(type, id);
        self.all_types.push(instance_type);
        var type_name = tt_get_type_name(self, type);
        self.names.push(type_name);
        type_set_is_generic(instance_type, false);
        type_set_params(instance_type, params); // used for looking up existing instances.
        type_set_ref_to_this(instance_type, NULL); // clear the old ref type
        var ref_type = tt_reference_to_type(self, instance_type);
        instances.push(instance_type);
        _tt_instantiate_generic_type_impl(self, st, type, params, instance_type);
        return instance_type;
    end
end

def tt_make_anon_def self, return_type, param_types, varargs in
    var type = make_type_def(self.all_types.length, return_type, param_types, varargs);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def tt_make_anon_struct self, fields, defs in
    var type = make_type_struct(self.all_types.length, fields, defs);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def tt_make_anon_union self, field_names, field_types in
    var type = make_type_union(self.all_types.length, field_names, field_types);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def _tt_append_def_type_repr self, string, type in
    if not type then
        string_append_cstr(string, "{null}");
    elif type_is_def(type) then
        var name = tt_get_def_type_name(self, type);
        string_append_string(string, name);
        free_string(name);
    else
        var refs = 0;
        var deref_type = type;
        while type_is_reference(deref_type) do
            refs += 1;
            deref_type = type_deref_type(deref_type);
        end

        var name = tt_get_type_name(self, deref_type);
        if name then
            string_append_cstr(string, name);
        else
            string_append_cstr(string, "<type id ");
            string_append_int(string, type_id(deref_type));
            string_push(string, '>');
        end

        var params = type_params(deref_type);
        if params and params.length > 0 then
            string_push(string, '[');
            var i = 0; var len = params.length;
            while i < len do
                _tt_append_def_type_repr(self, string, params.get(i));
                i += 1;
                if i < len then
                    string_append_cstr(string, ", ");
                end
            end
            string_push(string, ']');
        end
        while refs > 0 do
            string_push(string, '&');
            refs -= 1;
        end
    end
end

def tt_get_def_type_name self, type in
    if not type_is_def(type) then
        return NULL;
    end

    var string = make_string(20);
    string_push(string, '(');
    var params = type_def_parameters(type);
    var ret_ty = type_def_return_type(type);

    var i = 0; var len = params.length;
    while i < len do
        var param_type = params.get(i);
        _tt_append_def_type_repr(self, string, param_type);
        i += 1;
        if i < len then
            string_append_cstr(string, ", ");
        end
    end
    if i == 0 then
        string_append_cstr(string, "void");
    end

    string_append_cstr(string, " -> ");
    _tt_append_def_type_repr(self, string, ret_ty);
    string_push(string, ')');
    return string;
end

def tt_calculate_struct self, stype, again_q in
    if type_size(stype) != TYPE_NEEDS_SIZING then
        return;
    end
    var fields = type_struct_fields(stype);
    var bit_offs = 0;
    var i = 0; var len = fields.length;
    var ptr_align = false;
    while i < len do
        var field = fields.get(i);
        var fname = field.name;
        var ftype = field.type;
        if type_is_generic_param(ftype) then
            // FIXME: this shouldn't happen but it does...
            type_set_is_generic(stype, true);
            return;
        end

        if type_is_reference(ftype) and not ptr_align then
            ptr_align = true;
        end

        var size = type_size(ftype);
        if size == TYPE_NEEDS_SIZING then
            queue_enqueue(again_q, stype);
            return;
        end
        if not type_is_struct(ftype) then
            bit_offs = (bit_offs + (size - 1)) & -size; // align to nearest boundary
        end
        field.bit_offset = bit_offs;
        bit_offs += size;
        i += 1;
    end
    if ptr_align then
        bit_offs = (bit_offs + (PTR_BITS-1)) & -PTR_BITS;
    end
    type_set_size(stype, bit_offs);
end

def tt_detect_cycles self, stype in
    // Breadth-first search for cycles.
    var q = make_queue(0);
    var explored = make_set(0, NULL, NULL);

    set_add(explored, stype);
    var fields = type_struct_fields(stype);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var ftype = field.type;
        if ftype == stype then // immediate self-reference
            return true;
        end
        if type_is_struct(ftype) and not set_contains(explored, ftype) then
            set_add(explored, ftype);
            queue_enqueue(q, ftype);
        end
        i += 1;
    end

    while queue_len(q) != 0 do
        var v = queue_dequeue(q);
        if v == stype then
            return true;
        end
        fields = type_struct_fields(v);
        i = 0; len = fields.length;
        while i < len do
            var field = fields.get(i);
            var ftype = field.type;
            if ftype == stype then
                return true;
            end
            if type_is_struct(ftype) and not set_contains(explored, ftype) then
                set_add(explored, ftype);
                queue_enqueue(q, ftype);
            end
            i += 1;
        end
    end
    free_queue(q);
    free_set(explored);
    return false;
end

def tt_check_struct_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var fname = field.name;
        var ftoke = field.token;
        var found = map_find(member_name_map, fname);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", fname);
            print_token_loc(ftoke);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, fname, ftoke);
        i += 1;
    end

    var defs = type_struct_defs(type);
    i = 0; len = defs.length;
    while i < len do
        var def_ = defs.get(i);
        var found = map_find(member_name_map, def_.name);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", def_.name);
            print_token_loc(def_.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, def_.name, def_.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_check_enum_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var enum_vals = type_enum_values(type);
    var i = 0; var len = enum_vals.length;
    while i < len do
        var ev = enum_vals.get(i);
        var found = map_find(member_name_map, ev.name);
        if found then
            printf("ERROR: enum `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", ev.name);
            print_token_loc(ev.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, ev.name, ev.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_calculate_structs self in
    assert(self.type_scope.parent == NULL, "Compiler bug: calculating stucts but not at top scope\n");
    var to_calc = make_queue(0);
    var i = 0; var len = self.all_types.length;
    var void = tt_void_type(self);
    while i < len do
        var type = self.all_types.get(i);
        if type_is_generic(type) or type_is_generic_param(type) then
            // skip generics because they aren't concrete types and their concrete instances
            // should also be in this list.
            i += 1;
            continue;
        elif type_is_undefined(type) then
            var name = tt_get_type_name(self, type);
            if name then
                // HACK this is a bit of a hack to allow the FIXME in tt_get_type_or_make_undefined to work.
                var outer = tt_get_type_or_null(self, name);
                if outer and not type_is_undefined(outer) then
                    memcpy(type, outer, sizeof_TTYPE);
                    continue;
                end
            end
            printf("WARN: type `%s` is still undefined!\n", tt_get_type_name(self, type));
            type_set_size(type, PTR_BITS);
            type_set_kind(type, TyK_reference);
            type_set_deref_type(type, void);
        elif type_is_struct(type) and type_size(type) == TYPE_NEEDS_SIZING then
            queue_enqueue(to_calc, type);
        end
        if type_is_struct(type) then
            tt_check_struct_for_field_name_collisions(self, type);
        elif type_is_enum(type) then
            tt_check_enum_for_field_name_collisions(self, type);
        end
        i += 1;
    end

    while queue_len(to_calc) != 0 do
        var type = queue_dequeue(to_calc);
        if tt_detect_cycles(self, type) then
            printf("ERROR: Detected cycles in struct `%s`\n", tt_get_type_name(self, type));
            exit(1);
        end
        tt_calculate_struct(self, type, to_calc);
    end
    free_queue(to_calc);
end

def tt_instantiate_types self in
end

def tt_print_type_name self, type in
    if type then
        var name = make_string(32);
        _tt_append_def_type_repr(self, name, type);
        printf("%s", string_cstr(name));
        free_string(name);
    else
        printf("{null}");
    end
end

def scope_resolve_type tt: TypeTable&, ast: ast, error: bool -> type in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = defs.get(i);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_type;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_type)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return tt_any_type(tt);
    elif type_is_enum(type) then
        return type;
    elif type_is_union(type) then
        assert(false, "scope resolve for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return tt_any_type(tt);
end

def scope_resolve_def tt: TypeTable&, ast: ast, error: bool -> Symbol& in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = defs.get(i);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_def)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return NULL;
    elif type_is_enum(type) then
        return NULL;
    elif type_is_union(type) then
        assert(false, "scope_resolve_def for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return NULL;
end
