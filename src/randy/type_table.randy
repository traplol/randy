
struct Field in
    type: type;
    name: cstr;
    bit_offset: int;
    token: Token&;
end

def make_field type, name, bit_offset, token -> Field& in
    var self: Field& = malloc(__sizeof(Field));
    self.type = type;
    self.name = name;
    self.bit_offset = bit_offset;
    self.token = token;
    return self;
end

struct EnumValue in
    token: Token&;
    name: cstr;
    value: ast;
    cache_value: ptr;
end

def make_enum_value token: Token&, name: cstr, value: ast -> EnumValue& in
    var self = cast(malloc(__sizeof(EnumValue)), EnumValue&);
    self.token = token;
    self.name = name;
    self.value = value;
    self.cache_value = NULL;
    return self;
end

const TyK_undefined = 0;
const TyK_void      = 1;
const TyK_any       = 2;
const TyK_int_like  = 3;
const TyK_reference = 4;
const TyK_def       = 5;
const TyK_struct    = 6;
const TyK_enum      = 7;
const TyK_union     = 8; // NYI

const TTYPE_id          = 0;  // int
const TTYPE_kind        = 8;  // TyK
const TTYPE_is_generic  = 9;  // bool
const TTYPE_size        = 12; // uint32
const TTYPE_params      = 16; // type Vector&
const TTYPE_ast         = 24; // ast
const TTYPE_ref_to_this = 32; // type
const TTYPE_instances = 40; // type Vector& : generic instances of this type
// reference
const TTYPE_deref_type  = 48; // type
// def
const TTYPE_def_return_type = 48; // type
const TTYPE_def_parameters  = 56; // symbol Vector&
const TTYPE_def_varargs     = 64; // bool
// struct
const TTYPE_struct_fields = 48; // Field& Vector&
const TTYPE_struct_defs   = 56; // def_symbol Vector&
// enum
const TTYPE_enum_values = 48; // EnumValue& Vector&
// union
const TTYPE_union_names = 48; // cstr Vector&
const TTYPE_union_types = 56; // type Vector&

const sizeof_TTYPE = 72;
const TYPE_NEEDS_SIZING = (1<<32)-1;

def make_type kind: int, id: int -> type in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_id, id);
    u8!(self + TTYPE_kind, kind);
    u8!(self + TTYPE_is_generic, false);
    u32!(self + TTYPE_size, TYPE_NEEDS_SIZING);
    return cast(self, type);
end

def make_type_undefined id: int in
    return make_type(TyK_undefined, id);
end

def make_type_reference id: int, type: type in
    var self = make_type(TyK_reference, id);
    u64!(self + TTYPE_deref_type, type);
    return self;
end

def make_type_def id: int, return_type: type, param_types: Vector&, varargs: bool in
    var self = make_type(TyK_def, id);
    u64!(self + TTYPE_def_return_type, return_type);
    u64!(self + TTYPE_def_parameters, param_types);
    u8!(self + TTYPE_def_varargs, varargs);
    return self;
end

def make_type_struct id: int, fields: Vector&, defs: Vector& in
    var self = make_type(TyK_struct, id);
    u64!(self + TTYPE_struct_fields, fields);
    u64!(self + TTYPE_struct_defs, defs);
    return self;
end

def make_type_enum id: int, enum_values: Vector& in
    var self = make_type(TyK_enum, id);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

def make_type_union id: int, union_names: Vector&, union_types: Vector& in
    var self = make_type(TyK_union, id);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

def copy_type_with_id type: type, id: int in
    var copy = cast(malloc(sizeof_TTYPE), type);
    memcpy(copy, type, sizeof_TTYPE);
    u64!(copy + TTYPE_id, id);
    return copy;
end

def type_kind self: type in return cast(u8@(self + TTYPE_kind), int); end
def type_is_generic self: type in return cast(u8@(self + TTYPE_is_generic), bool); end
def type_size self: type in return cast(u32@(self + TTYPE_size), int); end
def type_id self: type in return cast(u64@(self + TTYPE_id), int); end
def type_params self: type in return cast(u64@(self + TTYPE_params), Vector&); end
def type_ast self: type in return cast(u64@(self + TTYPE_ast), ast); end
def type_deref_type self: type in return cast(u64@(self + TTYPE_deref_type), type); end
def type_ref_to_this self: type in return cast(u64@(self + TTYPE_ref_to_this), type); end
def type_def_return_type self: type in
    return cast(u64@(self + TTYPE_def_return_type), type);
end
def type_def_parameters self: type in
    return cast(u64@(self + TTYPE_def_parameters), Vector&);
end
def type_def_varargs self: type in
    return cast(u8@(self + TTYPE_def_varargs), bool);
end
def type_struct_fields self: type in
    return cast(u64@(self + TTYPE_struct_fields), Vector&);
end
def type_struct_defs self: type in
    return cast(u64@(self + TTYPE_struct_defs), Vector&);
end
def type_enum_values self: type in return cast(u64@(self + TTYPE_enum_values), Vector&); end
def type_union_names self: type in return cast(u64@(self + TTYPE_union_names), Vector&); end
def type_union_types self: type in return cast(u64@(self + TTYPE_union_types), Vector&); end

def type_set_kind self: type, kind: int in u8!(self + TTYPE_kind, kind); end
def type_set_is_generic self: type, val: bool in u8!(self + TTYPE_is_generic, val); end
def type_set_size self: type, size: int in u32!(self + TTYPE_size, size); end
def type_set_params self: type, params: Vector& in u64!(self + TTYPE_params, params); end
def type_set_ast self: type, ast: ast in u64!(self + TTYPE_ast, ast); end
def type_set_deref_type self: type, type: type in u64!(self + TTYPE_deref_type, type); end
def type_set_ref_to_this self: type, type: type in u64!(self + TTYPE_ref_to_this, type); end
def type_set_def_return_type self: type, type: type in
    u64!(self + TTYPE_def_return_type, type);
end
def type_set_def_parameters self: type, params: Vector& in
    u64!(self + TTYPE_def_parameters, params);
end
def type_set_def_varargs self: type, varargs: bool in
    u8!(self + TTYPE_def_varargs, varargs);
end
def type_set_struct_fields self: type, fields: Vector& in u64!(self + TTYPE_struct_fields, fields); end
def type_set_struct_defs self: type, defs: Vector& in u64!(self + TTYPE_struct_defs, defs); end
def type_set_enum_values self: type, values: Vector& in u64!(self + TTYPE_enum_values, values); end
def type_set_union_names self: type, names: Vector& in u64!(self + TTYPE_union_names, names); end
def type_set_union_types self: type, types: Vector& in u64!(self + TTYPE_union_types, types); end

def type_is_undefined self: type in return type_kind(self) == TyK_undefined; end
def type_is_void self: type in return type_kind(self) == TyK_void; end
def type_is_any self: type in return type_kind(self) == TyK_any; end
def type_is_int_like self: type in return type_kind(self) == TyK_int_like; end
def type_is_reference self: type in return type_kind(self) == TyK_reference; end
def type_is_struct self: type in return type_kind(self) == TyK_struct; end
def type_is_def self: type in return type_kind(self) == TyK_def; end
def type_is_enum self: type in return type_kind(self) == TyK_enum; end
def type_is_union self: type in return type_kind(self) == TyK_union; end

def type_is_scalar self: type in
    if type_is_int_like(self) then
        return true;
    elif type_is_reference(self) then
        return true;
    elif type_is_def(self) then
        return true;
    end
    return false;
end

def types_eq a: type, b: type in
    if a == b then
        return true;
    end
    if type_id(a) == type_id(b) then
        return true;
    end
    if type_is_reference(a) and type_is_reference(b) then
        return types_eq(type_deref_type(a), type_deref_type(b));
    end
    if type_is_def(a) and type_is_def(b) then
        var a_ret = type_def_return_type(a);
        var b_ret = type_def_return_type(b);
        if not types_eq(a_ret, b_ret) then
            return false;
        end
        var a_params = type_def_parameters(a);
        var b_params = type_def_parameters(b);
        if a_params.length != b_params.length then
            return false;
        end
        var i = 0; var len = a_params.length;
        while i < len do
            var ap = vector_get(a_params, i);
            var bp = vector_get(b_params, i);
            if not types_eq(ap, bp) then
                return false;
            end
            i += 1;
        end
        return true;
    end
    return false;
end

def _basic_def_type_match tt, lhs, rhs in
    if type_def_varargs(lhs) != type_def_varargs(rhs) then
        return false;
    elif not types_assignable(tt, type_def_return_type(lhs), type_def_return_type(rhs)) then
        return false;
    end
    var lhs_params = type_def_parameters(lhs);
    var rhs_params = type_def_parameters(rhs);
    if lhs_params.length != rhs_params.length then
        return false;
    end

    var i = 0; var len = lhs_params.length;
    while i < len do
        var a = vector_get(lhs_params, i);
        var b = vector_get(rhs_params, i);
        if not types_assignable(tt, a, b) then
            return false;
        end
        i += 1;
    end
    return true;
end

def types_assignable tt: TypeTable&, lhs: type, rhs: type in
    if types_eq(lhs, rhs) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    var char = tt_char_type(tt);
    var int = tt_int_type(tt);
    var bool = tt_bool_type(tt);
    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        // ensure the rhs can fit into the lhs.
        if type_size(lhs) >= type_size(rhs) then
            return true;
        end
    end

    if lhs == ptr and rhs == cstr then
        return true;
    elif lhs == cstr and rhs == ptr then // TODO FIXME: cstr should not accept ptr
        return true;
    elif lhs == ptr and type_is_int_like(rhs) then // TODO FIXME: ptr should not accept int-like
        return true;
    elif lhs == ptr and type_is_reference(rhs) then
        return true;
    elif type_is_reference(lhs) and rhs == ptr then // TODO FIXME: ref should not accept ptr
        return true;
    elif type_is_def(lhs) and type_is_def(rhs) then
        return _basic_def_type_match(tt, lhs, rhs);
    elif lhs == ptr and type_is_def(rhs) then
        return true;
    elif type_is_def(lhs) and rhs == ptr then // TODO FIXME: function should not accept ptr
        return true;
    // TODO FIXME: this is a hack so int literals, which are `int`s can be assigned to chars.
    elif lhs == char and type_is_int_like(rhs) then
        return true;
    elif lhs == bool and type_is_scalar(rhs) then
        return true;
    end
    return false;
end

struct TypeTable in
    type_scope: Vector&; // (cstr, int) map Vector& : stack of name -> type_id
    all_types: Vector&;  // type Vector& : all types; type_id is index into this Vector&
    names: Vector&;  // cstr Vector& : type_id is index into this Vector&, may have NULLs
    ast_types: map;  // (ast, type) map : ast -> type
    void_type: type; // fast ref to `void` type
    any_type: type;  // fast ref to `any` type
    int_type: type;  // fast ref to `int` type
    char_type: type; // fast ref to `char` type
    ptr_type: type;  // fast ref to `ptr` type
    cstr_type: type; // fast ref to `cstr` type
    bool_type: type; // fast ref to `bool` type
end

def _tt_make_type tyk, name, size, type_ids, types, names in
    var type_idx = types.length;
    var t = make_type(tyk, type_idx);
    type_set_size(t, size);
    map_set(type_ids, name, type_idx);
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

def _tt_make_ref_type type, name, type_ids, types, names in
    assert(not type_ref_to_this(type));
    var type_idx = types.length;
    var t = make_type_reference(type_idx, type);
    type_set_size(t, PTR_BITS);
    type_set_ref_to_this(type, t);
    if name then
        map_set(type_ids, name, type_idx);
    end
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

def _tt_make_type_alias type, name, type_ids, types, names in
    map_set(type_ids, name, types.length);
    vector_push(types, type);
    vector_push(names, name);
end

def make_type_table -> TypeTable& in
    var self: TypeTable& = malloc(__sizeof(TypeTable));
    var type_ids = make_map(0, cstr_eq, cstr_hash);
    var types = make_vector(0);
    var names = make_vector(0);
    self.type_scope = make_vector(8);
    vector_push(self.type_scope, type_ids);
    self.all_types = types;
    self.names = names;
    self.ast_types = make_map(0, NULL, NULL);

    var void_t = _tt_make_type(TyK_void, "void", 0, type_ids, types, names);
    self.void_type = void_t;

    var any_t = _tt_make_type(TyK_any, "any", 0, type_ids, types, names);
    self.any_type = any_t;

    var bool_t = _tt_make_type(TyK_int_like, "bool", BOOL_BITS, type_ids, types, names);
    self.bool_type = bool_t;

    var int_t = _tt_make_type(TyK_int_like, "int", INT_BITS, type_ids, types, names);
    self.int_type = int_t;

    var char_t = _tt_make_type(TyK_int_like, "char", CHAR_BITS, type_ids, types, names);
    self.char_type = char_t;

    var ptr_t = _tt_make_ref_type(void_t, "ptr", type_ids, types, names);
    self.ptr_type = ptr_t;

    var cstr_t = _tt_make_ref_type(char_t, "cstr", type_ids, types, names);
    self.cstr_type = cstr_t;

    _tt_make_type_alias(char_t, "int8", type_ids, types, names);
    _tt_make_type_alias(int_t, "int64", type_ids, types, names);

    _tt_make_type(TyK_int_like, "int16", 16, type_ids, types, names);
    _tt_make_type(TyK_int_like, "int32", 32, type_ids, types, names);

    return self;
end

def tt_any_type self: TypeTable& in return self.any_type; end
def tt_void_type self: TypeTable& in return self.void_type; end
def tt_int_type self: TypeTable& in return self.int_type; end
def tt_ptr_type self: TypeTable& in return self.ptr_type; end
def tt_cstr_type self: TypeTable& in return self.cstr_type; end
def tt_bool_type self: TypeTable& in return self.bool_type; end
def tt_char_type self: TypeTable& in return self.char_type; end

def tt_push_scope self in
    vector_push(self.type_scope, make_map(0, cstr_eq, cstr_hash));
end

def tt_pop_scope self in
    assert(self.type_scope.length >= 1);
    var map = cast(vector_back(self.type_scope), map);
    vector_pop(self.type_scope);
    free_map(map);
end

def tt_cur_scope self -> map in
    return cast(vector_back(self.type_scope), map);
end

def tt_top_scope self -> map in
    return cast(vector_front(self.type_scope), map);
end

def tt_get_ast_type self, ast -> type in
    var found = map_find(self.ast_types, ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def tt_set_ast_type self, ast, type in
    map_set(self.ast_types, ast, type);
end

def tt_get_type_name self, type -> cstr in
    while type_is_reference(type) and type_deref_type(type) do
        type = type_deref_type(type);
    end
    return vector_get(self.names, type_id(type));
end

def tt_get_type_or_null self, name -> type in
    var i = self.type_scope.length - 1;
    while i >= 0 do
        var found = map_find(vector_get(self.type_scope, i), name);
        if found then
            return vector_get(self.all_types, cast(map_pair_val(found), int));
        end
        i -= 1;
    end
    return NULL;
end

def tt_get_type_or_make_undefined self, name -> type in
    var type = tt_get_type_or_null(self, name);
    if type then
        return type;
    end

    var type_idx = self.all_types.length;
    type = make_type_undefined(type_idx);

    // FIXME: We want to remove the need for forward declarations and to allow types which
    // haven't been defined yet to be referenced. In most scenarios this is probably fine
    // to make the type in the top scope but consider this code:
    // Fig 1.
    // struct Foo in
    //     bar: Bar&;
    //     struct Bar in
    //         ...
    //     end
    // end
    //
    // When parsing this code we parse the type of the `bar` field but no `Bar` type has
    // been defined yet, where do we define Bar? If we define it locally, which would be
    // correct, then we lose the ability to reference types that haven't been created yet
    // another example:
    // Fig 2.
    // struct Foo in
    //    bar: Bar&;
    // end
    // struct Bar in
    //    ...
    // end
    //
    // If we define Bar locally to Foo then this would result in an error because the
    // Bar local to Foo hasn't been defined yet. How do we fix this?
    // The current solution is to "catch" the local 'Bar' type in Fig 2 as being undefined
    // and overwrite the type "act" as the outer 'Bar' type

    map_set(tt_cur_scope(self), name, type_idx);
    vector_push(self.all_types, type);
    vector_push(self.names, name);
    return type;
end

def tt_get_reference_to_type self, type -> type in
    var ref = type_ref_to_this(type);
    if not ref then
        ref = _tt_make_ref_type(type, NULL,
                    tt_cur_scope(self),
                    self.all_types,
                    self.names);
    end
    return ref;
end

def tt_set_local_type self, type in
    var name = tt_get_type_name(self, type);
    if name then
        map_set(tt_cur_scope(self), name, type_id(type));
    end
end

def _tt_copy_ast_replacing_types self, ast, src_params, dst_params in
    // TODO: will also need a way of flagging all of the src_types as ignored when calculating below
    print_ast(ast);
    var i = 0; var len = src_params.length;
    while i < len do
        printf("src type: ");
        tt_print_type_name(self, vector_get(src_params, i));
        printf(" -> dst type: ");
        tt_print_type_name(self, vector_get(dst_params, i));
        printf("\n");
        i += 1;
    end
    assert(false, "nyi\n");
    return cast(NULL, ast);
end

def _tt_instantiate_generic_type_impl self, type, params in
    assert(type_is_generic(type), "forgot to verify type is generic before creating type instance\n");
    assert(type_params(type));
    assert(params);
    assert(type_params(type).length == params.length, "forgot to verify type_params lengths match\n");
    assert(type_ast(type), "forgot to set type ast\n");
    var id = self.all_types.length;
    var type_name = tt_get_type_name(self, type);
    var instance_ast = _tt_copy_ast_replacing_types(self, type_ast(type), type_params(type), params);
    var instance_type = copy_type_with_id(type, id);
    vector_push(self.all_types, instance_type);
    vector_push(self.names, type_name);
    type_set_is_generic(instance_type, false);
    type_set_params(instance_type, params); // used for pretty printing type params
    var ref_type = tt_get_reference_to_type(self, instance_type);
    type_set_ref_to_this(instance_type, ref_type);
    type_set_ast(instance_type, instance_ast);
    return instance_type;
end

def tt_create_type_instance_of self, type, params in
    if type_is_undefined(type) then
        // need to register for later instantiation.
        assert(false, "not implemented: need to register type instance for later instantiation\n");
    else
        return _tt_instantiate_generic_type_impl(self, type, params);
    end
end

def tt_make_anon_def self, return_type, param_types, varargs in
    var type = make_type_def(self.all_types.length, return_type, param_types, varargs);
    vector_push(self.all_types, type);
    vector_push(self.names, NULL);
    return type;
end

def tt_make_anon_struct self, fields, defs in
    var type = make_type_struct(self.all_types.length, fields, defs);
    vector_push(self.all_types, type);
    vector_push(self.names, NULL);
    return type;
end

def tt_make_anon_union self, field_names, field_types in
    var type = make_type_union(self.all_types.length, field_names, field_types);
    vector_push(self.all_types, type);
    vector_push(self.names, NULL);
    return type;
end

def _tt_append_def_type_repr self, string, type in
    if not type then
        string_append_cstr(string, "{null}");
    elif type_is_def(type) then
        var ptn = tt_get_def_type_name(self, type);
        string_append_string(string, ptn);
        free_string(ptn);
    else
        var tn = tt_get_type_name(self, type);
        if tn then
            string_append_cstr(string, tn);
        else
            string_append_cstr(string, "{no type}");
        end
    end
end

def tt_get_def_type_name self, type in
    if not type_is_def(type) then
        return NULL;
    end

    var string = make_string(20);
    string_push(string, '(');
    var params = type_def_parameters(type);
    var ret_ty = type_def_return_type(type);

    var i = 0; var len = params.length;
    while i < len do
        var param_type = vector_get(params, i);
        _tt_append_def_type_repr(self, string, param_type);
        i += 1;
        if i < len then
            string_append_cstr(string, ", ");
        end
    end
    if i == 0 then
        string_append_cstr(string, "void");
    end

    string_append_cstr(string, " -> ");
    _tt_append_def_type_repr(self, string, ret_ty);
    string_push(string, ')');
    return string;
end

def tt_calculate_struct self, stype, again_q in
    if type_size(stype) != TYPE_NEEDS_SIZING then
        return;
    end
    var fields = type_struct_fields(stype);
    var bit_offs = 0;
    var i = 0; var len = fields.length;
    var ptr_align = false;
    while i < len do
        var field = cast(vector_get(fields, i), Field&);
        var fname = field.name;
        var ftype = field.type;

        if type_is_reference(ftype) and not ptr_align then
            ptr_align = true;
        end

        var size = type_size(ftype);
        if size == TYPE_NEEDS_SIZING then
            queue_enqueue(again_q, stype);
            return;
        end
        if not type_is_struct(ftype) then
            bit_offs = (bit_offs + (size - 1)) & -size; // align to nearest boundary
        end
        field.bit_offset = bit_offs;
        bit_offs += size;
        i += 1;
    end
    if ptr_align then
        bit_offs = (bit_offs + (PTR_BITS-1)) & -PTR_BITS;
    end
    type_set_size(stype, bit_offs);
end

def tt_detect_cycles self, stype in
    // Breadth-first search for cycles.
    var q = make_queue(0);
    var explored = make_set(0, NULL, NULL);

    set_add(explored, stype);
    var fields = type_struct_fields(stype);
    var i = 0; var len = fields.length;
    while i < len do
        var field = cast(vector_get(fields, i), Field&);
        var ftype = field.type;
        if ftype == stype then // immediate self-reference
            return true;
        end
        if type_is_struct(ftype) and not set_contains(explored, ftype) then
            set_add(explored, ftype);
            queue_enqueue(q, ftype);
        end
        i += 1;
    end

    while queue_len(q) != 0 do
        var v = queue_dequeue(q);
        if v == stype then
            return true;
        end
        fields = type_struct_fields(v);
        i = 0; len = fields.length;
        while i < len do
            var field = cast(vector_get(fields, i), Field&);
            var ftype = field.type;
            if ftype == stype then
                return true;
            end
            if type_is_struct(ftype) and not set_contains(explored, ftype) then
                set_add(explored, ftype);
                queue_enqueue(q, ftype);
            end
            i += 1;
        end
    end
    free_queue(q);
    free_set(explored);
    return false;
end

def tt_check_struct_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = cast(vector_get(fields, i), Field&);
        var fname = field.name;
        var ftoke = field.token;
        var found = map_find(member_name_map, fname);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", fname);
            print_token_loc(ftoke);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, fname, ftoke);
        i += 1;
    end

    var defs = type_struct_defs(type);
    i = 0; len = defs.length;
    while i < len do
        var def_ = cast(vector_get(defs, i), Symbol&);
        var found = map_find(member_name_map, def_.name);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", def_.name);
            print_token_loc(def_.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, def_.name, def_.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_check_enum_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var enum_vals = type_enum_values(type);
    var i = 0; var len = enum_vals.length;
    while i < len do
        var ev = cast(vector_get(enum_vals, i), EnumValue&);
        var found = map_find(member_name_map, ev.name);
        if found then
            printf("ERROR: enum `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", ev.name);
            print_token_loc(ev.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, ev.name, ev.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_calculate_structs self in
    assert(self.type_scope.length == 1, "Compiler bug: calculating stucts but not at top scope\n");
    var to_calc = make_queue(0);
    var i = 0; var len = self.all_types.length;
    var void = tt_void_type(self);
    while i < len do
        var type = vector_get(self.all_types, i);
        if type_is_generic(type) then
            // skip generics because they aren't concrete types and their concrete instances
            // should also be in this list.
            i += 1;
            continue;
        elif type_is_undefined(type) then
            var name = tt_get_type_name(self, type);
            if name then
                // HACK this is a bit of a hack to allow the FIXME in tt_get_type_or_make_undefined to work.
                var outer = tt_get_type_or_null(self, name);
                if not type_is_undefined(outer) then
                    memcpy(type, outer, sizeof_TTYPE);
                    continue;
                end
            end
            printf("WARN: type `%s` is still undefined!\n", tt_get_type_name(self, type));
            type_set_size(type, PTR_BITS);
            type_set_kind(type, TyK_reference);
            type_set_deref_type(type, void);
        elif type_is_struct(type) and type_size(type) == TYPE_NEEDS_SIZING then
            queue_enqueue(to_calc, type);
        end
        if type_is_struct(type) then
            tt_check_struct_for_field_name_collisions(self, type);
        elif type_is_enum(type) then
            tt_check_enum_for_field_name_collisions(self, type);
        end
        i += 1;
    end

    while queue_len(to_calc) != 0 do
        var type = queue_dequeue(to_calc);
        if tt_detect_cycles(self, type) then
            printf("ERROR: Detected cycles in struct `%s`\n", tt_get_type_name(self, type));
            exit(1);
        end
        tt_calculate_struct(self, type, to_calc);
    end
    free_queue(to_calc);
end

def tt_instantiate_types self in
end

def tt_print_type_name self, type in
    if type then
        if type_is_def(type) then
            var string = tt_get_def_type_name(self, type);
            printf("%s", string_cstr(string));
            free_string(string);
        else
            var name = tt_get_type_name(self, type);
            if name then
                printf("%s", name);
            else
                printf("<type id %d>", type_id(type));
            end
            var refs = 0;
            while type_is_reference(type) and type_deref_type(type) do
                type = type_deref_type(type);
                refs += 1;
            end

            var params = type_params(type);
            if params then
                printf("[");
                var i = 0; var len = params.length;
                while i < len do
                    tt_print_type_name(self, vector_get(params, i));
                    i += 1;
                    if i < len then
                        printf(", ");
                    end
                end
                printf("]");
            end

            while refs > 0 do
                printf("&");
                refs -= 1;
            end
        end
    else
        printf("{no type}");
    end
end

def scope_resolve_type tt: TypeTable&, ast: ast, error: bool -> type in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = cast(vector_get(defs, i), Symbol&);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_type;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_type)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return tt_any_type(tt);
    elif type_is_enum(type) then
        return type;
    elif type_is_union(type) then
        assert(false, "scope resolve for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return tt_any_type(tt);
end

def scope_resolve_def tt: TypeTable&, ast: ast, error: bool -> Symbol& in
    assert(ast_kind(ast) == AstK_ScopeResolve);
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet. %s\n",
        ast_kind_cstr(ast_kind(ast_rhs(ast))));
    var type = ast_type(ast_lhs(ast));
    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = cast(vector_get(defs, i), Symbol&);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_def)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return NULL;
    elif type_is_enum(type) then
        return NULL;
    elif type_is_union(type) then
        assert(false, "scope_resolve_def for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return NULL;
end
