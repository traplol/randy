
const TFIELD_type       = 0;  // type
const TFIELD_name       = 8;  // cstr
const TFIELD_bit_offset = 16; // int
const TFIELD_token      = 24; // token
const sizeof_TFIELD = 32;

proc make_field type, name, bit_offset, token -> field in
    var self = malloc(sizeof_TFIELD);
    u64!(self + TFIELD_type, type);
    u64!(self + TFIELD_name, name);
    u64!(self + TFIELD_bit_offset, bit_offset);
    u64!(self + TFIELD_token, token);
    return cast(self, field);
end

proc field_type self: field -> type in return cast(u64@(self + TFIELD_type), type); end
proc field_name self: field -> cstr in return cast(u64@(self + TFIELD_name), cstr); end
proc field_bit_offset self: field -> int in return cast(u64@(self + TFIELD_bit_offset), int); end
proc field_token self: field -> token in return cast(u64@(self + TFIELD_token), token); end

proc field_set_bit_offset self: field, bit_offset: int in
    u64!(self + TFIELD_bit_offset, bit_offset);
end

const TyK_undefined = 0;
const TyK_void      = 1;
const TyK_any       = 2;
const TyK_int_like  = 3;
const TyK_reference = 4; // NYI
const TyK_procedure = 5;
const TyK_struct    = 6; // NYI
const TyK_enum      = 7; // NYI
const TyK_union     = 8; // NYI
const TyK_array     = 9; // NYI

const TTYPE_id        = 0;  // int
const TTYPE_kind      = 8;  // TyK
const TTYPE_size      = 12; // uint32
const TTYPE_params    = 16; // type vector
const TTYPE_ast       = 24; // ast
const TTYPE_ref_to_this = 32; // type
// reference
const TTYPE_deref_type  = 40; // type
// procedure
const TTYPE_proc_return_type = 40; // type
const TTYPE_proc_parameters  = 48; // symbol vector
const TTYPE_proc_varargs     = 56; // bool
// struct
const TTYPE_struct_fields = 40; // field vector
const TTYPE_struct_procs  = 48; // proc_symbol vector
// enum
const TTYPE_enum_names  = 40; // cstr vector
const TTYPE_enum_values = 48; // int vector
// union
const TTYPE_union_names = 40; // cstr vector
const TTYPE_union_types = 48; // type vector
// array
const TTYPE_array_count = 40; // number of elems in array
const TTYPE_array_type  = 48; // type of each elem in array

const sizeof_TTYPE = 64;
const TYPE_NEEDS_SIZING = (1<<32)-1;

proc make_type kind: int, id: int -> type in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_id, id);
    u32!(self + TTYPE_kind, kind);
    u32!(self + TTYPE_size, TYPE_NEEDS_SIZING);
    return cast(self, type);
end

proc make_type_undefined id: int in
    return make_type(TyK_undefined, id);
end

proc make_type_reference id: int, type: type in
    var self = make_type(TyK_reference, id);
    u64!(self + TTYPE_deref_type, type);
    return self;
end

proc make_type_procedure id: int, return_type: type, param_types: vector, varargs: bool in
    var self = make_type(TyK_procedure, id);
    u64!(self + TTYPE_proc_return_type, return_type);
    u64!(self + TTYPE_proc_parameters, param_types);
    u8!(self + TTYPE_proc_varargs, varargs);
    return self;
end

proc make_type_struct id: int, fields: vector, procs: vector in
    var self = make_type(TyK_struct, id);
    u64!(self + TTYPE_struct_fields, fields);
    u64!(self + TTYPE_struct_procs, procs);
    return self;
end

proc make_type_enum id: int, enum_names: vector, enum_values: vector in
    var self = make_type(TyK_enum, id);
    u64!(self + TTYPE_enum_names, enum_names);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

proc make_type_union id: int, union_names: vector, union_types: vector in
    var self = make_type(TyK_union, id);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

proc make_type_array id: int, count: int, type: type in
    var self = make_type(TyK_array, id);
    u64!(self + TTYPE_array_count, count);
    u64!(self + TTYPE_array_type, type);
    return self;
end

proc type_kind self: type in return cast(u32@(self + TTYPE_kind), int); end
proc type_size self: type in return cast(u32@(self + TTYPE_size), int); end
proc type_id self: type in return cast(u64@(self + TTYPE_id), int); end
proc type_params self: type in return cast(u64@(self + TTYPE_params), vector); end
proc type_ast self: type in return cast(u64@(self + TTYPE_ast), ast); end
proc type_deref_type self: type in return cast(u64@(self + TTYPE_deref_type), type); end
proc type_ref_to_this self: type in return cast(u64@(self + TTYPE_ref_to_this), type); end
proc type_proc_return_type self: type in
    return cast(u64@(self + TTYPE_proc_return_type), type);
end
proc type_proc_parameters self: type in
    return cast(u64@(self + TTYPE_proc_parameters), vector);
end
proc type_proc_varargs self: type in
    return cast(u8@(self + TTYPE_proc_varargs), bool);
end
proc type_struct_fields self: type in
    return cast(u64@(self + TTYPE_struct_fields), vector);
end
proc type_struct_procs self: type in
    return cast(u64@(self + TTYPE_struct_procs), vector);
end
proc type_enum_names self: type in return cast(u64@(self + TTYPE_enum_names), vector); end
proc type_enum_values self: type in return cast(u64@(self + TTYPE_enum_values), vector); end
proc type_union_names self: type in return cast(u64@(self + TTYPE_union_names), vector); end
proc type_union_types self: type in return cast(u64@(self + TTYPE_union_types), vector); end
proc type_array_count self: type in return cast(u64@(self + TTYPE_array_count), int); end
proc type_array_type self: type in return cast(u64@(self + TTYPE_array_type), type); end

proc type_set_kind self: type, kind: int in u32!(self + TTYPE_kind, kind); end
proc type_set_size self: type, size: int in u32!(self + TTYPE_size, size); end
proc type_set_params self: type, params: vector in u64!(self + TTYPE_params, params); end
proc type_set_ast self: type, ast: ast in u64!(self + TTYPE_ast, ast); end
proc type_set_deref_type self: type, type: type in u64!(self + TTYPE_deref_type, type); end
proc type_set_ref_to_this self: type, type: type in u64!(self + TTYPE_ref_to_this, type); end
proc type_set_proc_return_type self: type, type: type in
    u64!(self + TTYPE_proc_return_type, type);
end
proc type_set_proc_parameters self: type, params: vector in
    u64!(self + TTYPE_proc_parameters, params);
end
proc type_set_proc_varargs self: type, varargs: bool in
    u8!(self + TTYPE_proc_varargs, varargs);
end
proc type_set_struct_fields self: type, fields: vector in u64!(self + TTYPE_struct_fields, fields); end
proc type_set_struct_procs self: type, procs: vector in u64!(self + TTYPE_struct_procs, procs); end
proc type_set_enum_names self: type, names: vector in u64!(self + TTYPE_enum_names, names); end
proc type_set_enum_values self: type, values: vector in u64!(self + TTYPE_enum_values, values); end
proc type_set_union_names self: type, names: vector in u64!(self + TTYPE_union_names, names); end
proc type_set_union_types self: type, types: vector in u64!(self + TTYPE_union_types, types); end
proc type_set_array_count self: type, count: int in u64!(self + TTYPE_array_count, count); end
proc type_set_array_type self: type, type: type in u64!(self + TTYPE_array_type, type); end

proc type_is_undefined self: type in return type_kind(self) == TyK_undefined; end
proc type_is_void self: type in return type_kind(self) == TyK_void; end
proc type_is_any self: type in return type_kind(self) == TyK_any; end
proc type_is_int_like self: type in return type_kind(self) == TyK_int_like; end
proc type_is_reference self: type in return type_kind(self) == TyK_reference; end
proc type_is_struct self: type in return type_kind(self) == TyK_struct; end
proc type_is_procedure self: type in return type_kind(self) == TyK_procedure; end
proc type_is_enum self: type in return type_kind(self) == TyK_enum; end
proc type_is_union self: type in return type_kind(self) == TyK_union; end
proc type_is_array self: type in return type_kind(self) == TyK_array; end

proc type_is_scalar self: type in
    if type_is_int_like(self) then
        return true;
    elif type_is_reference(self) then
        return true;
    elif type_is_procedure(self) then
        return true;
    end
    return false;
end

proc types_eq a: type, b: type in
    if a == b then
        return true;
    end
    if type_is_procedure(a) and type_is_procedure(b) then
        var a_ret = type_proc_return_type(a);
        var b_ret = type_proc_return_type(b);
        if not types_eq(a_ret, b_ret) then
            return false;
        end
        var a_params = type_proc_parameters(a);
        var b_params = type_proc_parameters(b);
        if vector_len(a_params) != vector_len(b_params) then
            return false;
        end
        var i = 0; var len = vector_len(a_params);
        while i < len do
            var ap = vector_get(a_params, i);
            var bp = vector_get(b_params, i);
            if not types_eq(ap, bp) then
                return false;
            end
            i += 1;
        end
        return true;
    end
    return a == b;
end

proc _basic_proc_type_match tt, lhs, rhs in
    if type_proc_varargs(lhs) != type_proc_varargs(rhs) then
        return false;
    elif not types_assignable(tt, type_proc_return_type(lhs), type_proc_return_type(rhs)) then
        return false;
    end
    var lhs_params = type_proc_parameters(lhs);
    var rhs_params = type_proc_parameters(rhs);
    if vector_len(lhs_params) != vector_len(rhs_params) then
        return false;
    end

    var i = 0; var len = vector_len(lhs_params);
    while i < len do
        var a = vector_get(lhs_params, i);
        var b = vector_get(rhs_params, i);
        if not types_assignable(tt, a, b) then
            return false;
        end
        i += 1;
    end
    return true;
end

proc types_assignable tt: type_table, lhs: type, rhs: type in
    if types_eq(lhs, rhs) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    var char = tt_char_type(tt);
    var int = tt_int_type(tt);
    var bool = tt_bool_type(tt);
    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        // ensure the rhs can fit into the lhs.
        if type_size(lhs) >= type_size(rhs) then
            return true;
        end
    end

    if lhs == ptr and rhs == cstr then
        return true;
    elif lhs == cstr and rhs == ptr then
        return true;
    elif lhs == ptr and type_is_int_like(rhs) then
        return true;
    elif lhs == ptr and type_is_reference(rhs) then
        return true;
    elif type_is_reference(lhs) and rhs == ptr then
        return true;
    elif type_is_procedure(lhs) and type_is_procedure(rhs) then
        return _basic_proc_type_match(tt, lhs, rhs);
    elif lhs == ptr and type_is_procedure(rhs) then
        return true;
    elif type_is_procedure(lhs) and rhs == ptr then
        return true;
    elif lhs == char and rhs == int then
        return true;
    elif lhs == int and rhs == char then
        return true;
    elif lhs == int and rhs == bool then
        return true;
    elif lhs == bool and type_is_int_like(rhs) then
        return true;
    elif lhs == bool and type_is_scalar(rhs) then
        return true;
    end
    return false;
end

proc print_type self: type in
    var kind = type_kind(self);
    var id = type_id(self);
    printf("kind=%d, id=%d\n", kind, id);
end

const TTYPE_TABLE_type_ids  = 0;  // (cstr, int) map : name -> type_id
const TTYPE_TABLE_types     = 8;  // type vector : type_id is index into this vector
const TTYPE_TABLE_names     = 16; // cstr vector : type_id is index into this vector, may have NULLs
const TTYPE_TABLE_ast_types = 24; // (ast, type) map : ast -> type
const TTYPE_TABLE_void_type = 32; // fast ref to `void` type
const TTYPE_TABLE_any_type  = 40; // fast ref to `any` type
const TTYPE_TABLE_int_type  = 48; // fast ref to `int` type
const TTYPE_TABLE_char_type = 56; // fast ref to `char` type
const TTYPE_TABLE_ptr_type  = 64; // fast ref to `ptr` type
const TTYPE_TABLE_cstr_type = 72; // fast ref to `cstr` type
const TTYPE_TABLE_bool_type = 80; // fast ref to `bool` type
const sizeof_TTYPE_TABLE    = 88;

proc _tt_make_type tyk, name, size, type_ids, types, names in
    var type_idx = vector_len(types);
    var t = make_type(tyk, type_idx);
    type_set_size(t, size);
    map_set(type_ids, name, type_idx);
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

proc _tt_make_ref_type type, name, type_ids, types, names in
    assert(not type_ref_to_this(type));
    var type_idx = vector_len(types);
    var t = make_type_reference(type_idx, type);
    type_set_size(t, PTR_BITS);
    type_set_ref_to_this(type, t);
    if name then
        map_set(type_ids, name, type_idx);
    end
    vector_push(types, t);
    vector_push(names, name);
    return t;
end

proc _tt_make_type_alias type, name, type_ids, types, names in
    map_set(type_ids, name, vector_len(types));
    vector_push(types, type);
    vector_push(names, name);
end

proc make_type_table -> type_table in
    var self = malloc(sizeof_TTYPE_TABLE);
    var type_ids = make_map(0, cstr_eq, cstr_hash);
    var types = make_vector(0);
    var names = make_vector(0);
    u64!(self + TTYPE_TABLE_type_ids, type_ids);
    u64!(self + TTYPE_TABLE_types, types);
    u64!(self + TTYPE_TABLE_names, names);
    u64!(self + TTYPE_TABLE_ast_types, make_map(0, NULL, NULL));

    var void_t = _tt_make_type(TyK_void, "void", 0, type_ids, types, names);
    u64!(self + TTYPE_TABLE_void_type, void_t);

    var any_t = _tt_make_type(TyK_any, "any", 0, type_ids, types, names);
    u64!(self + TTYPE_TABLE_any_type, any_t);

    var bool_t = _tt_make_type(TyK_int_like, "bool", BOOL_BITS, type_ids, types, names);
    u64!(self + TTYPE_TABLE_bool_type, bool_t);

    var int_t = _tt_make_type(TyK_int_like, "int", INT_BITS, type_ids, types, names);
    u64!(self + TTYPE_TABLE_int_type, int_t);

    var char_t = _tt_make_type(TyK_int_like, "char", CHAR_BITS, type_ids, types, names);
    u64!(self + TTYPE_TABLE_char_type, char_t);

    var ptr_t = _tt_make_ref_type(void_t, "ptr", type_ids, types, names);
    u64!(self + TTYPE_TABLE_ptr_type, ptr_t);

    var cstr_t = _tt_make_ref_type(char_t, "cstr", type_ids, types, names);
    u64!(self + TTYPE_TABLE_cstr_type, cstr_t);

    _tt_make_type_alias(char_t, "int8", type_ids, types, names);
    _tt_make_type_alias(int_t, "int64", type_ids, types, names);

    _tt_make_type(TyK_int_like, "int16", 16, type_ids, types, names);
    _tt_make_type(TyK_int_like, "int32", 32, type_ids, types, names);

    return cast(self, type_table);
end

proc type_table_type_ids self: type_table in return cast(u64@(self + TTYPE_TABLE_type_ids), map); end
proc type_table_types self: type_table in return cast(u64@(self + TTYPE_TABLE_types), vector); end
proc type_table_names self: type_table in return cast(u64@(self + TTYPE_TABLE_names), vector); end
proc type_table_ast_types self: type_table in return cast(u64@(self + TTYPE_TABLE_ast_types), map); end
proc tt_any_type self: type_table in return cast(u64@(self + TTYPE_TABLE_any_type), type); end
proc tt_void_type self: type_table in return cast(u64@(self + TTYPE_TABLE_void_type), type); end
proc tt_int_type self: type_table in return cast(u64@(self + TTYPE_TABLE_int_type), type); end
proc tt_ptr_type self: type_table in return cast(u64@(self + TTYPE_TABLE_ptr_type), type); end
proc tt_cstr_type self: type_table in return cast(u64@(self + TTYPE_TABLE_cstr_type), type); end
proc tt_bool_type self: type_table in return cast(u64@(self + TTYPE_TABLE_bool_type), type); end
proc tt_char_type self: type_table in return cast(u64@(self + TTYPE_TABLE_char_type), type); end

proc tt_get_ast_type self, ast in
    var found = map_find(type_table_ast_types(self), ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc tt_set_ast_type self, ast, type in
    map_set(type_table_ast_types(self), ast, type);
end

proc tt_get_type_name self, type in
    return vector_get(type_table_names(self), type_id(type));
end

proc tt_get_type_or_null self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, cast(map_pair_val(found), int));
    end
    return NULL;
end

proc tt_get_type_or_make_undefined self, name in
    var type_ids = type_table_type_ids(self);
    var found = map_find(type_ids, name);
    var types = type_table_types(self);
    if found then
        return vector_get(types, cast(map_pair_val(found), int));
    end
    var type_idx = vector_len(types);
    var type = make_type_undefined(type_idx);
    map_set(type_ids, name, type_idx);
    vector_push(types, type);
    vector_push(type_table_names(self), name);
    return type;
end

proc tt_get_reference_to_type self, type in
    var ref = type_ref_to_this(type);
    if not ref then
        ref = _tt_make_ref_type(type, NULL,
                    type_table_type_ids(self),
                    type_table_types(self),
                    type_table_names(self));
    end
    return ref;
end

proc tt_make_anon_proc self, return_type, param_types, varargs in
    var types = type_table_types(self);
    var type = make_type_procedure(vector_len(types), return_type, param_types, varargs);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc tt_make_anon_struct self, fields, procs in
    var types = type_table_types(self);
    var type = make_type_struct(vector_len(types), fields, procs);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc tt_make_anon_union self, field_names, field_types in
    var types = type_table_types(self);
    var type = make_type_union(vector_len(types), field_names, field_types);
    vector_push(types, type);
    vector_push(type_table_names(self), NULL);
    return type;
end

proc _tt_append_proc_type_repr self, string, type in
    if not type then
        string_append_cstr(string, "{null}");
    elif type_is_procedure(type) then
        var ptn = tt_get_proc_type_name(self, type);
        string_append_string(string, ptn);
        free_string(ptn);
    else
        var tn = tt_get_type_name(self, type);
        if tn then
            string_append_cstr(string, tn);
        else
            string_append_cstr(string, "{no type}");
        end
    end
end

proc tt_get_proc_type_name self, type in
    if not type_is_procedure(type) then
        return NULL;
    end

    var string = make_string(20);
    string_push(string, '(');
    var params = type_proc_parameters(type);
    var ret_ty = type_proc_return_type(type);

    var i = 0; var len = vector_len(params);
    while i < len do
        var param_type = vector_get(params, i);
        _tt_append_proc_type_repr(self, string, param_type);
        i += 1;
        if i < len then
            string_append_cstr(string, ", ");
        end
    end
    if i == 0 then
        string_append_cstr(string, "void");
    end

    string_append_cstr(string, " -> ");
    _tt_append_proc_type_repr(self, string, ret_ty);
    string_push(string, ')');
    return string;
end

proc tt_calculate_struct self, stype, again_q in
    if type_size(stype) != TYPE_NEEDS_SIZING then
        return;
    end
    var fields = type_struct_fields(stype);
    var bit_offs = 0;
    var i = 0; var len = vector_len(fields);
    var ptr_align = false;
    while i < len do
        var field = vector_get(fields, i);
        var fname = field_name(field);
        var ftype = field_type(field);

        if type_is_reference(ftype) and not ptr_align then
            ptr_align = true;
        end

        var size = type_size(ftype);
        if size == TYPE_NEEDS_SIZING then
            queue_enqueue(again_q, stype);
            return;
        end
        if not type_is_struct(ftype) then
            bit_offs = (bit_offs + (size - 1)) & -size; // align to nearest boundary
        end
        field_set_bit_offset(field, bit_offs);
        bit_offs += size;
        i += 1;
    end
    if ptr_align then
        bit_offs = (bit_offs + (PTR_BITS-1)) & -PTR_BITS;
    end
    type_set_size(stype, bit_offs);
end

proc tt_detect_cycles self, stype in
    // Breadth-first search for cycles.
    var q = make_queue(0);
    var explored = make_set(0, NULL, NULL);

    set_add(explored, stype);
    var fields = type_struct_fields(stype);
    var i = 0; var len = vector_len(fields);
    while i < len do
        var field = vector_get(fields, i);
        var ftype = field_type(field);
        if ftype == stype then // immediate self-reference
            return true;
        end
        if type_is_struct(ftype) and not set_contains(explored, ftype) then
            set_add(explored, ftype);
            queue_enqueue(q, ftype);
        end
        i += 1;
    end

    while queue_len(q) != 0 do
        var v = queue_dequeue(q);
        if v == stype then
            return true;
        end
        fields = type_struct_fields(v);
        i = 0; len = vector_len(fields);
        while i < len do
            var field = vector_get(fields, i);
            var ftype = field_type(field);
            if ftype == stype then
                return true;
            end
            if type_is_struct(ftype) and not set_contains(explored, ftype) then
                set_add(explored, ftype);
                queue_enqueue(q, ftype);
            end
            i += 1;
        end
    end
    free_queue(q);
    free_set(explored);
    return false;
end

proc tt_calculate_structs self in
    var to_calc = make_queue(0);
    var types = type_table_types(self);
    var i = 0; var len = vector_len(types);
    var void = tt_void_type(self);
    while i < len do
        var type = vector_get(types, i);
        if type_is_undefined(type) then
            printf("WARN: type `%s` is still undefined!\n", tt_get_type_name(self, type));
            type_set_size(type, PTR_BITS);
            type_set_kind(type, TyK_reference);
            type_set_deref_type(type, void);
        elif type_is_struct(type) and type_size(type) == TYPE_NEEDS_SIZING then
            queue_enqueue(to_calc, type);
        end
        i += 1;
    end

    while queue_len(to_calc) != 0 do
        var type = queue_dequeue(to_calc);
        if tt_detect_cycles(self, type) then
            printf("ERROR: Detected cycles in struct `%s`\n", tt_get_type_name(self, type));
            exit(1);
        end
        tt_calculate_struct(self, type, to_calc);
    end
    free_queue(to_calc);
end

proc tt_print_type_name self, type in
    if type then
        if type_is_procedure(type) then
            var string = tt_get_proc_type_name(self, type);
            printf("%s", string_cstr(string));
            free_string(string);
        else
            var name = tt_get_type_name(self, type);
            if name then
                printf("%s", name);
            elif type_is_reference(type) then
                var refs = 0;
                while type_is_reference(type) do
                    if type_deref_type(type) then
                        type = type_deref_type(type);
                        refs += 1;
                    else
                        break;
                    end
                end
                printf("%s", tt_get_type_name(self, type));
                while refs != 0 do
                    printf("&");
                    refs -= 1;
                end
            else
                printf("<type id %d>", type_id(type));
            end
        end
    else
        printf("{no type}");
    end
end
