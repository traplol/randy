
const TyK_void      = 0;
const TyK_any       = 1;
const TyK_primitive = 2;
const TyK_reference = 3; // NYI
const TyK_procedure = 4;
const TyK_struct    = 5; // NYI
const TyK_enum      = 6; // NYI
const TyK_union     = 7; // NYI
const TyK_array     = 8; // NYI

const TTYPE_kind     = 0;  // TyK
const TTYPE_name     = 8;  // cstr
// reference
const TTYPE_ref_type = 16; // type
// procedure
const TTYPE_proc_return_type = 16; // type
const TTYPE_proc_parameters  = 24; // symbol vector
// struct
const TTYPE_struct_names = 16; // cstr vector
const TTYPE_struct_types = 24; // type vector
// enum
const TTYPE_enum_names  = 16; // cstr vector
const TTYPE_enum_values = 24; // int vector
// union
const TTYPE_union_names = 16; // cstr vector
const TTYPE_union_types = 24; // type vector
// array
const TTYPE_array_count = 16; // number of elems in array
const TTYPE_array_type  = 24; // type of each elem in array

const sizeof_TTYPE = 32;

proc make_type kind, name in
    var self = calloc(1, sizeof_TTYPE);
    u64!(self + TTYPE_kind, kind);
    u64!(self + TTYPE_name, name);
    return self;
end

proc make_type_reference name, type in
    var self = make_type(TyK_reference, name);
    u64!(self + TTYPE_ref_type, type);
    return self;
end

proc make_type_procedure name, return_type, parameters in
    var self = make_type(TyK_procedure, name);
    u64!(self + TTYPE_proc_return_type, return_type);
    u64!(self + TTYPE_proc_parameters, parameters);
    return self;
end

proc make_type_struct name, field_names, field_types in
    var self = make_type(TyK_struct, name);
    u64!(self + TTYPE_struct_names, field_names);
    u64!(self + TTYPE_struct_types, field_types);
    return self;
end

proc make_type_enum name, enum_names, enum_values in
    var self = make_type(TyK_enum, name);
    u64!(self + TTYPE_enum_names, enum_names);
    u64!(self + TTYPE_enum_values, enum_values);
    return self;
end

proc make_type_union name, union_names, union_types in
    var self = make_type(TyK_union, name);
    u64!(self + TTYPE_union_names, union_names);
    u64!(self + TTYPE_union_types, union_types);
    return self;
end

proc make_type_array name, count, type in
    var self = make_type(TyK_array, name);
    u64!(self + TTYPE_array_count, count);
    u64!(self + TTYPE_array_type, type);
    return self;
end

proc type_kind self in return u64@(self + TTYPE_kind); end
proc type_name self in return u64@(self + TTYPE_name); end
proc type_ref_type self in return u64@(self + TTYPE_ref_type); end
proc type_proc_return_type self in return u64@(self + TTYPE_proc_return_type); end
proc type_proc_parameters self in return u64@(self + TTYPE_proc_parameters); end
proc type_struct_names self in return u64@(self + TTYPE_struct_names); end
proc type_struct_types self in return u64@(self + TTYPE_struct_types); end
proc type_enum_names self in return u64@(self + TTYPE_enum_names); end
proc type_enum_values self in return u64@(self + TTYPE_enum_values); end
proc type_union_names self in return u64@(self + TTYPE_union_names); end
proc type_union_types self in return u64@(self + TTYPE_union_types); end
proc type_array_count self in return u64@(self + TTYPE_array_count); end
proc type_array_type self in return u64@(self + TTYPE_array_type); end

proc type_is_void self in return type_kind(self) == TyK_void; end
proc type_is_any self in return type_kind(self) == TyK_any; end
proc type_is_primitive self in return type_kind(self) == TyK_primitive; end
proc type_is_reference self in return type_kind(self) == TyK_reference; end
proc type_is_struct self in return type_kind(self) == TyK_struct; end
proc type_is_procedure self in return type_kind(self) == TyK_procedure; end
proc type_is_enum self in return type_kind(self) == TyK_enum; end
proc type_is_union self in return type_kind(self) == TyK_union; end
proc type_is_array self in return type_kind(self) == TyK_array; end

proc print_type self in
    var kind = type_kind(self);
    var name = type_name(self);
    printf("kind=%d, name=%s\n", kind, name);
end

const TTYPE_TABLE_types         = 0;  // (cstr, type) map : type_name -> type
const TTYPE_TABLE_ast_types     = 8;  // (ast, type) map : ast -> type
const TTYPE_TABLE_any_type      = 24; // fast ref to `any` type
const TTYPE_TABLE_void_type     = 32; // fast ref to `void` type
const TTYPE_TABLE_int_type      = 40; // fast ref to `int` type
const TTYPE_TABLE_ptr_type      = 48; // fast ref to `ptr` type
const TTYPE_TABLE_cstr_type     = 56; // fast ref to `cstr` type
const sizeof_TTYPE_TABLE        = 104;

proc make_type_table in
    var self = malloc(sizeof_TTYPE_TABLE);
    var types = make_map(0, cstr_eq, cstr_hash);
    u64!(self + TTYPE_TABLE_types, types);
    u64!(self + TTYPE_TABLE_ast_types, make_map(0, NULL, NULL));

    var t;

    t = make_type(TyK_any, "any"); // temporary "black hole" type, matches anything
    u64!(self + TTYPE_TABLE_any_type, t);
    map_set(types, type_name(t), t);

    t = make_type(TyK_void, "void"); // only usable for proc return types
    u64!(self + TTYPE_TABLE_void_type, t);
    map_set(types, type_name(t), t);

    t = make_type(TyK_primitive, "int");
    u64!(self + TTYPE_TABLE_int_type, t);
    map_set(types, type_name(t), t);

    t = make_type(TyK_primitive, "ptr");
    u64!(self + TTYPE_TABLE_ptr_type, t);
    map_set(types, type_name(t), t);

    t = make_type(TyK_primitive, "cstr");
    u64!(self + TTYPE_TABLE_cstr_type, t);
    map_set(types, type_name(t), t);
    return self;
end

proc tt_types self in return u64@(self + TTYPE_TABLE_types); end
proc tt_ast_types self in return u64@(self + TTYPE_TABLE_ast_types); end
proc tt_any_type self in return u64@(self + TTYPE_TABLE_any_type); end
proc tt_void_type self in return u64@(self + TTYPE_TABLE_void_type); end
proc tt_int_type self in return u64@(self + TTYPE_TABLE_int_type); end
proc tt_ptr_type self in return u64@(self + TTYPE_TABLE_ptr_type); end
proc tt_cstr_type self in return u64@(self + TTYPE_TABLE_cstr_type); end

proc tt_get_ast_type self, ast in
    var found = map_find(tt_ast_types(self), ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc tt_set_ast_type self, ast, type in
    map_set(tt_ast_types(self), ast, type);
end

proc tt_add_type self, type in
    var name = type_name(type);
    map_set(tt_types(self), name, type);
end

proc tt_get_type self, name in
    var found = map_find(tt_types(self), name);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end
