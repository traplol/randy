
struct Field in
    type: Type&;
    name: cstr;
    bit_offset: int;
    token: Token&;
end

def make_field type, name, bit_offset, token -> Field& in
    var self: Field& = malloc(__sizeof(Field));
    self.type = type;
    self.name = name;
    self.bit_offset = bit_offset;
    self.token = token;
    return self;
end

def field_make_copy self: Field& in
    return make_field(self.type, self.name, self.bit_offset, self.token);
end

struct EnumValue in
    token: Token&;
    name: cstr;
    value: ast;
    cache_value: ptr;
end

def make_enum_value token: Token&, name: cstr, value: ast -> EnumValue& in
    var self = cast(malloc(__sizeof(EnumValue)), EnumValue&);
    self.token = token;
    self.name = name;
    self.value = value;
    self.cache_value = NULL;
    return self;
end

enum TypeKind in
    Undefined;
    Void;
    Any;
    Int_like;
    Reference;
    Def;
    Struct;
    Enum;
    Union;
    GenericParam;
end

struct Type in
    struct Def in
        return_type: Type&;
        parameters: Vector[Type&]&;
        varargs: bool;
    end

    struct Struct in
        fields: Vector[Field&]&;
        defs: Vector[Symbol&]&;
    end

    struct Enum in
        values: Vector[EnumValue&]&;
    end

    struct Union in
        fields: Vector[Field&]&;
    end

    union u in
        deref_type: Type&;
        def_: Def;
        struct_: Struct;
        enum_: Enum;
        union_: Union;
    end

    kind: TypeKind;
    id: int;
    size: int32;
    is_generic: bool;
    params: Vector[Type&]&;
    ast: ast;
    ref_to_this: Type&;
    instances: Vector[Type&]&;
    scope: TypeScope&;
    enclosed: Type&;
    u: u;
end

const TYPE_NEEDS_SIZING = (1<<32)-1;

def make_type kind: TypeKind, id: int, scope: TypeScope& -> Type& in
    var self = cast(calloc(1, __sizeof(Type)), Type&);
    self.kind = kind;
    self.id = id;
    self.size = TYPE_NEEDS_SIZING;
    self.is_generic = false;
    self.scope = scope;
    if scope then
        self.enclosed = scope.enclosing;
    end
    return self;
end

def make_type_undefined id: int, scope: TypeScope& in
    return make_type(TypeKind::Undefined, id, scope);
end

def make_type_reference id: int, type: Type& in
    var self = make_type(TypeKind::Reference, id, type_scope(type));
    self.u.deref_type = type;
    return self;
end

def make_type_def id: int, scope: TypeScope&, return_type: Type&, param_types: Vector[Type&]&, varargs: bool in
    var self = make_type(TypeKind::Def, id, scope);
    self.u.def_.return_type = return_type;
    self.u.def_.parameters = param_types;
    self.u.def_.varargs = varargs;
    return self;
end

def make_type_struct id: int, scope: TypeScope&, fields: Vector[Field&]&, defs: Vector[Symbol&]& in
    var self = make_type(TypeKind::Struct, id, scope);
    self.u.struct_.fields = fields;
    self.u.struct_.defs = defs;
    return self;
end

def make_type_enum id: int, scope: TypeScope&, enum_values: Vector[EnumValue&]& in
    var self = make_type(TypeKind::Enum, id, scope);
    self.u.enum_.values = enum_values;
    return self;
end

def make_type_union id: int, scope: TypeScope&, fields: Vector[Field&]& in
    var self = make_type(TypeKind::Union, id, scope);
    self.u.union_.fields = fields;
    return self;
end

def copy_type_with_id type: Type&, id: int, scope: TypeScope& in
    var copy = cast(malloc(__sizeof(Type)), Type&);
    memcpy(copy, type, __sizeof(Type));
    copy.id = id;
    copy.scope = scope;
    return copy;
end

def type_kind self: Type& in return self.kind; end
def type_is_generic self: Type& in return self.is_generic; end
def type_size self: Type& in return self.size; end
def type_id self: Type& in return self.id; end
def type_params self: Type& in return self.params; end
def type_scope self: Type& in return self.scope; end
def type_instances self: Type& in return self.instances; end
def type_ast self: Type& in return self.ast; end
def type_deref_type self: Type& in return self.u.deref_type; end
def type_ref_to_this self: Type& in return self.ref_to_this; end
def type_def_return_type self: Type& in return self.u.def_.return_type; end
def type_def_parameters self: Type& in return self.u.def_.parameters; end
def type_def_varargs self: Type& in return self.u.def_.varargs; end
def type_struct_fields self: Type& in return self.u.struct_.fields; end
def type_struct_defs self: Type& in return self.u.struct_.defs; end
def type_enum_values self: Type& in return self.u.enum_.values; end
def type_union_fields self: Type& in return self.u.union_.fields; end

def type_set_kind self: Type&, kind: TypeKind in self.kind = kind; end
def type_set_is_generic self: Type&, val: bool in self.is_generic = val; end
def type_set_size self: Type&, size: int in self.size = size; end
def type_set_params self: Type&, params: Vector[Type&]& in self.params = params; end
def type_set_instances self: Type&, instances: Vector[Type&]& in self.instances = instances; end
def type_set_ast self: Type&, ast: ast in self.ast = ast; end
def type_set_deref_type self: Type&, type: Type& in self.u.deref_type = type; end
def type_set_ref_to_this self: Type&, type: Type& in self.ref_to_this = type; end
def type_set_def_return_type self: Type&, type: Type& in self.u.def_.return_type = type; end
def type_set_def_parameters self: Type&, params: Vector[Symbol]& in self.u.def_.parameters = params; end
def type_set_def_varargs self: Type&, varargs: bool in self.u.def_.varargs = varargs; end
def type_set_struct_fields self: Type&, fields: Vector[Field&]& in self.u.struct_.fields = fields; end
def type_set_struct_defs self: Type&, defs: Vector[Symbol&]& in self.u.struct_.defs = defs; end
def type_set_enum_values self: Type&, values: Vector[EnumValue&]& in self.u.enum_.values = values; end
def type_set_union_fields self: Type&, fields: Vector[Field&]& in self.u.union_.fields = fields; end

def type_is_undefined self: Type& in return type_kind(self) == TypeKind::Undefined; end
def type_is_void self: Type& in return type_kind(self) == TypeKind::Void; end
def type_is_any self: Type& in return type_kind(self) == TypeKind::Any; end
def type_is_int_like self: Type& in return type_kind(self) == TypeKind::Int_like; end
def type_is_reference self: Type& in return type_kind(self) == TypeKind::Reference; end
def type_is_struct self: Type& in return type_kind(self) == TypeKind::Struct; end
def type_is_def self: Type& in return type_kind(self) == TypeKind::Def; end
def type_is_enum self: Type& in return type_kind(self) == TypeKind::Enum; end
def type_is_union self: Type& in return type_kind(self) == TypeKind::Union; end
def type_is_generic_param self: Type& in return type_kind(self) == TypeKind::GenericParam; end

def type_is_scalar self: Type& in
    if type_is_int_like(self) then
        return true;
    elif type_is_reference(self) then
        return true;
    elif type_is_def(self) then
        return true;
    end
    return false;
end

def types_eq a: Type&, b: Type& in
    assert(a);
    assert(b);
    if a == b then
        return true;
    end
    if type_id(a) == type_id(b) then
        return true;
    end
    if type_is_reference(a) and type_is_reference(b) then
        return types_eq(type_deref_type(a), type_deref_type(b));
    end
    return false;
end

def _basic_def_type_match tt, lhs, rhs in
    if type_def_varargs(lhs) != type_def_varargs(rhs) then
        return false;
    elif not types_assignable(tt, type_def_return_type(lhs), type_def_return_type(rhs)) then
        return false;
    end
    var lhs_params = type_def_parameters(lhs);
    var rhs_params = type_def_parameters(rhs);
    if lhs_params.length != rhs_params.length then
        return false;
    end

    var i = 0; var len = lhs_params.length;
    while i < len do
        var a = lhs_params.get(i);
        var b = rhs_params.get(i);
        if not types_assignable(tt, a, b) then
            return false;
        end
        i += 1;
    end
    return true;
end

def types_assignable tt: TypeTable&, lhs: Type&, rhs: Type& in
    if types_eq(lhs, rhs) then
        return true;
    end
    var ptr = tt_ptr_type(tt);
    var cstr = tt_cstr_type(tt);
    var char = tt_char_type(tt);
    var int = tt_int_type(tt);
    var bool = tt_bool_type(tt);
    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        return true;
    end

    if lhs == ptr and rhs == cstr then
        return true;
    elif lhs == cstr and rhs == ptr then // TODO FIXME: cstr should not accept ptr
        return true;
    elif lhs == ptr and type_is_int_like(rhs) then // TODO FIXME: ptr should not accept int-like
        return true;
    elif lhs == ptr and type_is_reference(rhs) then
        return true;
    elif type_is_reference(lhs) and rhs == ptr then // TODO FIXME: ref should not accept ptr
        return true;
    elif type_is_def(lhs) and type_is_def(rhs) then
        return _basic_def_type_match(tt, lhs, rhs);
    elif lhs == ptr and type_is_def(rhs) then
        return true;
    elif type_is_def(lhs) and rhs == ptr then // TODO FIXME: function should not accept ptr
        return true;
    // TODO FIXME: this is a hack so int literals, which are `int`s can be assigned to chars.
    elif lhs == char and type_is_int_like(rhs) then
        return true;
    elif lhs == bool and type_is_scalar(rhs) then
        return true;
    end
    return false;
end

struct TypeScope in
    types: map; // (cstr, int) : the types within the current scope
    parent: TypeScope&;
    enclosing: Type&;
end

def make_type_scope parent: TypeScope& -> TypeScope& in
    var self = cast(malloc(__sizeof(TypeScope)), TypeScope&);
    self.types = make_map(0, cstr_eq, cstr_hash);
    self.parent = parent;
    self.enclosing = NULL;
    return self;
end

def type_scope_find self, tt, name -> Type& in
    var found = map_find(self.types, name);
    if found then
        return tt_get_type_by_id(tt, cast(map_pair_val(found), int));
    end
    return NULL;
end

struct TypeTable in
    type_scope: TypeScope&;
    top_type_scope: map; // fast reference to the top-level type scope.
    all_types: Vector[Type&]&;  // type Vector& : all types; type_id is index into this Vector&
    names: Vector[cstr]&;  // cstr Vector& : type_id is index into this Vector&, may have NULLs
    ast_types: map;  // (ast, type) map : ast -> type
    type_substitutes: map; // (type, type) map : replace the key type with val type
    void_type: Type&; // fast ref to `void` type
    any_type: Type&;  // fast ref to `any` type
    int_type: Type&;  // fast ref to `int` type
    char_type: Type&; // fast ref to `char` type
    ptr_type: Type&;  // fast ref to `ptr` type
    cstr_type: Type&; // fast ref to `cstr` type
    bool_type: Type&; // fast ref to `bool` type
    made_change: bool;
end

def _tt_make_type tyk, name, size, type_ids, types, names, scope in
    var type_idx = types.length;
    var t = make_type(tyk, type_idx, scope);
    type_set_size(t, size);
    map_set(type_ids, name, type_idx);
    types.push(t);
    names.push(name);
    return t;
end

def _tt_make_ref_type type, name, type_ids, types, names in
    assert(not type_ref_to_this(type));
    var type_idx = types.length;
    var t = make_type_reference(type_idx, type);
    type_set_size(t, PTR_BITS);
    type_set_ref_to_this(type, t);
    if name then
        map_set(type_ids, name, type_idx);
    end
    types.push(t);
    names.push(name);
    return t;
end

def _tt_make_type_alias type, name, type_ids, types, names in
    map_set(type_ids, name, types.length);
    types.push(type);
    names.push(name);
end

def make_type_table -> TypeTable& in
    var self: TypeTable& = calloc(1, __sizeof(TypeTable));
    var types = Vector[Type&]::new(0);
    var names = Vector[cstr]::new(0);
    self.type_scope = make_type_scope(NULL);
    var type_ids = self.type_scope.types;
    self.top_type_scope = type_ids;
    self.all_types = types;
    self.names = names;
    self.ast_types = make_map(0, NULL, NULL);
    self.type_substitutes = NULL;

    var void_t = _tt_make_type(TypeKind::Void, "void", 0, type_ids, types, names, self.type_scope);
    self.void_type = void_t;

    var any_t = _tt_make_type(TypeKind::Any, "any", 0, type_ids, types, names, self.type_scope);
    self.any_type = any_t;

    var bool_t = _tt_make_type(TypeKind::Int_like, "bool", BOOL_BITS, type_ids, types, names, self.type_scope);
    self.bool_type = bool_t;

    var int_t = _tt_make_type(TypeKind::Int_like, "int", INT_BITS, type_ids, types, names, self.type_scope);
    self.int_type = int_t;

    var char_t = _tt_make_type(TypeKind::Int_like, "char", CHAR_BITS, type_ids, types, names, self.type_scope);
    self.char_type = char_t;

    var ptr_t = _tt_make_ref_type(void_t, "ptr", type_ids, types, names);
    self.ptr_type = ptr_t;

    var cstr_t = _tt_make_ref_type(char_t, "cstr", type_ids, types, names);
    self.cstr_type = cstr_t;

    _tt_make_type_alias(char_t, "int8", type_ids, types, names);
    _tt_make_type_alias(int_t, "int64", type_ids, types, names);

    _tt_make_type(TypeKind::Int_like, "int16", 16, type_ids, types, names, self.type_scope);
    _tt_make_type(TypeKind::Int_like, "int32", 32, type_ids, types, names, self.type_scope);

    return self;
end

def tt_any_type self: TypeTable& in return self.any_type; end
def tt_void_type self: TypeTable& in return self.void_type; end
def tt_int_type self: TypeTable& in return self.int_type; end
def tt_ptr_type self: TypeTable& in return self.ptr_type; end
def tt_cstr_type self: TypeTable& in return self.cstr_type; end
def tt_bool_type self: TypeTable& in return self.bool_type; end
def tt_char_type self: TypeTable& in return self.char_type; end

def tt_set_enclosing self, enclosing in
    self.type_scope.enclosing = enclosing;
end

def tt_push_scope self in
    self.type_scope = make_type_scope(self.type_scope);
end

def tt_pop_scope self in
    assert(self.type_scope.parent);
    // don't free the map because places that push a type scope will hold onto that reference.
    self.type_scope = self.type_scope.parent;
end

def tt_cur_scope self -> map in
    return self.type_scope.types;
end

def tt_top_scope self -> map in
    return self.top_type_scope;
end

def tt_get_ast_type self, ast -> Type& in
    var found = map_find(self.ast_types, ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def tt_set_ast_type self, ast, type in
    var found = map_find(self.ast_types, ast);
    if not found then
        map_set(self.ast_types, ast, type);
        self.made_change = true;
    else
        var old_type = map_pair_val(found);
        if type != self.any_type and type != old_type then
            map_set(self.ast_types, ast, type);
            self.made_change = true;
        end
    end
end

def tt_get_type_name self, type -> cstr in
    while type_is_reference(type) and type_deref_type(type) do
        type = type_deref_type(type);
    end
    return self.names.get(type_id(type));
end

def tt_dump_scope self, scope in
    var types = scope.types;
    var cur = map_begin(types);
    printf("========= %p =========\n", scope);
    while cur != map_end(types) do
        var key = map_pair_key(cur);
        var val = map_pair_val(cur);
        printf("key = %s, val = %d\n", key, val);
        cur = map_next(types, cur);
    end
end

def tt_get_type_by_id self, id: int -> Type& in
    return self.all_types.get(id);
end

def tt_get_type_or_null self, name -> Type& in
    var cur = self.type_scope;
    while cur do
        var found = map_find(cur.types, name);
        if found then
            return self.all_types.get(cast(map_pair_val(found), int));
        end
        cur = cur.parent;
    end
    return NULL;
end

def tt_get_type_or_make_undefined self, name -> Type& in
    var type = tt_get_type_or_null(self, name);
    if type then
        return type;
    end

    var type_idx = self.all_types.length;
    type = make_type_undefined(type_idx, self.type_scope);

    // FIXME: We want to remove the need for forward declarations and to allow types which
    // haven't been defined yet to be referenced. In most scenarios this is probably fine
    // to make the type in the top scope but consider this code:
    // Fig 1.
    // struct Foo in
    //     bar: Bar&;
    //     struct Bar in
    //         ...
    //     end
    // end
    //
    // When parsing this code we parse the type of the `bar` field but no `Bar` type has
    // been defined yet, where do we define Bar? If we define it locally, which would be
    // correct, then we lose the ability to reference types that haven't been created yet
    // another example:
    // Fig 2.
    // struct Foo in
    //    bar: Bar&;
    // end
    // struct Bar in
    //    ...
    // end
    //
    // If we define Bar locally to Foo then this would result in an error because the
    // Bar local to Foo hasn't been defined yet. How do we fix this?
    // The current solution is to "catch" the local 'Bar' type in Fig 2 as being undefined
    // and overwrite the type "act" as the outer 'Bar' type
    map_set(tt_cur_scope(self), name, type_idx);
    self.all_types.push(type);
    self.names.push(name);
    return type;
end

def tt_reference_to_type self, type -> Type& in
    var ref = type_ref_to_this(type);
    if not ref then
        ref = _tt_make_ref_type(type, NULL, NULL, self.all_types, self.names);
        type_set_ref_to_this(type, ref);
    end
    return ref;
end

def tt_set_local_type self, type in
    var name = tt_get_type_name(self, type);
    if name then
        map_set(tt_cur_scope(self), name, type_id(type));
    end
end

def tt_promote_type self, type in
    tt_set_local_type(self, type);
    if type.scope.parent != NULL then
        var map = type.scope.types;
        var cur = map_begin(map);
        while cur != map_end(map) do
            var ty_id = cast(map_pair_val(cur), int);
            var ty = tt_get_type_by_id(self, ty_id);
            assert(ty);
            if ty.kind == TypeKind::Undefined then
                tt_set_local_type(self, ty);
                if ty.enclosed then
                    ty.enclosed = ty.enclosed.enclosed;
                end
            end
            cur = map_next(map, cur);
        end
    end
end

def tt_substitute_type self, type -> Type& in
    if not type then
        return NULL;
    end
    if not self.type_substitutes then
        return type;
    end
    var deref_type = type;
    var is_ref_type = false;
    if type_is_reference(deref_type) then
        is_ref_type = true;
        deref_type = type_deref_type(type);
        assert(deref_type);
        assert(not type_is_reference(deref_type), "TODO: support substituting multiple dereferences\n");
    end

    var found = map_find(self.type_substitutes, deref_type);
    if found then
        type = map_pair_val(found);
        if is_ref_type then
            type = tt_reference_to_type(self, type);
        end
        return type;
    end

    var params = type_params(deref_type);
    if params and params.length > 0 then
        var i = 0; var len = params.length;
        var new_params = Vector[Type&]::new(len);
        var made_subst = false;
        while i < len do
            var orig = params.get(i);
            var subst = tt_substitute_type(self, orig);
            if subst != orig then
                made_subst = true;
            end
            new_params.push(subst);
            i += 1;
        end
        if made_subst then
            type = tt_get_type_instance_of(self, g_SymbolTable, deref_type, new_params);
            if is_ref_type then
                type = tt_reference_to_type(self, type);
            end
            return type;
        else
            new_params.delete();
        end
    end
    return type;
end

def _tt_copy_ast_replacing_types self, st, ast, src_params, dst_params, type, instance in
    // TODO: will also need a way of flagging all of the src_types as ignored when calculating below
    tt_push_scope(self);
    var type_sub_map = make_map(src_params.length, NULL, NULL);
    var i = 0; var len = src_params.length;
    while i < len do
        var src = src_params.get(i);
        map_set(type_sub_map, src, dst_params.get(i));
        tt_set_local_type(self, src);
        i += 1;
    end
    map_set(type_sub_map, type, instance);
    var prev = self.type_substitutes;
    self.type_substitutes = type_sub_map;
    var ast_copy = _ast_deep_copy(ast, self, st);
    self.type_substitutes = prev;
    free_map(type_sub_map);
    tt_pop_scope(self);
    return ast_copy;
end

def _tt_instantiate_generic_type_impl self, st, type, params, instance_type in
    assert(type_params(type));
    assert(params);
    assert(type_params(type).length == params.length, "forgot to verify type_params lengths match\n");
    assert(type_ast(type), "forgot to set type ast\n");
    var instance_ast = _tt_copy_ast_replacing_types(self, st, type_ast(type), type_params(type), params, type, instance_type);
end

def tt_get_type_instance_of self, st, type, params in
    if type_is_undefined(type) then
        // need to register for later instantiation.
        assert(type_is_generic(type));
        var generic_params = type_params(type);
        assert(params.length == generic_params.length, "forgot to verify params length\n");
        var same = true;
        var i = 0; var len = params.length;
        while i < len do
            var src_type = generic_params.get(i);
            var dst_type = params.get(i);
            if not types_eq(src_type, dst_type) then
                same = false;
                break;
            end
            i += 1;
        end
        if same then
            return type;
        end
        assert(false, "not implemented: need to register type instance for later instantiation\n");
    else
        var instances = type_instances(type);
        if not instances then
            instances = Vector[Type&]::new(8);
            type_set_instances(type, instances);
        else
            var i = 0; var len = instances.length;
            while i < len do
                var inst = instances.get(i);
                var inst_params = type_params(inst);
                assert(params.length == inst_params.length, "forgot to verify params.length\n");
                var j = 0; var jlen = inst_params.length;
                while j < jlen do
                    if not types_eq(params.get(j), inst_params.get(j)) then
                        break;
                    end
                    j += 1;
                end
                if j == jlen then
                    return inst;
                end
                i += 1;
            end
        end

        var id = self.all_types.length;
        var instance_type = copy_type_with_id(type, id, self.type_scope);
        self.all_types.push(instance_type);
        var type_name = tt_get_type_name(self, type);
        self.names.push(type_name);
        type_set_is_generic(instance_type, false);
        type_set_params(instance_type, params); // used for looking up existing instances.
        type_set_ref_to_this(instance_type, NULL); // clear the old ref type
        var ref_type = tt_reference_to_type(self, instance_type);
        instances.push(instance_type);
        _tt_instantiate_generic_type_impl(self, st, type, params, instance_type);
        return instance_type;
    end
end

def tt_make_anon_def self, return_type, param_types, varargs in
    var type = make_type_def(self.all_types.length, self.type_scope, return_type, param_types, varargs);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def tt_make_anon_struct self, fields, defs in
    var type = make_type_struct(self.all_types.length, self.type_scope, fields, defs);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def tt_make_anon_union self, fields in
    var type = make_type_union(self.all_types.length, self.type_scope, fields);
    self.all_types.push(type);
    self.names.push(NULL);
    return type;
end

def _tt_append_type_repr self, string, type in
    if not type then
        string.append_cstr("{null}");
    elif type_is_def(type) then
        var name = tt_get_def_type_name(self, type);
        string.append_string(name);
        name.delete();
    else
        var refs = 0;
        var deref_type = type;
        while type_is_reference(deref_type) do
            refs += 1;
            deref_type = type_deref_type(deref_type);
        end

        if deref_type.enclosed then
            _tt_append_type_repr(self, string, deref_type.enclosed);
            string.push(':');
            string.push(':');
        end

        var name = tt_get_type_name(self, deref_type);
        if name then
            string.append_cstr(name);
        else
            string.append_cstr("<type id ");
            string.append_int(type_id(deref_type));
            string.push('>');
        end

        var params = type_params(deref_type);
        if params and params.length > 0 then
            string.push('[');
            var i = 0; var len = params.length;
            while i < len do
                _tt_append_type_repr(self, string, params.get(i));
                i += 1;
                if i < len then
                    string.append_cstr(", ");
                end
            end
            string.push(']');
        end
        while refs > 0 do
            string.push('&');
            refs -= 1;
        end
    end
end

def tt_get_def_type_name self, type -> String& in
    if not type_is_def(type) then
        return NULL;
    end

    var string = String::new(20);
    string.push('(');
    var params = type_def_parameters(type);
    var ret_ty = type_def_return_type(type);

    var i = 0; var len = params.length;
    while i < len do
        var param_type = params.get(i);
        _tt_append_type_repr(self, string, param_type);
        i += 1;
        if i < len then
            string.append_cstr(", ");
        end
    end
    if i == 0 then
        string.append_cstr("void");
    end

    string.append_cstr(" -> ");
    _tt_append_type_repr(self, string, ret_ty);
    string.push(')');
    return string;
end

def tt_calculate_struct self, stype, again_q in
    if type_size(stype) != TYPE_NEEDS_SIZING then
        return;
    end
    assert(type_is_struct(stype) or type_is_union(stype));
    var fields;
    if type_is_struct(stype) then
        fields = type_struct_fields(stype);
    else
        fields = type_union_fields(stype);
    end
    var bit_offs = 0;
    var ptr_align = false;
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var ftype = field.type;
        if type_is_generic_param(ftype) then
            // FIXME: this shouldn't happen but it does...
            type_set_is_generic(stype, true);
            return;
        end

        if type_is_reference(ftype) and not ptr_align then
            ptr_align = true;
        end

        var size = type_size(ftype);
        if size == TYPE_NEEDS_SIZING then
            again_q.enqueue(stype);
            return;
        end
        if not type_is_struct(ftype) and not type_is_union(ftype) then
            bit_offs = (bit_offs + (size - 1)) & -size; // align to nearest boundary
        end
        if type_is_struct(stype) then
            field.bit_offset = bit_offs;
            bit_offs += size;
        else
            field.bit_offset = 0;
            if size > bit_offs then
                bit_offs = size;
            end
        end
        i += 1;
    end
    if ptr_align then
        bit_offs = (bit_offs + (PTR_BITS-1)) & -PTR_BITS;
    end
    type_set_size(stype, bit_offs);
end

def tt_detect_cycles self, stype in
    // Breadth-first search for cycles.
    var q = Queue[Type&]::new(0);
    var explored = make_set(0, NULL, NULL);

    set_add(explored, stype);
    var fields;
    if type_is_struct(stype) then
        fields = type_struct_fields(stype);
    else
        fields = type_union_fields(stype);
    end
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var ftype = field.type;
        if ftype == stype then // immediate self-reference
            return true;
        end
        if not set_contains(explored, ftype) then
            if type_is_struct(ftype) or type_is_union(ftype) then
                set_add(explored, ftype);
                q.enqueue(ftype);
            end
        end
        i += 1;
    end

    while q.length() != 0 do
        var v = q.dequeue();
        if v == stype then
            return true;
        end
        fields = type_struct_fields(v);
        i = 0; len = fields.length;
        while i < len do
            var field = fields.get(i);
            var ftype = field.type;
            if ftype == stype then
                return true;
            end
            if not set_contains(explored, ftype) then
                if type_is_struct(ftype) or type_is_union(ftype) then
                    set_add(explored, ftype);
                    q.enqueue(ftype);
                end
            end
            i += 1;
        end
    end
    q.delete();
    free_set(explored);
    return false;
end

def tt_check_struct_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var fname = field.name;
        var ftoke = field.token;
        var found = map_find(member_name_map, fname);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", fname);
            print_token_loc(ftoke);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, fname, ftoke);
        i += 1;
    end

    var defs = type_struct_defs(type);
    i = 0; len = defs.length;
    while i < len do
        var def_ = defs.get(i);
        var found = map_find(member_name_map, def_.name);
        if found then
            printf("ERROR: struct `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", def_.name);
            print_token_loc(def_.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, def_.name, def_.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_check_enum_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var enum_vals = type_enum_values(type);
    var i = 0; var len = enum_vals.length;
    while i < len do
        var ev = enum_vals.get(i);
        var found = map_find(member_name_map, ev.name);
        if found then
            printf("ERROR: enum `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", ev.name);
            print_token_loc(ev.token);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, ev.name, ev.token);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_check_union_for_field_name_collisions self, type in
    var member_name_map = make_map(0, cstr_eq, cstr_hash);
    var fields = type_union_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        var fname = field.name;
        var ftoke = field.token;
        var found = map_find(member_name_map, fname);
        if found then
            printf("ERROR: union `");
            tt_print_type_name(self, type);
            printf("` already contains a member named `%s.`\n", fname);
            print_token_loc(ftoke);
            printf("NOTE: it was previously defined here\n");
            print_token_loc(cast(map_pair_val(found), Token&));
            g_Errors += 1;
        end
        map_set(member_name_map, fname, ftoke);
        i += 1;
    end
    free_map(member_name_map);
end

def tt_calculate_structs self in
    assert(self.type_scope.parent == NULL, "Compiler bug: calculating stucts but not at top scope\n");
    var to_calc = Queue[Type&]::new(0);
    var i = 0; var len = self.all_types.length;
    var void = tt_void_type(self);
    while i < len do
        var type = self.all_types.get(i);
        if type_is_generic(type) or type_is_generic_param(type) then
            // skip generics because they aren't concrete types and their concrete instances
            // should also be in this list.
            i += 1;
            continue;
        elif type_is_undefined(type) then
            var name = tt_get_type_name(self, type);
            if name then
                // HACK this is a bit of a hack to allow the FIXME in tt_get_type_or_make_undefined to work.
                var outer = tt_get_type_or_null(self, name);
                if outer and not type_is_undefined(outer) then
                    memcpy(type, outer, __sizeof(Type));
                    continue;
                end
            end
            printf("WARN: type `%s` is still undefined!\n", tt_get_type_name(self, type));
            type_set_size(type, PTR_BITS);
            type_set_kind(type, TypeKind::Reference);
            type_set_deref_type(type, void);
        elif type_is_struct(type) and type_size(type) == TYPE_NEEDS_SIZING then
            to_calc.enqueue(type);
        elif type_is_union(type) and type_size(type) == TYPE_NEEDS_SIZING then
            to_calc.enqueue(type);
        end
        if type_is_struct(type) then
            tt_check_struct_for_field_name_collisions(self, type);
        elif type_is_enum(type) then
            tt_check_enum_for_field_name_collisions(self, type);
        elif type_is_union(type) then
            tt_check_union_for_field_name_collisions(self, type);
        end
        i += 1;
    end

    while to_calc.length() != 0 do
        var type = to_calc.dequeue();
        if tt_detect_cycles(self, type) then
            printf("ERROR: Detected cycles in struct `%s`\n", tt_get_type_name(self, type));
            exit(1);
        end
        tt_calculate_struct(self, type, to_calc);
    end
    to_calc.delete();
end

def tt_instantiate_types self in
end

def tt_print_type_name self, type in
    if type then
        var name = String::new(32);
        _tt_append_type_repr(self, name, type);
        printf("%s", name.cstr());
        name.delete();
    else
        printf("{null}");
    end
end

def scope_resolve_lhs tt: TypeTable&, ast: ast, error: bool -> Type& in
    if ast_kind(ast) == AstK::ScopeResolve then
        var lhs_type = scope_resolve_lhs(tt, ast_lhs(ast), false);
        if not lhs_type then
            if error then
                printf("FIXME: better error message for this: ");
                printf("File \"%s\", line %d\n", __FILE__, __LINE__);
                printf("ERROR: type scope resolution does not resolve.\n");
                print_ast(ast);
                print_ast_src_loc(ast);
                g_Errors += 1;
            end
            return NULL;
        end
        assert(ast_kind(ast_rhs(ast)) == AstK::Ident);
        var name = ast_ident(ast_rhs(ast));
        var scope = type_scope(lhs_type);
        assert(scope);

        var found = map_find(scope.types, name);
        if found then
            return tt_get_type_by_id(tt, cast(map_pair_val(found), int));
        end
        return NULL;
    elif ast_kind(ast) == AstK::Type then
        return ast_type(ast);
    else
        assert(false, "Recursive scope lookup only supports Types or Scope Resolve\n");
        return NULL;
    end
end

def scope_resolve_type tt: TypeTable&, ast: ast, error: bool -> Type& in
    assert(ast_kind(ast) == AstK::ScopeResolve);
    var type: Type&;
    if ast_kind(ast_lhs(ast)) != AstK::Type then
        assert(ast_kind(ast_lhs(ast)) == AstK::ScopeResolve);
        type = scope_resolve_lhs(tt, ast_lhs(ast), error);
        if not type then
            return tt.any_type;
        end
    else
        assert(ast_kind(ast_lhs(ast)) == AstK::Type);
        type = ast_type(ast_lhs(ast));
    end
    assert(ast_kind(ast_rhs(ast)) == AstK::Ident);

    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var fields = type_struct_fields(type);
        var i = 0; var len = fields.length;
        while i < len do
            var field = fields.get(i);
            if cstr_eq(member, field.name) then
                return field.type;
            end
            i += 1;
        end

        var defs = type_struct_defs(type);
        i = 0; len = defs.length;
        while i < len do
            var def_ = defs.get(i);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_type;
            end
            i += 1;
        end
        var scope = type_scope(type);
        assert(scope);
        var found = map_find(scope.types, member);
        if found then
            return tt_get_type_by_id(tt, cast(map_pair_val(found), int));
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_type)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return tt_any_type(tt);
    elif type_is_enum(type) then
        return type;
    elif type_is_union(type) then
        assert(false, "scope resolve for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return tt.any_type;
end

def scope_resolve_def tt: TypeTable&, ast: ast, error: bool -> Symbol& in
    assert(ast_kind(ast) == AstK::ScopeResolve);
    var type: Type&;
    if ast_kind(ast_lhs(ast)) != AstK::Type then
        assert(ast_kind(ast_lhs(ast)) == AstK::ScopeResolve);
        type = scope_resolve_lhs(tt, ast_lhs(ast), error);
        if not type then
            return NULL;
        end
    else
        assert(ast_kind(ast_lhs(ast)) == AstK::Type);
        type = ast_type(ast_lhs(ast));
    end
    assert(ast_kind(ast_rhs(ast)) == AstK::Ident);

    if type_is_struct(type) then
        var member = ast_ident(ast_rhs(ast));
        var defs = type_struct_defs(type);
        var i = 0; var len = defs.length;
        while i < len do
            var def_ = defs.get(i);
            var def_name = symbol_name(def_);
            if cstr_eq(member, def_name) then
                var def_type = symbol_type(def_);
                assert(def_type);
                assert(type_is_def(def_type));
                return def_;
            end
            i += 1;
        end
        if error then
            printf("ERROR: type `");
            tt_print_type_name(tt, type);
            printf("` has no member `%s.` (scope_resolve_def)\n", member);
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        return NULL;
    elif type_is_enum(type) then
        return NULL;
    elif type_is_union(type) then
        assert(false, "scope_resolve_def for unions not implemented yet.\n");
    elif error then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    return NULL;
end
