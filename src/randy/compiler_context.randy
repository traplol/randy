
const TCOMPILER_CONTEXT_out_lines     = 0;  // string Vector&
const TCOMPILER_CONTEXT_proc_src_name = 8;
const TCOMPILER_CONTEXT_proc_name     = 16;
const TCOMPILER_CONTEXT_proc_params   = 24;
const TCOMPILER_CONTEXT_proc_locals   = 32;
const TCOMPILER_CONTEXT_file_map      = 40; // (cstr, int) : path -> id
const TCOMPILER_CONTEXT_nodebug       = 48; // bool
const sizeof_TCOMPILER_CONTEXT        = 56;

proc make_compiler_context debug: bool -> compiler_context in
    var self = malloc(sizeof_TCOMPILER_CONTEXT);
    var lines = make_vector(0);
    u64!(self + TCOMPILER_CONTEXT_out_lines, lines);
    u64!(self + TCOMPILER_CONTEXT_proc_src_name, NULL);
    u64!(self + TCOMPILER_CONTEXT_proc_name, NULL);
    u64!(self + TCOMPILER_CONTEXT_proc_params, NULL);
    u64!(self + TCOMPILER_CONTEXT_proc_locals, NULL);
    u64!(self + TCOMPILER_CONTEXT_file_map, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TCOMPILER_CONTEXT_nodebug, not debug);
    return cast(self, compiler_context);
end

proc compiler_context_file_map self: compiler_context in
    return cast(u64@(self + TCOMPILER_CONTEXT_file_map), map);
end
proc compiler_context_lines self: compiler_context in
    return cast(u64@(self + TCOMPILER_CONTEXT_out_lines), Vector&);
end
proc compiler_context_nodebug self: compiler_context in
    return cast(u64@(self + TCOMPILER_CONTEXT_nodebug), bool);
end

proc compiler_context_get_file_id self: compiler_context, path: cstr in
    var found = map_find(compiler_context_file_map(self), path);
    return cast(map_pair_val(found), int);
end

proc compiler_context_add_file self:compiler_context, path: cstr, id: int in
    map_set(compiler_context_file_map(self), path, id);
end

proc cc_print_lines self: compiler_context in
    var lines = u64@(self + TCOMPILER_CONTEXT_out_lines);
    var len = lines.length;
    var i = 0;
    while i < len do
        printf("%s\n", string_cstr(vector_get(lines, i)));
        i += 1;
    end
end

proc cc_out self: compiler_context, cstr: cstr in
    var lines = cast(u64@(self + TCOMPILER_CONTEXT_out_lines), Vector&);
    vector_push(lines, string_from_cstr(cstr));
    //printf("%s\n", cstr);
end

proc cc_out_global self: compiler_context, cstr: cstr in
    var str = make_string(20);
    string_append_cstr(str, "    .global ");
    string_append_cstr(str, cstr);
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_extern self: compiler_context, cstr: cstr in
    var str = make_string(20);
    string_append_cstr(str, ".extern ");
    string_append_cstr(str, cstr);
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_label self: compiler_context, cstr: cstr in
    var str = make_string(20);
    string_append_cstr(str, cstr);
    string_push(str, ':');
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_string self: compiler_context, string: String& in
    var str = make_string(20);
    string_append_cstr(str, ".byte ");
    var i = 0;
    var len = string.length;
    while i < len do
        string_append_int(str, string_get(string, i));
        i += 1;
        if i < len then
            string_append_cstr(str, ", ");
        end
    end
    if len > 0 then
        string_append_cstr(str, ", 0");
    else
        string_append_cstr(str, "0");
    end
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_src_loc self: compiler_context, src_loc: SrcLoc& in
    if not src_loc then
        return;
    end
    if compiler_context_nodebug(self) then
        return;
    end
    var str = make_string(20);
    var id = compiler_context_get_file_id(self, src_loc_filename(src_loc));
    string_append_cstr(str, "    .loc ");
    string_append_int(str, id);
    string_push(str, ' ');
    string_append_int(str, src_loc_line(src_loc));
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_file self: compiler_context, idx: int, filename: cstr in
    var str = make_string(20);
    string_append_cstr(str, "    .file ");
    string_append_int(str, idx);
    string_append_cstr(str, " \"");
    string_append_cstr(str, filename);
    string_push(str, '"');
    cc_out(self, string_cstr(str));
    free_string(str);
end

proc cc_out_files irctx: ir_context, cctx: compiler_context in
    var files = ir_files(irctx);
    var i = 0;
    while i < files.length do
        cc_out_file(cctx, i, vector_get(files, i));
        compiler_context_add_file(cctx, vector_get(files, i), i);
        i += 1;
    end
end

proc cc_out_instructions irctx: ir_context, cctx: compiler_context in
    var instructions = ir_instructions(irctx);
    var i = 0;
    while i < instructions.length do
        x86_64_emit_instruction(cctx, vector_get(instructions, i));
        i += 1;
    end
end

proc cc_out_externs irctx: ir_context, cctx: compiler_context in
    var externs = ir_externs(irctx);
    var cur_extern = map_begin(externs);
    var end_extern = map_end(externs);
    while cur_extern != end_extern do
        cc_out_extern(cctx, map_pair_key(cur_extern));
        cur_extern = map_next(externs, cur_extern);
    end
end

proc cc_out_data_section irctx: ir_context, cctx: compiler_context in
    cc_out(cctx, ".data");
    cc_out(cctx, ".align 8");
    cc_out(cctx, "__argc__: .quad 0");
    cc_out(cctx, "__argv__: .quad 0");

    var globals = ir_globals(irctx);
    var i = 0; var len = globals.length;
    var str = make_string(0);
    while i < len do
        string_reset(str);
        var gi = vector_get(globals, i);
        var kind = global_info_kind(gi);
        var label = global_info_label(gi);
        var value = global_info_value(gi);
        if kind == GIK_String then
            string_append_cstr(str, label);
            string_append_cstr(str, ": .quad ");
            string_append_cstr(str, value);
            cc_out(cctx, string_cstr(str));
        elif kind == GIK_Integer then
            string_append_cstr(str, label);
            string_append_cstr(str, ": .quad ");
            string_append_int(str, cast(value, int));
            cc_out(cctx, string_cstr(str));
        else
            NYI_ERR(__FILE__, __LINE__, "cc_out_data_section: unknown global kind");
        end
        i += 1;
    end

    cc_out(cctx, ".section .rodata, \"a\"");
    var strings = ir_strings(irctx);
    var cur_string = map_begin(strings);
    var end_string = map_end(strings);
    while cur_string != end_string do
        cc_out(cctx, ".align 8");
        cc_out_label(cctx, map_pair_val(cur_string));
        cc_out_string(cctx, map_pair_key(cur_string));
        cur_string = map_next(strings, cur_string);
    end
end

proc cc_lines_to_file cctx: compiler_context, path: cstr in
    var fd = open_for_write(path);
    if fd < 0 then
        printf("Open for write failed with (%d), path was: '%s'\n", fd, path);
        return false;
    end
    var i = 0; var j = 0;
    var BUFLEN = 4096;
    var buffer = malloc(BUFLEN);
    var buffer_end = buffer + BUFLEN;
    var p = buffer;

    var lines = compiler_context_lines(cctx);
    var num_lines = lines.length;
    var line; var line_len;
    while i < num_lines do
        line = cast(vector_get(lines, i), String&);
        j = 0; line_len = line.length;
        while j < line_len do
            if p == buffer_end then
                write_file(fd, buffer, BUFLEN);
                p = buffer;
            end
            u8!(p, string_get(line, j));
            p += 1;
            j += 1;
        end
        if p == buffer_end then
            write_file(fd, buffer, BUFLEN);
            p = buffer;
        end
        u8!(p, '\n');
        p += 1;
        i += 1;
    end
    if p != buffer then
        write_file(fd, buffer, p - buffer);
    end
    close(fd);
    free(buffer);
    return true;
end

proc cc_out_start self: compiler_context, main_proc: cstr, exit_proc: cstr in
    x86_64_emit_start(self, main_proc, exit_proc);
end
