
const IRK_GetLocal      = 0;
const IRK_PushLabel     = 1;
const IRK_PushInt       = 2;
const IRK_AllocTemps    = 3;
const IRK_FreeTemps     = 4;
const IRK_StoreTemp     = 5;
const IRK_SetArgTemp    = 6;
const IRK_Call          = 7;
const IRK_PopCall       = 8;
//const IRK_Plus          = 9;
const IRK_OpAdd         = 10;
const IRK_OpSub         = 11;
const IRK_OpMul         = 12;
const IRK_OpDiv         = 13;
const IRK_OpMod         = 14;
const IRK_OpEq          = 15;
const IRK_OpNotEq       = 16;
const IRK_OpLess        = 17;
const IRK_OpLessEq      = 18;
const IRK_OpGreater     = 19;
const IRK_OpGreaterEq   = 20;
const IRK_PopReturn     = 21;
const IRK_ReturnVoid    = 22;
const IRK_SetLocal      = 23;
const IRK_NewProc       = 24;
const IRK_SetLocalArg   = 25;
const IRK_CloseProc     = 26;
const IRK_GotoTopFalse  = 27;
const IRK_GotoTopTrue   = 28;
const IRK_GotoFalse     = 29;
const IRK_Goto          = 30;
const IRK_Label         = 31;
const IRK_PtrRead       = 32;
const IRK_PtrWrite      = 33;
const IRK_BitNot        = 34;
const IRK_LogicNot      = 35;
//const IRK_LogicAnd      = 36;
//const IRK_LogicOr       = 37;
const IRK_InlineAsm     = 38;
const IRK_LazyIdent     = 39;
const IRK_CallLazyIdent = 40;

proc ir_instr_kind_cstr k in
    if k == IRK_GetLocal then return "IRK_GetLocal"; end
    if k == IRK_PushLabel then return "IRK_PushLabel"; end
    if k == IRK_PushInt then return "IRK_PushInt"; end
    if k == IRK_AllocTemps then return "IRK_AllocTemps"; end
    if k == IRK_FreeTemps then return "IRK_FreeTemps"; end
    if k == IRK_StoreTemp then return "IRK_StoreTemp"; end
    if k == IRK_SetArgTemp then return "IRK_SetArgTemp"; end
    if k == IRK_Call then return "IRK_Call"; end
    if k == IRK_PopCall then return "IRK_PopCall"; end
    if k == IRK_OpAdd then return "IRK_OpAdd"; end
    if k == IRK_OpSub then return "IRK_OpSub"; end
    if k == IRK_OpMul then return "IRK_OpMul"; end
    if k == IRK_OpDiv then return "IRK_OpDiv"; end
    if k == IRK_OpMod then return "IRK_OpMod"; end
    if k == IRK_OpEq then return "IRK_OpEq"; end
    if k == IRK_OpNotEq then return "IRK_OpNotEq"; end
    if k == IRK_OpLess then return "IRK_OpLess"; end
    if k == IRK_OpLessEq then return "IRK_OpLessEq"; end
    if k == IRK_OpGreater then return "IRK_OpGreater"; end
    if k == IRK_OpGreaterEq then return "IRK_OpGreaterEq"; end
    if k == IRK_PopReturn then return "IRK_PopReturn"; end
    if k == IRK_ReturnVoid then return "IRK_ReturnVoid"; end
    if k == IRK_SetLocal then return "IRK_SetLocal"; end
    if k == IRK_NewProc then return "IRK_NewProc"; end
    if k == IRK_SetLocalArg then return "IRK_SetLocalArg"; end
    if k == IRK_CloseProc then return "IRK_CloseProc"; end
    if k == IRK_GotoTopFalse then return "IRK_GotoTopFalse"; end
    if k == IRK_GotoTopTrue then return "IRK_GotoTopTrue"; end
    if k == IRK_GotoFalse then return "IRK_GotoFalse"; end
    if k == IRK_Goto then return "IRK_Goto"; end
    if k == IRK_Label then return "IRK_Label"; end
    if k == IRK_PtrRead then return "IRK_PtrRead"; end
    if k == IRK_PtrWrite then return "IRK_PtrWrite"; end
    if k == IRK_BitNot then return "IRK_BitNot"; end
    if k == IRK_LogicNot then return "IRK_LogicNot"; end
    if k == IRK_InlineAsm then return "IRK_InlineAsm"; end
    if k == IRK_LazyIdent then return "IRK_LazyIdent"; end
    if k == IRK_CallLazyIdent then return "IRK_CallLazyIdent"; end
    return "IRK_OUT_OF_RANGE";
    end


const TIR_INSTR_kind     = 0;
const TIR_INSTR_src_loc  = 8;

const TIR_INSTR_name     = 16;
const TIR_INSTR_ident    = 16;
const TIR_INSTR_local    = 16;
const TIR_INSTR_label    = 16;

const TIR_INSTR_n        = 24;
const TIR_INSTR_nargs    = 24;
const TIR_INSTR_params   = 24;
const TIR_INSTR_size     = 24;

const TIR_INSTR_value    = 32;
const TIR_INSTR_varargs  = 32;
const TIR_INSTR_asm      = 32;
const TIR_INSTR_arg      = 32;
const TIR_INSTR_src_name = 32;

const TIR_INSTR_locals   = 40;
const sizeof_TIR_INSTR   = 48;

proc ir_instr_kind self in return u64@(self + TIR_INSTR_kind); end
proc ir_instr_src_loc self in return u64@(self + TIR_INSTR_src_loc); end
proc ir_instr_name self in return u64@(self + TIR_INSTR_name); end
proc ir_instr_ident self in return u64@(self + TIR_INSTR_ident); end
proc ir_instr_local self in return u64@(self + TIR_INSTR_local); end
proc ir_instr_label self in return u64@(self + TIR_INSTR_label); end
proc ir_instr_n self in return u64@(self + TIR_INSTR_n); end
proc ir_instr_nargs self in return u64@(self + TIR_INSTR_nargs); end
proc ir_instr_params self in return u64@(self + TIR_INSTR_params); end
proc ir_instr_size self in return u64@(self + TIR_INSTR_size); end
proc ir_instr_value self in return u64@(self + TIR_INSTR_value); end
proc ir_instr_varargs self in return u64@(self + TIR_INSTR_varargs); end
proc ir_instr_asm self in return u64@(self + TIR_INSTR_asm); end
proc ir_instr_arg self in return u64@(self + TIR_INSTR_arg); end
proc ir_instr_src_name self in return u64@(self + TIR_INSTR_src_name); end
proc ir_instr_locals self in return u64@(self + TIR_INSTR_locals); end

proc make_ir_alloc_temps src_loc, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_AllocTemps);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_n, n);
    return self;
end
proc make_ir_call src_loc, label, varargs in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Call);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    u64!(self + TIR_INSTR_varargs, varargs);
    return self;
end
proc make_ir_call_lazy_ident src_loc, ident, nargs in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_CallLazyIdent);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_ident, ident);
    u64!(self + TIR_INSTR_nargs, nargs);
    return self;
end
proc make_ir_close_proc src_loc, name in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_CloseProc);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_name, name);
    return self;
end
proc make_ir_free_temps src_loc, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_FreeTemps);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_n, n);
    return self;
end
proc make_ir_get_local src_loc, local, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GetLocal);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, n);
    return self;
end
proc make_ir_goto src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Goto);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_goto_false src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoFalse);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_goto_top_false src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoTopFalse);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_goto_top_true src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoTopTrue);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_inline_asm src_loc, name, asmcode in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_InlineAsm);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_name, name);
    u64!(self + TIR_INSTR_asm, asmcode);
    return self;
end
proc make_ir_label src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Label);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_logic_not src_loc in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_LogicNot);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    return self;
end
proc make_ir_new_proc src_loc, src_name, name, params, locals in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_NewProc);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_src_name, src_name);
    u64!(self + TIR_INSTR_name, name);
    u64!(self + TIR_INSTR_params, params);
    u64!(self + TIR_INSTR_locals, locals);
    return self;
end
proc make_ir_simple_op src_loc, op in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, op);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    return self;
end
proc make_ir_pop_call src_loc in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PopCall);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    return self;
end
proc make_ir_pop_return src_loc in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PopReturn);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    return self;
end
proc make_ir_ptr_read src_loc, size in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrRead);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_size, size);
    return self;
end
proc make_ir_ptr_write src_loc, size in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrWrite);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_size, size);
    return self;
end
proc make_ir_push_int src_loc, value in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PushInt);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_value, value);
    return self;
end
proc make_ir_push_label src_loc, label in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PushLabel);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_label, label);
    return self;
end
proc make_ir_return_void src_loc in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_ReturnVoid);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    return self;
end
proc make_ir_set_arg_temp src_loc, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetArgTemp);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_n, n);
    return self;
end
proc make_ir_set_local src_loc, local, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetLocal);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, n);
    return self;
end
proc make_ir_set_local_arg src_loc, local, arg in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetLocalArg);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_arg, arg);
    return self;
end
proc make_ir_store_temp src_loc, n in
    var self = malloc(sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_StoreTemp);
    u64!(self + TIR_INSTR_src_loc, src_loc);
    u64!(self + TIR_INSTR_n, n);
    return self;
end

const TIR_CONTEXT_instructions =  0; // ir_instruction vector
const TIR_CONTEXT_label_id     =  8; // int
const TIR_CONTEXT_strings      = 16; // (string, string) map
const TIR_CONTEXT_externs      = 24; // (string, string) map
const TIR_CONTEXT_labels       = 32; // string set
const TIR_CONTEXT_constants    = 40; // (string, Union(string, int)) map
const TIR_CONTEXT_src_locs     = 48; // src_loc vector
const TIR_CONTEXT_file_map     = 56; // (string, int) map
const TIR_CONTEXT_files        = 64; // string vector
const TIR_CONTEXT_file_idx     = 72; // int
const sizeof_TIR_CONTEXT       = 80;

proc make_ir_context in
    var self = malloc(sizeof_TIR_CONTEXT);
    u64!(self + TIR_CONTEXT_instructions, make_vector(0));
    u64!(self + TIR_CONTEXT_label_id, 0);
    u64!(self + TIR_CONTEXT_strings, make_map(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_externs, make_map(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_labels, make_set(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_constants, make_map(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_src_locs, make_vector(0));
    u64!(self + TIR_CONTEXT_file_map, make_map(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_files, make_vector(0));
    u64!(self + TIR_CONTEXT_file_idx, 0);
    return self;
end

proc ir_instructions self in return u64@(self + TIR_CONTEXT_instructions); end
proc ir_strings self in return u64@(self + TIR_CONTEXT_strings); end
proc ir_externs self in return u64@(self + TIR_CONTEXT_externs); end
proc ir_labels self in return u64@(self + TIR_CONTEXT_labels); end
proc ir_constants self in return u64@(self + TIR_CONTEXT_constants); end
proc ir_src_locs self in return u64@(self + TIR_CONTEXT_src_locs); end
proc ir_file_map self in return u64@(self + TIR_CONTEXT_file_map); end
proc ir_files self in return u64@(self + TIR_CONTEXT_files); end
proc ir_append self, insn in
    var vec = ir_instructions(self);
    vector_push(vec, insn);
end

proc ir_string_label self, string in
    var strings = ir_strings(self);
    var found = map_find(strings, string);
    if found then
        return map_pair_val(found);
    end

    var label_id = u64@(self + TIR_CONTEXT_label_id);
    u64!(self + TIR_CONTEXT_label_id, label_id + 1);

    var label = make_string(0);
    string_append_cstr(label, "__string__");
    string_append_int(label, label_id);

    set_add(ir_labels(self), label);
    map_set(strings, string, label);

    return label;
end

proc ir_string_bytes self in
    NYI_ERR("ir_string_bytes");
end

proc check_ast_kind expect, ast in
    var actual = ast_kind(ast);
    if expect != actual then
        printf("check_ast_kind failed: expected %s, actual was %s\n",
            ast_kind_cstr(expect),
            ast_kind_cstr(actual));
        abort();
    end
end
        
proc ir_emit_ident self, ast in NYI_ERR("ir_emit_ident"); end
proc ir_emit_integer self, ast in NYI_ERR("ir_emit_integer"); end
proc ir_emit_string self, ast in NYI_ERR("ir_emit_string"); end
proc ir_emit_call self, ast in NYI_ERR("ir_emit_call"); end
proc ir_emit_binop self, ast in NYI_ERR("ir_emit_binop"); end
proc ir_emit_return self, ast in NYI_ERR("ir_emit_return"); end
proc ir_emit_var_decl self, ast in NYI_ERR("ir_emit_var_decl"); end
proc ir_emit_var_assign self, ast in NYI_ERR("ir_emit_var_assign"); end
proc ir_emit_assign self, ast in NYI_ERR("ir_emit_assign"); end
proc ir_emit_procedure self, ast in NYI_ERR("ir_emit_procedure"); end
proc ir_emit_if_else self, ast in NYI_ERR("ir_emit_if_else"); end
proc ir_emit_while self, ast in NYI_ERR("ir_emit_while"); end
proc ir_emit_pointer_op self, ast in NYI_ERR("ir_emit_pointer_op"); end
proc ir_emit_prefix_op self, ast in NYI_ERR("ir_emit_prefix_op"); end
proc ir_emit_const self, ast in NYI_ERR("ir_emit_const"); end
proc ir_emit_extern self, ast in NYI_ERR("ir_emit_extern"); end
proc ir_emit_inline_asm self, ast in
    check_ast_kind(AstK_InlineAsm, ast);
    var asm_name = ast_ident(ast);
    var asm_code = ast_asm(ast);
    ir_append(self, make_ir_inline_asm(ast_src_loc(ast), asm_name, asm_code));
end

proc ir_compile self, ast in
    var k = ast_kind(ast);
    if k == AstK_Ident then ir_emit_ident(self, ast);
    else if k == AstK_Integer then ir_emit_integer(self, ast);
    else if k == AstK_String then ir_emit_string(self, ast);
    else if k == AstK_Call then ir_emit_call(self, ast);
    else if k == AstK_BinOp then ir_emit_binop(self, ast);
    else if k == AstK_Return then ir_emit_return(self, ast);
    else if k == AstK_VarDecl then ir_emit_var_decl(self, ast);
    else if k == AstK_VarAssign then ir_emit_var_assign(self, ast);
    else if k == AstK_Assign then ir_emit_assign(self, ast);
    else if k == AstK_Procedure then ir_emit_procedure(self, ast);
    else if k == AstK_IfElse then ir_emit_if_else(self, ast);
    else if k == AstK_While then ir_emit_while(self, ast);
    else if k == AstK_PointerOp then ir_emit_pointer_op(self, ast);
    else if k == AstK_Prefix then ir_emit_prefix_op(self, ast);
    else if k == AstK_Const then ir_emit_const(self, ast);
    else if k == AstK_Extern then ir_emit_extern(self, ast);
    else if k == AstK_InlineAsm then ir_emit_inline_asm(self, ast);
    else
        printf("Unknown AstK: %d\n", k);
        abort();
    end
end