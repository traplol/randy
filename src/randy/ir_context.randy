
const IRK_GetLocal      = 0;
const IRK_PushLabel     = 1;
const IRK_PushInt       = 2;
const IRK_AllocTemps    = 3;
const IRK_FreeTemps     = 4;
const IRK_StoreTemp     = 5;
const IRK_SetArgTemp    = 6;
const IRK_Call          = 7;
const IRK_PopCall       = 8;
//const IRK_Plus          = 9;
const IRK_OpAdd         = 10;
const IRK_OpSub         = 11;
const IRK_OpMul         = 12;
const IRK_OpDiv         = 13;
const IRK_OpMod         = 14;
const IRK_OpEq          = 15;
const IRK_OpNotEq       = 16;
const IRK_OpLess        = 17;
const IRK_OpLessEq      = 18;
const IRK_OpGreater     = 19;
const IRK_OpGreaterEq   = 20;
const IRK_PopReturn     = 21;
const IRK_ReturnVoid    = 22;
const IRK_SetLocal      = 23;
const IRK_NewDef       = 24;
const IRK_SetLocalArg   = 25;
const IRK_CloseDef     = 26;
const IRK_GotoTopFalse  = 27;
const IRK_GotoTopTrue   = 28;
const IRK_GotoFalse     = 29;
const IRK_Goto          = 30;
const IRK_Label         = 31;
const IRK_PtrRead       = 32;
const IRK_PtrWrite      = 33;
const IRK_BitNot        = 34;
const IRK_LogicNot      = 35;
//const IRK_LogicAnd      = 36;
//const IRK_LogicOr       = 37;
const IRK_InlineAsm     = 38;
const IRK_LazyIdent     = 39;
const IRK_CallLazyIdent = 40;
const IRK_DropTop       = 41;
const IRK_SetGlobal     = 42;
const IRK_GetGlobal     = 43;
const IRK_Negative      = 44;
const IRK_OpBitXOR      = 45;
const IRK_OpBitAND      = 46;
const IRK_OpBitOR       = 47;
const IRK_OpBitShiftL   = 48;
const IRK_OpBitShiftR   = 49;
const IRK_ScopeOpen     = 50;
const IRK_ScopeClose    = 51;
const IRK_PtrCopy       = 52;
const IRK_PtrOffset     = 53;
const IRK_RefLocal      = 54;
const IRK_RefGlobal     = 55;

def ir_instr_kind_cstr k: int -> cstr in
    if k == IRK_GetLocal then return "IRK_GetLocal"; end
    if k == IRK_PushLabel then return "IRK_PushLabel"; end
    if k == IRK_PushInt then return "IRK_PushInt"; end
    if k == IRK_AllocTemps then return "IRK_AllocTemps"; end
    if k == IRK_FreeTemps then return "IRK_FreeTemps"; end
    if k == IRK_StoreTemp then return "IRK_StoreTemp"; end
    if k == IRK_SetArgTemp then return "IRK_SetArgTemp"; end
    if k == IRK_Call then return "IRK_Call"; end
    if k == IRK_PopCall then return "IRK_PopCall"; end
    if k == IRK_OpAdd then return "IRK_OpAdd"; end
    if k == IRK_OpSub then return "IRK_OpSub"; end
    if k == IRK_OpMul then return "IRK_OpMul"; end
    if k == IRK_OpDiv then return "IRK_OpDiv"; end
    if k == IRK_OpMod then return "IRK_OpMod"; end
    if k == IRK_OpEq then return "IRK_OpEq"; end
    if k == IRK_OpNotEq then return "IRK_OpNotEq"; end
    if k == IRK_OpLess then return "IRK_OpLess"; end
    if k == IRK_OpLessEq then return "IRK_OpLessEq"; end
    if k == IRK_OpGreater then return "IRK_OpGreater"; end
    if k == IRK_OpGreaterEq then return "IRK_OpGreaterEq"; end
    if k == IRK_PopReturn then return "IRK_PopReturn"; end
    if k == IRK_ReturnVoid then return "IRK_ReturnVoid"; end
    if k == IRK_SetLocal then return "IRK_SetLocal"; end
    if k == IRK_NewDef then return "IRK_NewDef"; end
    if k == IRK_SetLocalArg then return "IRK_SetLocalArg"; end
    if k == IRK_CloseDef then return "IRK_CloseDef"; end
    if k == IRK_GotoTopFalse then return "IRK_GotoTopFalse"; end
    if k == IRK_GotoTopTrue then return "IRK_GotoTopTrue"; end
    if k == IRK_GotoFalse then return "IRK_GotoFalse"; end
    if k == IRK_Goto then return "IRK_Goto"; end
    if k == IRK_Label then return "IRK_Label"; end
    if k == IRK_PtrRead then return "IRK_PtrRead"; end
    if k == IRK_PtrWrite then return "IRK_PtrWrite"; end
    if k == IRK_BitNot then return "IRK_BitNot"; end
    if k == IRK_LogicNot then return "IRK_LogicNot"; end
    if k == IRK_InlineAsm then return "IRK_InlineAsm"; end
    if k == IRK_LazyIdent then return "IRK_LazyIdent"; end
    if k == IRK_CallLazyIdent then return "IRK_CallLazyIdent"; end
    if k == IRK_DropTop then return "IRK_DropTop"; end
    if k == IRK_SetGlobal then return "IRK_SetGlobal"; end
    if k == IRK_GetGlobal then return "IRK_GetGlobal"; end
    if k == IRK_Negative then return "IRK_Negative"; end
    if k == IRK_OpBitXOR then return "IRK_OpBitXOR"; end
    if k == IRK_OpBitAND then return "IRK_OpBitAND"; end
    if k == IRK_OpBitOR then return "IRK_OpBitOR"; end
    if k == IRK_OpBitShiftL then return "IRK_OpBitShiftL"; end
    if k == IRK_OpBitShiftR then return "IRK_OpBitShiftR"; end
    if k == IRK_ScopeOpen then return "IRK_ScopeOpen"; end
    if k == IRK_ScopeClose then return "IRK_ScopeClose"; end
    if k == IRK_PtrCopy then return "IRK_PtrCopy"; end
    if k == IRK_PtrOffset then return "IRK_PtrOffset"; end
    if k == IRK_RefLocal then return "IRK_RefLocal"; end
    if k == IRK_RefGlobal then return "IRK_RefGlobal"; end
    return "IRK_OUT_OF_RANGE";
end

const TIR_INSTR_kind     = 0;
const TIR_INSTR_src_loc  = 8;

const TIR_INSTR_name     = 16;
const TIR_INSTR_ident    = 16;
const TIR_INSTR_local    = 16;
const TIR_INSTR_label    = 16;

const TIR_INSTR_n        = 24;
const TIR_INSTR_nargs    = 24;
const TIR_INSTR_params   = 24;
const TIR_INSTR_size     = 24;

const TIR_INSTR_value    = 32;
const TIR_INSTR_symbol   = 32;
const TIR_INSTR_varargs  = 32;
const TIR_INSTR_asm      = 32;
const TIR_INSTR_arg      = 32;
const TIR_INSTR_src_name = 32;
const TIR_INSTR_offset   = 32;

const TIR_INSTR_nlocals  = 40;

const TIR_INSTR_expr_size = 48;
const TIR_INSTR_expr_offs = 56;
const sizeof_TIR_INSTR   = 64;

def ir_instr_kind self: ir_instr in return cast(u64@(self + TIR_INSTR_kind), int); end
def ir_instr_src_loc self: ir_instr in return cast(u64@(self + TIR_INSTR_src_loc), SrcLoc&); end
def ir_instr_name self: ir_instr in return cast(u64@(self + TIR_INSTR_name), cstr); end
def ir_instr_ident self: ir_instr in return cast(u64@(self + TIR_INSTR_ident), Token&); end
def ir_instr_local self: ir_instr in return cast(u64@(self + TIR_INSTR_local), int); end
def ir_instr_label self: ir_instr in return cast(u64@(self + TIR_INSTR_label), cstr); end
def ir_instr_n self: ir_instr in return cast(u64@(self + TIR_INSTR_n), int); end
def ir_instr_nargs self: ir_instr in return cast(u64@(self + TIR_INSTR_nargs), int); end
def ir_instr_params self: ir_instr in return cast(u64@(self + TIR_INSTR_params), Vector&); end
def ir_instr_size self: ir_instr in return cast(u64@(self + TIR_INSTR_size), int); end
def ir_instr_value self: ir_instr in return cast(u64@(self + TIR_INSTR_value), int); end
def ir_instr_varargs self: ir_instr in return cast(u64@(self + TIR_INSTR_varargs), bool); end
def ir_instr_asm self: ir_instr in return cast(u64@(self + TIR_INSTR_asm), cstr); end
def ir_instr_arg self: ir_instr in return cast(u64@(self + TIR_INSTR_arg), int); end
def ir_instr_src_name self: ir_instr in return cast(u64@(self + TIR_INSTR_src_name), cstr); end
def ir_instr_nlocals self: ir_instr in return cast(u64@(self + TIR_INSTR_nlocals), int); end
def ir_instr_offset self: ir_instr in return cast(u64@(self + TIR_INSTR_offset), int); end
def ir_instr_expr_size self: ir_instr in return cast(u64@(self + TIR_INSTR_expr_size), int); end
def ir_instr_expr_offs self: ir_instr in return cast(u64@(self + TIR_INSTR_expr_offs), int); end
def ir_instr_symbol self: ir_instr in return cast(u64@(self + TIR_INSTR_symbol), Symbol&); end

def make_ir_alloc_temps n -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_AllocTemps);
    u64!(self + TIR_INSTR_n, n);
    return cast(self, ir_instr);
end
def make_ir_call label, varargs -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Call);
    u64!(self + TIR_INSTR_label, label);
    u64!(self + TIR_INSTR_varargs, varargs);
    return cast(self, ir_instr);
end
def make_ir_lazy_ident ident, symbol -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_LazyIdent);
    u64!(self + TIR_INSTR_ident, ident);
    u64!(self + TIR_INSTR_symbol, symbol);
    return cast(self, ir_instr);
end
def make_ir_call_lazy_ident ident, symbol, nargs -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_CallLazyIdent);
    u64!(self + TIR_INSTR_ident, ident);
    u64!(self + TIR_INSTR_symbol, symbol);
    u64!(self + TIR_INSTR_nargs, nargs);
    return cast(self, ir_instr);
end
def make_ir_close_def src_name, name -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_CloseDef);
    u64!(self + TIR_INSTR_src_name, src_name);
    u64!(self + TIR_INSTR_name, name);
    return cast(self, ir_instr);
end
def make_ir_free_temps n -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_FreeTemps);
    u64!(self + TIR_INSTR_n, n);
    return cast(self, ir_instr);
end
def make_ir_get_local local, n, offs: int -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GetLocal);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, n);
    u64!(self + TIR_INSTR_expr_offs, offs);
    return cast(self, ir_instr);
end
def make_ir_ref_local local, n, offs: int -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_RefLocal);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, n);
    u64!(self + TIR_INSTR_expr_offs, offs);
    return cast(self, ir_instr);
end
def make_ir_goto label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Goto);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_goto_false label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoFalse);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_goto_top_false label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoTopFalse);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_goto_top_true label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GotoTopTrue);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_inline_asm name, asmcode -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_InlineAsm);
    u64!(self + TIR_INSTR_name, name);
    u64!(self + TIR_INSTR_asm, asmcode);
    return cast(self, ir_instr);
end
def make_ir_label label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Label);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_bit_not -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_BitNot);
    return cast(self, ir_instr);
end
def make_ir_logic_not -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_LogicNot);
    return cast(self, ir_instr);
end
def make_ir_negative -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_Negative);
    return cast(self, ir_instr);
end
def make_ir_scope_open -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_ScopeOpen);
    return cast(self, ir_instr);
end
def make_ir_scope_close -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_ScopeClose);
    return cast(self, ir_instr);
end
def make_ir_new_def src_name, name, params -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_NewDef);
    u64!(self + TIR_INSTR_src_name, src_name);
    u64!(self + TIR_INSTR_name, name);
    u64!(self + TIR_INSTR_params, params);
    return cast(self, ir_instr);
end
def make_ir_simple_op op -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, op);
    return cast(self, ir_instr);
end
def make_ir_pop_call -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PopCall);
    return cast(self, ir_instr);
end
def make_ir_pop_return -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PopReturn);
    return cast(self, ir_instr);
end
def make_ir_ptr_read size -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrRead);
    u64!(self + TIR_INSTR_size, size);
    return cast(self, ir_instr);
end
def make_ir_ptr_write size -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrWrite);
    u64!(self + TIR_INSTR_size, size);
    return cast(self, ir_instr);
end
def make_ir_ptr_copy size -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrCopy);
    u64!(self + TIR_INSTR_size, size);
    return cast(self, ir_instr);
end
def make_ir_ptr_offs offset -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PtrOffset);
    u64!(self + TIR_INSTR_offset, offset);
    return cast(self, ir_instr);
end
def make_ir_push_int value -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PushInt);
    u64!(self + TIR_INSTR_value, value);
    return cast(self, ir_instr);
end
def make_ir_push_label label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_PushLabel);
    u64!(self + TIR_INSTR_label, label);
    return cast(self, ir_instr);
end
def make_ir_return_void -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_ReturnVoid);
    return cast(self, ir_instr);
end
def make_ir_set_arg_temp n -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetArgTemp);
    u64!(self + TIR_INSTR_n, n);
    return cast(self, ir_instr);
end
def make_ir_set_local local, n, offs: int -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetLocal);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, n);
    u64!(self + TIR_INSTR_expr_offs, offs);
    return cast(self, ir_instr);
end
def make_ir_set_local_arg local, local_n, arg, offs: int -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetLocalArg);
    u64!(self + TIR_INSTR_local, local);
    u64!(self + TIR_INSTR_n, local_n);
    u64!(self + TIR_INSTR_arg, arg);
    u64!(self + TIR_INSTR_expr_offs, offs);
    return cast(self, ir_instr);
end
def make_ir_store_temp n -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_StoreTemp);
    u64!(self + TIR_INSTR_n, n);
    return cast(self, ir_instr);
end
def make_ir_drop_top -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_DropTop);
    return cast(self, ir_instr);
end
def make_ir_set_global name, label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_SetGlobal);
    u64!(self + TIR_INSTR_label, label);
    u64!(self + TIR_INSTR_src_name, name);
    return cast(self, ir_instr);
end
def make_ir_get_global name, label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_GetGlobal);
    u64!(self + TIR_INSTR_label, label);
    u64!(self + TIR_INSTR_src_name, name);
    return cast(self, ir_instr);
end
def make_ir_ref_global name, label -> ir_instr in
    var self = calloc(1, sizeof_TIR_INSTR);
    u64!(self + TIR_INSTR_kind, IRK_RefGlobal);
    u64!(self + TIR_INSTR_label, label);
    u64!(self + TIR_INSTR_src_name, name);
    return cast(self, ir_instr);
end
def print_ir_alloc_temps self in
    printf("(IR.AllocTemps ");
    printf("n=%d)\n", u64@(self + TIR_INSTR_n));
end
def print_ir_call self in
    printf("(IR.Call ");
    printf("label='%s', ", u64@(self + TIR_INSTR_label));
    printf("varargs=%d)\n", u64@(self + TIR_INSTR_varargs));
end
def print_ir_call_lazy_ident self in
    printf("(IR.CallLazyIdent ");
    printf("ident=<Token:%s>, ", token_value(cast(u64@(self + TIR_INSTR_ident), Token&)));
    printf("nargs=%d)\n", u64@(self + TIR_INSTR_nargs));
end
def print_ir_lazy_ident self in
    printf("(IR.LazyIdent ");
    printf("ident=<Token:%s>)\n", token_value(cast(u64@(self + TIR_INSTR_ident), Token&)));
end
def print_ir_close_def self in
    printf("(IR.CloseDef ");
    printf("src_name='%s', ", u64@(self + TIR_INSTR_src_name));
    printf("name='%s')\n", u64@(self + TIR_INSTR_name));
end
def print_ir_free_temps self in
    printf("(IR.FreeTemps ");
    printf("n=%d)\n", u64@(self + TIR_INSTR_n));
end
def print_ir_get_local self in
    printf("(IR.GetLocal ");
    printf("local='%s', ", u64@(self + TIR_INSTR_local));
    printf("n=%d, offs=%d)\n", u64@(self + TIR_INSTR_n), u64@(self + TIR_INSTR_expr_offs));
end
def print_ir_ref_local self in
    printf("(IR.RefLocal ");
    printf("local='%s', ", u64@(self + TIR_INSTR_local));
    printf("n=%d, offs=%d)\n", u64@(self + TIR_INSTR_n), u64@(self + TIR_INSTR_expr_offs));
end
def print_ir_goto self in
    printf("(IR.Goto ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_goto_false self in
    printf("(IR.GotoFalse ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_goto_top_false self in
    printf("(IR.GotoTopFalse ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_goto_top_true self in
    printf("(IR.GotoTopTrue ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_inline_asm self in
    printf("(IR.InlineAsm ");
    printf("name='%s', asm=\"...\")\n", u64@(self + TIR_INSTR_name));
end
def print_ir_label self in
    printf("(IR.Label ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_bit_not self in
    printf("(IR.BitNot)\n");
end
def print_ir_logic_not self in
    printf("(IR.LogicNot)\n");
end
def print_ir_negative self in
    printf("(IR.Negative)\n");
end
def print_ir_scope_open self in
    printf("(IR.ScopeOpen)\n");
end
def print_ir_scope_close self in
    printf("(IR.ScopeClose)\n");
end
def print_ir_new_def self in
    printf("(IR.NewDef ");
    printf("src_name='%s', ", u64@(self + TIR_INSTR_src_name));
    printf("name='%s', ", u64@(self + TIR_INSTR_name));
    printf("params=[");
    var params = cast(u64@(self + TIR_INSTR_params), Vector&);
    var i = 0; var len = params.length;
    while i < len do
        printf("'%s'", vector_get(params, i));
        i += 1;
        if i < len then
            printf(", ");
        end
    end
    printf("], nlocals=%d, ", u64@(self + TIR_INSTR_nlocals));
    printf("expr_size=%d)\n", u64@(self + TIR_INSTR_expr_size));
end
def print_ir_op_add self in
    printf("(IR.OpAdd)\n");
end
def print_ir_op_div self in
    printf("(IR.OpDiv)\n");
end
def print_ir_op_eq self in
    printf("(IR.OpEq)\n");
end
def print_ir_op_greater self in
    printf("(IR.OpGreater)\n");
end
def print_ir_op_greater_eq self in
    printf("(IR.OpGreaterEq)\n");
end
def print_ir_op_less self in
    printf("(IR.OpLess)\n");
end
def print_ir_op_less_eq self in
    printf("(IR.OpLessEq)\n");
end
def print_ir_op_mod self in
    printf("(IR.OpMod)\n");
end
def print_ir_op_mul self in
    printf("(IR.OpMul)\n");
end
def print_ir_op_not_eq self in
    printf("(IR.OpNotEq)\n");
end
def print_ir_op_sub self in
    printf("(IR.OpSub)\n");
end
def print_ir_pop_call self in
    printf("(IR.PopCall)\n");
end
def print_ir_pop_return self in
    printf("(IR.PopReturn)\n");
end
def print_ir_ptr_read self in
    printf("(IR.PtrRead ");
    printf("size=%d)\n", u64@(self + TIR_INSTR_size));
end
def print_ir_ptr_write self in
    printf("(IR.PtrWrite ");
    printf("size=%d)\n", u64@(self + TIR_INSTR_size));
end
def print_ir_ptr_copy self in
    printf("(IR.PtrCopy ");
    printf("size=%d)\n", u64@(self + TIR_INSTR_size));
end
def print_ir_ptr_offset self in
    printf("(IR.PtrOffset ");
    printf("offset=%d)\n", u64@(self + TIR_INSTR_offset));
end
def print_ir_push_int self in
    printf("(IR.PushInt ");
    printf("value=%d)\n", u64@(self + TIR_INSTR_value));
end
def print_ir_push_label self in
    printf("(IR.PushLabel ");
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_return_void self in
    printf("(IR.ReturnVoid)\n");
end
def print_ir_set_arg_temp self in
    printf("(IR.SetArgTemp ");
    printf("n=%d)\n", u64@(self + TIR_INSTR_n));
end
def print_ir_set_local self in
    printf("(IR.SetLocal ");
    printf("local='%s', ", u64@(self + TIR_INSTR_local));
    printf("n=%d, offs=%d)\n", u64@(self + TIR_INSTR_n), u64@(self + TIR_INSTR_expr_offs));
end
def print_ir_set_local_arg self in
    printf("(IR.SetLocalArg ");
    printf("local='%s', ", u64@(self + TIR_INSTR_local));
    printf("n=%d, ", u64@(self + TIR_INSTR_n));
    printf("arg=%d, offs=%d)\n", u64@(self + TIR_INSTR_arg), u64@(self + TIR_INSTR_expr_offs));
end
def print_ir_store_temp self in
    printf("(IR.StoreTemp ");
    printf("n=%d)\n", u64@(self + TIR_INSTR_n));
end
def print_ir_drop_top self in
    printf("(IR.DropTop)\n");
end
def print_ir_set_global self in
    printf("(IR.SetGlobal ");
    printf("global='%s', ", u64@(self + TIR_INSTR_src_name));
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_get_global self in
    printf("(IR.GetGlobal ");
    printf("global='%s', ", u64@(self + TIR_INSTR_src_name));
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir_ref_global self in
    printf("(IR.RefGlobal ");
    printf("global='%s', ", u64@(self + TIR_INSTR_src_name));
    printf("label='%s')\n", u64@(self + TIR_INSTR_label));
end
def print_ir ir: ir_instr in
    var k = ir_instr_kind(ir);
    if k == IRK_AllocTemps then print_ir_alloc_temps(ir);
    elif k == IRK_Call then print_ir_call(ir);
    elif k == IRK_CallLazyIdent then print_ir_call_lazy_ident(ir);
    elif k == IRK_CloseDef then print_ir_close_def(ir);
    elif k == IRK_FreeTemps then print_ir_free_temps(ir);
    elif k == IRK_GetLocal then print_ir_get_local(ir);
    elif k == IRK_Goto then print_ir_goto(ir);
    elif k == IRK_GotoFalse then print_ir_goto_false(ir);
    elif k == IRK_GotoTopFalse then print_ir_goto_top_false(ir);
    elif k == IRK_GotoTopTrue then print_ir_goto_top_true(ir);
    elif k == IRK_InlineAsm then print_ir_inline_asm(ir);
    elif k == IRK_Label then print_ir_label(ir);
    elif k == IRK_BitNot then print_ir_bit_not(ir);
    elif k == IRK_LogicNot then print_ir_logic_not(ir);
    elif k == IRK_NewDef then print_ir_new_def(ir);
    elif k == IRK_OpAdd then print_ir_op_add(ir);
    elif k == IRK_OpDiv then print_ir_op_div(ir);
    elif k == IRK_OpEq then print_ir_op_eq(ir);
    elif k == IRK_OpGreater then print_ir_op_greater(ir);
    elif k == IRK_OpGreaterEq then print_ir_op_greater_eq(ir);
    elif k == IRK_OpLess then print_ir_op_less(ir);
    elif k == IRK_OpLessEq then print_ir_op_less_eq(ir);
    elif k == IRK_OpMod then print_ir_op_mod(ir);
    elif k == IRK_OpMul then print_ir_op_mul(ir);
    elif k == IRK_OpNotEq then print_ir_op_not_eq(ir);
    elif k == IRK_OpSub then print_ir_op_sub(ir);
    elif k == IRK_PopCall then print_ir_pop_call(ir);
    elif k == IRK_PopReturn then print_ir_pop_return(ir);
    elif k == IRK_PtrRead then print_ir_ptr_read(ir);
    elif k == IRK_PtrWrite then print_ir_ptr_write(ir);
    elif k == IRK_PushInt then print_ir_push_int(ir);
    elif k == IRK_PushLabel then print_ir_push_label(ir);
    elif k == IRK_ReturnVoid then print_ir_return_void(ir);
    elif k == IRK_SetArgTemp then print_ir_set_arg_temp(ir);
    elif k == IRK_SetLocal then print_ir_set_local(ir);
    elif k == IRK_SetLocalArg then print_ir_set_local_arg(ir);
    elif k == IRK_StoreTemp then print_ir_store_temp(ir);
    elif k == IRK_LazyIdent then print_ir_lazy_ident(ir);
    elif k == IRK_DropTop then print_ir_drop_top(ir);
    elif k == IRK_SetGlobal then print_ir_set_global(ir);
    elif k == IRK_GetGlobal then print_ir_get_global(ir);
    elif k == IRK_Negative then print_ir_negative(ir);
    elif k == IRK_ScopeOpen then print_ir_scope_open(ir);
    elif k == IRK_ScopeClose then print_ir_scope_close(ir);
    elif k == IRK_PtrCopy then print_ir_ptr_copy(ir);
    elif k == IRK_PtrOffset then print_ir_ptr_offset(ir);
    elif k == IRK_RefLocal then print_ir_ref_local(ir);
    elif k == IRK_RefGlobal then print_ir_ref_global(ir);
    else
        printf("Unknown IR Kind: %d\n", k);
    end
end

const TDEF_INFO_label = 0;    // cstr
const TDEF_INFO_varargs = 16; // bool
const sizeof_TDEF_INFO = 24;

def make_def_info label: cstr, params: Vector&, varargs: bool -> def_info in
    var self = malloc(sizeof_TDEF_INFO);
    u64!(self + TDEF_INFO_label, label);
    u64!(self + TDEF_INFO_varargs, varargs);
    return cast(self, def_info);
end

def def_info_label self: def_info -> cstr in
    return cast(u64@(self + TDEF_INFO_label), cstr);
end
def def_info_varargs self: def_info -> bool in
    return cast(u8@(self + TDEF_INFO_varargs), bool);
end

const TCONST_INFO_kind = 0;
const TCONST_INFO_value = 8;
const sizeof_TCONST_INFO = 16;
const CIK_String = 0;
const CIK_Integer = 1;

def make_const_info kind: int, value: ptr -> const_info in
    var self = malloc(sizeof_TCONST_INFO);
    u64!(self + TCONST_INFO_kind, kind);
    u64!(self + TCONST_INFO_value, value);
    return cast(self, const_info);
end

def const_info_kind self: const_info in return cast(u64@(self + TCONST_INFO_kind), int); end
def const_info_value self: const_info in return cast(u64@(self + TCONST_INFO_value), ptr); end

const TGLOBAL_INFO_kind = 0;
const TGLOBAL_INFO_label = 8;
const TGLOBAL_INFO_value = 16;
const sizeof_TGLOBAL_INFO = 24;
const GIK_String = 0;
const GIK_Integer = 1;

def make_global_info kind: int, label: cstr, value: ptr -> global_info in
    var self = malloc(sizeof_TGLOBAL_INFO);
    u64!(self + TGLOBAL_INFO_kind, kind);
    u64!(self + TGLOBAL_INFO_label, label);
    u64!(self + TGLOBAL_INFO_value, value);
    return cast(self, global_info);
end

def global_info_kind self: global_info in return cast(u64@(self + TGLOBAL_INFO_kind), int); end
def global_info_label self: global_info in return cast(u64@(self + TGLOBAL_INFO_label), cstr); end
def global_info_value self: global_info in return cast(u64@(self + TGLOBAL_INFO_value), ptr); end

const TLOCAL_INFO_n = 0;
const TLOCAL_INFO_offs = 8;
const TLOCAL_INFO_size = 16;
const sizeof_TLOCAL_INFO = 24;

def make_local_info n: int, offs: int, size: int -> local_info in
    var self = malloc(sizeof_TLOCAL_INFO);
    u64!(self + TLOCAL_INFO_n, n);
    u64!(self + TLOCAL_INFO_offs, offs);
    u64!(self + TLOCAL_INFO_size, size);
    return cast(self, local_info);
end

def local_info_n self: local_info in return cast(u64@(self + TLOCAL_INFO_n), int); end
def local_info_offs self: local_info in return cast(u64@(self + TLOCAL_INFO_offs), int); end
def local_info_size self: local_info in return cast(u64@(self + TLOCAL_INFO_size), int); end

const TIR_CONTEXT_instructions =  0;  // ir_instruction Vector&
const TIR_CONTEXT_label_id     =  8;  // int
const TIR_CONTEXT_strings      = 16;  // (string, cstr) map      : String& -> label
const TIR_CONTEXT_externs      = 24;  // (cstr, def_info) map   : name -> def_info
const TIR_CONTEXT_labels       = 32;  // string set : all labels
const TIR_CONTEXT_constants    = 40;  // (cstr, const_info) map  : name -> const_info
const TIR_CONTEXT_src_locs     = 48;  // src_loc Vector&
const TIR_CONTEXT_file_set     = 56;  // cstr set : paths
const TIR_CONTEXT_files        = 64;  // cstr Vector&
const TIR_CONTEXT_defs         = 72;  // (cstr, def_info) map   : name -> def_info
const TIR_CONTEXT_def_locals   = 80;  // (cstr, local_info) map Vector&  : stack of scope: name -> location
const TIR_CONTEXT_globals_map  = 88;  // (cstr, global_info) map : name -> global_info
// Order of definition is preserved in the `globals' Vector&.
const TIR_CONTEXT_globals      = 96;  // global_info Vector&
const TIR_CONTEXT_break_dests  = 104; // cstr Vector& -> label to goto
const TIR_CONTEXT_conti_dests  = 112; // cstr Vector& -> label to goto
const TIR_CONTEXT_num_locals   = 120; // int : max number of locals allocated
const TIR_CONTEXT_locals_size  = 128; // int : max size needed for all locals
const sizeof_TIR_CONTEXT       = 136;

def make_ir_context -> ir_context in
    var self = calloc(1, sizeof_TIR_CONTEXT);
    u64!(self + TIR_CONTEXT_instructions, make_vector(0));
    u64!(self + TIR_CONTEXT_label_id, 0);
    u64!(self + TIR_CONTEXT_strings, make_map(0, string_eq, string_hash));
    u64!(self + TIR_CONTEXT_externs, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TIR_CONTEXT_labels, make_set(0, cstr_eq, cstr_hash));
    u64!(self + TIR_CONTEXT_constants, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TIR_CONTEXT_src_locs, make_vector(0));
    u64!(self + TIR_CONTEXT_file_set, make_set(0, cstr_eq, cstr_hash));
    u64!(self + TIR_CONTEXT_files, make_vector(0));
    u64!(self + TIR_CONTEXT_defs, make_map(0, NULL, NULL));
    u64!(self + TIR_CONTEXT_def_locals, make_vector(0));
    u64!(self + TIR_CONTEXT_globals_map, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TIR_CONTEXT_globals, make_vector(0));
    u64!(self + TIR_CONTEXT_break_dests, make_vector(0));
    u64!(self + TIR_CONTEXT_conti_dests, make_vector(0));
    return cast(self, ir_context);
end

def ir_instructions self: ir_context in return cast(u64@(self + TIR_CONTEXT_instructions), Vector&); end
def ir_strings self: ir_context in return cast(u64@(self + TIR_CONTEXT_strings), map); end
def ir_externs self: ir_context in return cast(u64@(self + TIR_CONTEXT_externs), map); end
def ir_labels self: ir_context in return cast(u64@(self + TIR_CONTEXT_labels), set); end
def ir_constants self: ir_context in return cast(u64@(self + TIR_CONTEXT_constants), map); end
def ir_src_locs self: ir_context in return cast(u64@(self + TIR_CONTEXT_src_locs), Vector&); end
def ir_file_set self: ir_context in return cast(u64@(self + TIR_CONTEXT_file_set), set); end
def ir_files self: ir_context in return cast(u64@(self + TIR_CONTEXT_files), Vector&); end
def ir_defs self: ir_context in return cast(u64@(self + TIR_CONTEXT_defs), map); end
def ir_def_locals self: ir_context in return cast(u64@(self + TIR_CONTEXT_def_locals), Vector&); end
def ir_globals_map self: ir_context in return cast(u64@(self + TIR_CONTEXT_globals_map), map); end
def ir_globals self: ir_context in return cast(u64@(self + TIR_CONTEXT_globals), Vector&); end
def ir_break_dests self: ir_context in return cast(u64@(self + TIR_CONTEXT_break_dests), Vector&); end
def ir_continue_dests self: ir_context in return cast(u64@(self + TIR_CONTEXT_conti_dests), Vector&); end
def ir_num_locals self: ir_context in return cast(u64@(self + TIR_CONTEXT_num_locals), int); end
def ir_locals_size self: ir_context in return cast(u64@(self + TIR_CONTEXT_locals_size), int); end

def ir_append self, insn in
    u64!(insn + TIR_INSTR_src_loc, ir_current_src_loc(self));
    var vec = ir_instructions(self);
    vector_push(vec, insn);
end

def ir_push_src_loc self, src_loc in
    var src_locs = ir_src_locs(self);
    vector_push(src_locs, src_loc);

    var filename = src_loc_filename(src_loc);
    var fileset = ir_file_set(self);
    if not set_contains(fileset, filename) then
        set_add(fileset, filename);
        var files = ir_files(self);
        vector_push(files, filename);
    end
end

def ir_pop_src_loc self in
    var src_locs = ir_src_locs(self);
    vector_pop(src_locs);
end

def ir_current_src_loc self in
    var src_locs = ir_src_locs(self);
    return vector_back(src_locs);
end

def ir_push_scope self in
    vector_push(ir_def_locals(self), make_map(0, cstr_eq, cstr_hash));
    ir_append(self, make_ir_scope_open());
end

def ir_pop_scope self in
    var vec = ir_def_locals(self);
    var map = vector_back(vec);
    vector_pop(vec);
    ir_append(self, make_ir_scope_close());
    free_map(map);
end

def ir_cur_scope self in
    return vector_back(ir_def_locals(self));
end

def ir_new_def self, ident, params, ast, symbol in
    var defs = ir_defs(self);
    var found = map_find(defs, ident);
    if found then
        printf("ERROR: def `%s` already defined\n", ident);
        print_ast_src_loc(ast);
        exit(1);
    end
    
    var label = make_string(20); // @LEAK
    string_append_cstr(label, "_def_");
    if symbol.owned_by then
        string_push(label, '_');
        string_append_int(label, type_id(symbol.owned_by));
        string_push(label, '_');
    end
    string_append_cstr(label, ident);

    var label_cstr = string_cstr(label);
    set_add(ir_labels(self), label_cstr);
    map_set(defs, symbol_name(symbol), make_def_info(label_cstr, params, false));

    assert(ir_def_locals(self).length == 0,
        "Compiler bug: def locals not empty when creating new def\n");
    u64!(self + TIR_CONTEXT_num_locals, 0);
    u64!(self + TIR_CONTEXT_locals_size, 0);
    symbol.label = label_cstr;
    symbol.is_varargs = false;
    return label_cstr;
end

def ir_new_local self, ident, st in
    var def_locals = ir_def_locals(self);
    var local_idx = 0;
    var offset = 0;
    var i = 0; var len = def_locals.length;
    while i < len do
        var map = vector_get(def_locals, i);
        local_idx += map_len(map);
        var cur = map_begin(map);
        while cur != map_end(map) do
            var local_info = cast(map_pair_val(cur), local_info);
            offset += local_info_size(local_info);
            cur = map_next(map, cur);
        end
        i += 1;
    end
    var size = 0;
    if g_Experimental then
        var sym = st_get_symbol(st, ident);
        assert(sym);
        var type = symbol_type(sym);
        assert(type);
        size = type_size(type);
        if offset + size > ir_locals_size(self) then
            u64!(self + TIR_CONTEXT_locals_size, offset + size);
        end
            
    end
    map_set(ir_cur_scope(self), ident, make_local_info(local_idx, offset, size));
    if local_idx + 1 > ir_num_locals(self) then
        u64!(self + TIR_CONTEXT_num_locals, local_idx + 1);
    end
    return local_idx;
end

def ir_new_label self, hint in
    var label_id = cast(u64@(self + TIR_CONTEXT_label_id), int);
    u64!(self + TIR_CONTEXT_label_id, label_id + 1);

    var label = make_string(13); // @LEAK
    string_append_cstr(label, ".L");
    if hint then
        string_append_cstr(label, hint);
    end
    string_append_int(label, label_id);

    var label_cstr = string_cstr(label);
    set_add(ir_labels(self), label_cstr);
    return label_cstr;
end

def ir_string_label self, string in
    var strings = ir_strings(self);
    var found = map_find(strings, string);
    if found then
        return map_pair_val(found);
    end

    var label = ir_new_label(self, "C");
    set_add(ir_labels(self), label);
    map_set(strings, string, label);

    return label;
end

def ir_is_label self, ident in
    return set_contains(ir_labels(self), ident);
end

def ir_is_def self, ident in
    //var sym = st_get_symbol(g_SymbolTable, ident);
    if map_find(ir_defs(self), ident) != NULL then
        return true;
    else
        return false;
    end
end

def ir_get_def self, ident in
    var found = map_find(ir_defs(self), ident);
    return map_pair_val(found);
end

def ir_is_extern self, ident in
    return map_find(ir_externs(self), ident) != NULL;
end

def ir_get_extern self, ident in
    var found = map_find(ir_externs(self), ident);
    return map_pair_val(found);
end

def ir_add_extern self, ident, params, is_varargs in
    var def_info = make_def_info(ident, params, is_varargs);
    map_set(ir_externs(self), ident, def_info);
end

def ir_is_local self, ident in
    var def_locals = ir_def_locals(self);
    var i = 0; var len = def_locals.length;
    while i < len do
        if map_find(vector_get(def_locals, i), ident) then
            return true;
        end
        i += 1;
    end
    return false;
end

def ir_is_cur_scope_local self, ident in
    if map_find(ir_cur_scope(self), ident) then
        return true;
    end
    return false;
end

def ir_get_local self, ident in
    var def_locals = ir_def_locals(self);
    var i = def_locals.length - 1;
    var found;
    while i >= 0 do
        found = map_find(vector_get(def_locals, i), ident);
        if found then
            return local_info_n(map_pair_val(found));
        end
        i -= 1;
    end
    assert(false, "Compiler bug: didn't check `ir_is_local` before calling `ir_get_local`\n");
end

def ir_get_local_offset self, ident in
    var def_locals = ir_def_locals(self);
    var i = def_locals.length - 1;
    var found;
    while i >= 0 do
        found = map_find(vector_get(def_locals, i), ident);
        if found then
            return local_info_offs(map_pair_val(found));
        end
        i -= 1;
    end
    assert(false, "Compiler bug: didn't check `ir_is_local` before calling `ir_get_local_offset`\n");
end

def ir_is_const self, ident in
    return map_find(ir_constants(self), ident) != NULL;
end

def ir_get_const self, ident in
    var found = map_find(ir_constants(self), ident);
    return map_pair_val(found);
end

def ir_add_const self, ident, value in
    map_set(ir_constants(self), ident, value);
end

def ir_is_global self, ident in
    return map_find(ir_globals_map(self), ident) != NULL;
end

def ir_get_global self, ident in
    var found = map_find(ir_globals_map(self), ident);
    return map_pair_val(found);
end

def ir_add_global_string self, ident, value in
    var label = ir_new_label(self, "G");
    var val_label = ir_string_label(self, value);
    var gi = make_global_info(GIK_String, label, val_label);
    map_set(ir_globals_map(self), ident, gi);
    vector_push(ir_globals(self), gi);
end

def ir_add_global_int self, ident, value in
    var label = ir_new_label(self, "G");
    var gi = make_global_info(GIK_Integer, label, value);
    map_set(ir_globals_map(self), ident, gi);
    vector_push(ir_globals(self), gi);
end

def ir_push_break_dest self, dest in
    vector_push(ir_break_dests(self), dest);
end

def ir_pop_break_dest self in
    vector_pop(ir_break_dests(self));
end

def ir_get_break_dest self in
    var dests = ir_break_dests(self);
    if dests.length == 0 then
        return NULL;
    end
    return vector_back(dests);
end

def ir_push_continue_dest self, dest in
    vector_push(ir_continue_dests(self), dest);
end

def ir_pop_continue_dest self in
    vector_pop(ir_continue_dests(self));
end

def ir_get_continue_dest self in
    var dests = ir_continue_dests(self);
    if dests.length == 0 then
        return NULL;
    end
    return vector_back(dests);
end

def _comptime_eval_is_n n, ast in
    return ast_kind(ast) == AstK_Integer and ast_value(ast) == n;
end

def _comptime_scope_resolve_val self, ast, st, tt, depth in
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet.\n");

    var type = ast_type(ast_lhs(ast));
    var member = ast_ident(ast_rhs(ast));
    if type_is_enum(type) then
        var enum_vals = type_enum_values(type);
        var i = 0; var len = enum_vals.length;
        while i < len do
            var ev = cast(vector_get(enum_vals, i), EnumValue&);
            if cstr_eq(ev.name, member) then
                if not ev.cache_value then
                    ev.cache_value = ir_comptime_eval(self, ev.value, st, tt, true, depth + 1);
                end
                return ev.cache_value;
            end
            i += 1;
        end
        assert(false, "Error should have been reported in type checker\n");
    end
end

def ir_comptime_eval self, ast, st, tt, error_on_fail, depth in

    if depth > 10 then
        printf("ERROR: comptime eval reached recursion limit.\n");
        printf("NOTE: The expression was: ");
        print_ast(ast);
        print_ast_src_loc(ast);
        exit(1);
    end

    var evaled; var result: int;
    var op; var ident; var ci;
    var lhs; var rhs;
    var lhs_val; var rhs_val;

    var k = ast_kind(ast);
    if k == AstK_Integer then
        return ast;
    elif k == AstK_String then
        return ast;
    elif k == AstK_Ident then
        ident = ast_ident(ast);
        if ir_is_const(self, ident) then
            ci = ir_get_const(self, ident);
            if const_info_kind(ci) == CIK_String then
                return ast;
            elif const_info_kind(ci) == CIK_Integer then
                return make_ast_integer(ast_token(ast), cast(const_info_value(ci), int)); // @LEAK
            end
        end
    elif k == AstK_ScopeResolve then
        return _comptime_scope_resolve_val(self, ast, st, tt, depth);
    elif k == AstK_SizeofExpr then
        var expr_type = tt_get_ast_type(tt, ast_expr(ast));
        var size_bytes = (type_size(expr_type) + BYTE_BITS-1) / BYTE_BITS;
        return make_ast_integer(ast_token(ast), size_bytes); // @LEAK
    elif k == AstK_SizeofType then
        var type = ast_type(ast);
        if type then
            var size_bytes = (type_size(type) + BYTE_BITS-1) / BYTE_BITS;
            return make_ast_integer(ast_token(ast), size_bytes); // @LEAK
        end
    elif k == AstK_BinOp then
        op = ast_op(ast);
        lhs = ir_comptime_eval(self, ast_lhs(ast), st, tt, error_on_fail, depth + 1);
        rhs = ir_comptime_eval(self, ast_rhs(ast), st, tt, error_on_fail, depth + 1);

        if op == TK::Plus  and _comptime_eval_is_n(0, rhs) then return lhs; end // k + 0
        if op == TK::Plus  and _comptime_eval_is_n(0, lhs) then return rhs; end // 0 + k
        if op == TK::Minus and _comptime_eval_is_n(0, rhs) then return lhs; end // k - 0
        if op == TK::Star  and _comptime_eval_is_n(1, rhs) then return lhs; end // k * 1
        if op == TK::Star  and _comptime_eval_is_n(1, lhs) then return rhs; end // 1 * k
        if op == TK::Slash and _comptime_eval_is_n(1, rhs) then return lhs; end // k / 1

        if ast_kind(lhs) == ast_kind(rhs) then
            if ast_kind(lhs) == AstK_Integer then
                lhs_val = cast(ast_value(lhs), int);
                rhs_val = cast(ast_value(rhs), int);
                evaled = false;
                if op == TK::Plus then
                    evaled = true;
                    result = lhs_val + rhs_val;
                elif op == TK::Minus then
                    evaled = true;
                    result = lhs_val - rhs_val;
                elif op == TK::Star then
                    evaled = true;
                    result = lhs_val * rhs_val;
                elif op == TK::KW_and then
                    evaled = true;
                    result = lhs_val and rhs_val;
                elif op == TK::KW_or then
                    evaled = true;
                    result = lhs_val or rhs_val;
                elif op == TK::Slash then
                    if rhs_val != 0 then
                        evaled = true;
                        result = lhs_val / rhs_val;
                    end
                elif op == TK::Percent then
                    if rhs_val != 0 then
                        evaled = true;
                        result = lhs_val % rhs_val;
                    end
                elif op == TK::Caret then
                    evaled = true;
                    result = lhs_val ^ rhs_val;
                elif op == TK::Amper then
                    evaled = true;
                    result = lhs_val & rhs_val;
                elif op == TK::Bar then
                    evaled = true;
                    result = lhs_val | rhs_val;
                elif op == TK::LShift then
                    evaled = true;
                    result = lhs_val << rhs_val;
                elif op == TK::RShift then
                    evaled = true;
                    result = lhs_val >> rhs_val;
                elif op == TK::EqEq then
                    evaled = true;
                    result = lhs_val == rhs_val;
                elif op == TK::NotEq then
                    evaled = true;
                    result = lhs_val != rhs_val;
                elif op == TK::Less then
                    evaled = true;
                    result = lhs_val < rhs_val;
                elif op == TK::LessEq then
                    evaled = true;
                    result = lhs_val <= rhs_val;
                elif op == TK::Greater then
                    evaled = true;
                    result = lhs_val > rhs_val;
                elif op == TK::GreaterEq then
                    evaled = true;
                    result = lhs_val >= rhs_val;
                end
                if evaled then
                    return make_ast_integer(ast_token(ast), result); // @LEAK
                end
            end
        end
    elif k == AstK_Prefix then
        op = ast_op(ast);
        rhs = ir_comptime_eval(self, ast_expr(ast), st, tt, error_on_fail, depth + 1);
        evaled = false;
        if ast_kind(rhs) == AstK_Integer then
            rhs_val = cast(ast_value(rhs), int);
            if op == TK::Minus then
                evaled = true;
                result = 0 - rhs_val;
            elif op == TK::KW_not then
                evaled = true;
                result = not rhs_val;
            elif op == TK::Tilde then
                evaled = true;
                result = ~rhs_val;
            end
            if evaled then
                return make_ast_integer(ast_token(ast), result); // @LEAK
            end
        end
    elif k == AstK_Cast then
        return ir_comptime_eval(self, ast_expr(ast), st, tt, error_on_fail, depth + 1);
    end

    if error_on_fail then
        printf("ERROR: Expression is not compile-time evaluable.\n");
        printf("NOTE: The expression was: ");
        print_ast(ast);
        print_ast_src_loc(ast);
        exit(1);
    end
    return ast;
end

def ir_emit_body self, body, st, tt in
    var i = 0;
    var len = body.length;
    while i < len do
        var ast = vector_get(body, i);
        ir_compile(self, ast, st, tt);
        if ast_is_expr(ast) then
            ir_append(self, make_ir_drop_top());
        end
        i += 1;
    end
end
        
def ir_emit_ident self, ast, st, tt in
    check_ast_kind(AstK_Ident, ast);

    var ident = ast_ident(ast);
    if ir_is_local(self, ident) then
        var n = ir_get_local(self, ident);
        var offs = ir_get_local_offset(self, ident);
        ir_append(self, make_ir_get_local(ident, n, offs));
    elif ir_is_const(self, ident) then
        var const_info = ir_get_const(self, ident);
        var cik = const_info_kind(const_info);
        if cik == CIK_Integer then
            ir_append(self, make_ir_push_int(const_info_value(const_info)));
        elif cik == CIK_String then
            ir_append(self, make_ir_push_label(const_info_value(const_info)));
        else
            printf("Unhandled const_info kind: %d\n", cik);
            NYI_ERR(__FILE__, __LINE__, "ir_emit_ident:const");
        end
    elif ir_is_def(self, ident) then
        var def_info = ir_get_def(self, ident);
        ir_append(self, make_ir_push_label(def_info_label(def_info)));
    elif ir_is_extern(self, ident) then
        var extern_info = ir_get_extern(self, ident);
        ir_append(self, make_ir_push_label(def_info_label(extern_info)));
    elif ir_is_global(self, ident) then
        var gi = ir_get_global(self, ident);
        ir_append(self, make_ir_get_global(ident, global_info_label(gi)));
    else
        ir_append(self, make_ir_lazy_ident(ast_token(ast), st_get_symbol(st, ident)));
    end
end

def ir_emit_integer self, ast, st, tt in
    check_ast_kind(AstK_Integer, ast);
    ir_append(self, make_ir_push_int(ast_value(ast)));
end

def ir_emit_string self, ast, st, tt in
    check_ast_kind(AstK_String, ast);
    var string = ast_value(ast);
    var string_label = ir_string_label(self, string);
    ir_append(self, make_ir_push_label(string_label));
end

def ir_emit_call self, ast, st, tt in
    check_ast_kind(AstK_Call, ast);
    var args = ast_args(ast);
    var len = args.length;
    if len > 0 then
        ir_append(self, make_ir_alloc_temps(len));
    end
    var i = 0;
    while i < len do
        ir_compile(self, vector_get(args, i), st, tt);
        ir_append(self, make_ir_store_temp(i));
        i += 1;
    end

    i = 0;
    while i < len do
        ir_append(self, make_ir_set_arg_temp(i));
        i += 1;
    end
    if len > 0 then
        ir_append(self, make_ir_free_temps(len));
    end

    var expr = ast_expr(ast);
    if ast_kind(expr) == AstK_Ident then
        var ident = ast_ident(expr);
        var info;
        if ir_is_def(self, ident) then
            info = ir_get_def(self, ident);
            ir_append(self, make_ir_call(def_info_label(info), def_info_varargs(info)));
        elif ir_is_extern(self, ident) then
            info = ir_get_extern(self, ident);
            ir_append(self, make_ir_call(def_info_label(info), def_info_varargs(info)));
        elif ir_is_label(self, ident) then
            ir_append(self, make_ir_call(ident, false));
        elif ir_is_local(self, ident) then
            ir_compile(self, expr, st, tt);
            ir_append(self, make_ir_pop_call());
        else
            ir_append(self, make_ir_call_lazy_ident(ast_token(expr), st_get_symbol(st, ident), len));
        end
    elif ast_kind(expr) == AstK_ScopeResolve then
        var def_ = scope_resolve_def(tt, expr, true);
        assert(def_.label != NULL);
        ir_append(self, make_ir_call(def_.label, def_.is_varargs));
    else
        ir_compile(self, expr, st, tt);
        ir_append(self, make_ir_pop_call());
    end
end

def ir_emit_logic_and self, ast, st, tt in
    var label = ir_new_label(self, NULL);
    ir_compile(self, ast_lhs(ast), st, tt);
    ir_append(self, make_ir_goto_top_false(label));
    ir_compile(self, ast_rhs(ast), st, tt);
    ir_append(self, make_ir_label(label));
end

def ir_emit_logic_or self, ast, st, tt in
    var label = ir_new_label(self, NULL);
    ir_compile(self, ast_lhs(ast), st, tt);
    ir_append(self, make_ir_goto_top_true(label));
    ir_compile(self, ast_rhs(ast), st, tt);
    ir_append(self, make_ir_label(label));
end

def ir_emit_binop self, ast, st, tt in
    check_ast_kind(AstK_BinOp, ast);
    var op = ast_op(ast);
    var simple = -1;
    if op == TK::Plus then simple = IRK_OpAdd;
    elif op == TK::Minus then simple = IRK_OpSub;
    elif op == TK::Star then simple = IRK_OpMul;
    elif op == TK::Slash then simple = IRK_OpDiv;
    elif op == TK::Percent then simple = IRK_OpMod;
    elif op == TK::EqEq then simple = IRK_OpEq;
    elif op == TK::NotEq then simple = IRK_OpNotEq;
    elif op == TK::Less then simple = IRK_OpLess;
    elif op == TK::Greater then simple = IRK_OpGreater;
    elif op == TK::LessEq then simple = IRK_OpLessEq;
    elif op == TK::GreaterEq then simple = IRK_OpGreaterEq;
    elif op == TK::Caret then simple = IRK_OpBitXOR;
    elif op == TK::Amper then simple = IRK_OpBitAND;
    elif op == TK::Bar then simple = IRK_OpBitOR;
    elif op == TK::LShift then simple = IRK_OpBitShiftL;
    elif op == TK::RShift then simple = IRK_OpBitShiftR;
    elif op == TK::KW_and then ir_emit_logic_and(self, ast, st, tt);
    elif op == TK::KW_or then ir_emit_logic_or(self, ast, st, tt);
    else
        printf("Unhandled binop: %d\n", op);
        print_token(ast_token(ast));
        NYI_ERR(__FILE__, __LINE__, "ir_emit_binop");
    end
    if simple >= 0 then
        ir_compile(self, ast_lhs(ast), st, tt);
        ir_compile(self, ast_rhs(ast), st, tt);
        ir_append(self, make_ir_simple_op(simple));
    end
end

def ir_emit_return self, ast, st, tt in
    check_ast_kind(AstK_Return, ast);
    var expr = ast_expr(ast);
    if not expr then
        ir_append(self, make_ir_return_void());
        return;
    end
    ir_compile(self, expr, st, tt);
    ir_append(self, make_ir_pop_return());
end

def ir_emit_var_decl self, ast, st, tt in
    check_ast_kind(AstK_VarDecl, ast);
    var ident = ast_ident(ast);
    assert(not ir_is_cur_scope_local(self, ident),
        "Compiler bug: Error should have been handled earlier.\n");
    var sym = st_get_symbol(st, ident);
    assert(sym);
    var sym_type = symbol_type(sym);
    assert(sym_type and type_size(sym_type) != 0,
        "Compiler bug: Error should have been handled in type checker.\n");
    ir_new_local(self, ident, st);
end

def ir_emit_var_assign self, ast, st, tt in
    check_ast_kind(AstK_VarAssign, ast);
    var ident = ast_ident(ast);
    assert(not ir_is_cur_scope_local(self, ident),
        "Compiler bug: Error should have been handled earlier.\n");
    var sym = st_get_symbol(st, ident);
    assert(sym);
    var sym_type = symbol_type(sym);
    assert(sym_type and type_size(sym_type) != 0,
        "Compiler bug: Error should have been handled in type checker.\n");
    ir_compile(self, ast_assign_expr(ast), st, tt);
    var n = ir_new_local(self, ident, st);
    var offs = ir_get_local_offset(self, ident);
    ir_append(self, make_ir_set_local(ident, n, offs));
end

def ir_emit_assign_op self, ast, st, tt in
    check_ast_kind(AstK_AssignOp, ast);
    var ident = ast_ident(ast);
    var op = ast_op(ast);
    if op != TK::Assign then
        if ir_is_local(self, ident) then
            var n = ir_get_local(self, ident);
            var offs = ir_get_local_offset(self, ident);
            ir_append(self, make_ir_get_local(ident, n, offs));
        elif ir_is_global(self, ident) then
            var gi = ir_get_global(self, ident);
            var label = global_info_label(gi);
            ir_append(self, make_ir_get_global(ident, label));
            else
        //ir_append(self, make_ir_lazy_ident(ast_token(ast)));
        printf("TODO: This can be fixed in the compiler by implementing IRK_SetLazyIdent\n");
        printf("ERROR: No variable named `%s` exists.\n", ident);
        print_ast_src_loc(ast);
        exit(1);
        end
    end
    ir_compile(self, ast_assign_expr(ast), st, tt);

    var ir_op = -1;
    if op == TK::PlusEq then ir_op = IRK_OpAdd;
    elif op == TK::MinusEq then ir_op = IRK_OpSub;
    elif op == TK::StarEq then ir_op = IRK_OpMul;
    elif op == TK::SlashEq then ir_op = IRK_OpDiv;
    elif op == TK::PercentEq then ir_op = IRK_OpMod;
    elif op == TK::LShiftEq then ir_op = IRK_OpBitShiftL;
    elif op == TK::RShiftEq then ir_op = IRK_OpBitShiftR;
    elif op == TK::AmperEq then ir_op = IRK_OpBitAND;
    elif op == TK::CaretEq then ir_op = IRK_OpBitXOR;
    elif op == TK::BarEq then ir_op = IRK_OpBitOR;
    elif op == TK::Assign then // nothing
    else
        print_ast_src_loc(ast);
        assert(false, "Compiler bug: Unhandled assign op: %d\n", op);
    end

    if op != TK::Assign then
        assert(ir_op != -1, "Compiler bug: ir_op wasn't assigned. op = %d\n", op);
        ir_append(self, make_ir_simple_op(ir_op));
    end

    if ir_is_local(self, ident) then
        var n = ir_get_local(self, ident);
        var offs = ir_get_local_offset(self, ident);
        ir_append(self, make_ir_set_local(ident, n, offs));
    elif ir_is_global(self, ident) then
        var gi = ir_get_global(self, ident);
        var label = global_info_label(gi);
        ir_append(self, make_ir_set_global(ident, label));
    else
        print_ast_src_loc(ast);
        assert(false, "Compiler bug: Unhandled assignment for non-local and non-global\n");
    end
end

def ir_emit_assign_member self, ast, st, tt in
    check_ast_kind(AstK_AssignMember, ast);
    var lhs = ast_lhs(ast);
    var rhs = ast_rhs(ast);
    var op = ast_op(ast);

    if op != TK::Assign then
        if ast_kind(lhs) == AstK_MemberAccess then
            // dereference self
            ir_emit_member_access(self, lhs, st, tt, true);
        else
            ir_compile(self, lhs, st, tt);
        end
    end

    ir_compile(self, rhs, st, tt);

    var ir_op = -1;
    if op == TK::PlusEq then ir_op = IRK_OpAdd;
    elif op == TK::MinusEq then ir_op = IRK_OpSub;
    elif op == TK::StarEq then ir_op = IRK_OpMul;
    elif op == TK::SlashEq then ir_op = IRK_OpDiv;
    elif op == TK::PercentEq then ir_op = IRK_OpMod;
    elif op == TK::LShiftEq then ir_op = IRK_OpBitShiftL;
    elif op == TK::RShiftEq then ir_op = IRK_OpBitShiftR;
    elif op == TK::AmperEq then ir_op = IRK_OpBitAND;
    elif op == TK::CaretEq then ir_op = IRK_OpBitXOR;
    elif op == TK::BarEq then ir_op = IRK_OpBitOR;
    elif op == TK::Assign then // nothing
    else
        print_ast_src_loc(ast);
        assert(false, "Compiler bug: Unhandled assign op: %d\n", op);
    end

    if op != TK::Assign then
        assert(ir_op != -1, "Compiler bug: ir_op wasn't assigned. op = %d\n", op);
        ir_append(self, make_ir_simple_op(ir_op));
    end

    if ast_kind(lhs) == AstK_MemberAccess then
        ir_emit_member_access(self, lhs, st, tt, false);
    else
        ir_compile(self, lhs, st, tt);
    end
    var lhs_type = tt_get_ast_type(tt, lhs);
    var size = type_size(lhs_type);
    ir_append(self, make_ir_ptr_write(size));
end

def ir_emit_def self, ast, st, tt in
    check_ast_kind(AstK_Def, ast);
    var ident = ast_ident(ast);
    var params = ast_params(ast);
    var label = ir_new_def(self, ident, params, ast, st_get_symbol(st, ident));
    var insn = make_ir_new_def(ident, label, params);
    ir_push_scope(self);
    ir_append(self, insn);

    var i = 0; var len = params.length;
    while i < len do
        var param = vector_get(params, i);
        var n = ir_new_local(self, param, st);
        var offs = ir_get_local_offset(self, param);
        ir_append(self, make_ir_set_local_arg(param, n, i, offs));
        i += 1;
    end
    ir_emit_body(self, ast_body(ast), st, tt);
    u64!(insn + TIR_INSTR_nlocals, ir_num_locals(self));
    u64!(insn + TIR_INSTR_expr_size, ir_locals_size(self));
    ir_append(self, make_ir_close_def(ident, label));
    ir_pop_scope(self);
end

def ir_emit_if_else self, ast, st, tt in
    check_ast_kind(AstK_IfElse, ast);
    var l_else = ir_new_label(self, NULL);
    var l_out = ir_new_label(self, NULL);
    ir_compile(self, ast_test(ast), st, tt);
    ir_append(self, make_ir_goto_false(l_else));
    ir_push_scope(self);
    ir_emit_body(self, ast_consequence(ast), st, tt);
    ir_pop_scope(self);
    ir_append(self, make_ir_goto(l_out));

    ir_append(self, make_ir_label(l_else));
    ir_push_scope(self);
    ir_emit_body(self, ast_alternative(ast), st, tt);
    ir_pop_scope(self);
    ir_append(self, make_ir_label(l_out));
end

def ir_emit_while self, ast, st, tt in
    check_ast_kind(AstK_While, ast);
    var l_test = ir_new_label(self, NULL);
    var l_out = ir_new_label(self, NULL);
    ir_push_scope(self);
    ir_append(self, make_ir_label(l_test));
    ir_compile(self, ast_test(ast), st, tt);
    ir_append(self, make_ir_goto_false(l_out));
    ir_push_break_dest(self, l_out);     // break jumps to out
    ir_push_continue_dest(self, l_test); // continue jumps to test
    ir_emit_body(self, ast_body(ast), st, tt);
    ir_pop_continue_dest(self);
    ir_pop_break_dest(self);
    ir_append(self, make_ir_goto(l_test));
    ir_append(self, make_ir_label(l_out));
    ir_pop_scope(self);
end

def ir_emit_pointer_op self, ast, st, tt in
    //check_ast_kind(AstK_PointerOp, ast);
    var args = ast_pop_args(ast);
    var size = ast_size(ast);
    var op = ast_op(ast);
    if op == PointerOp_Read then
        ir_compile(self, vector_get(args, 0), st, tt);
        ir_append(self, make_ir_ptr_read(size));
    elif op == PointerOp_Write then
        // Pointer ops expect the pointer to be at top of stack so we compile in reverse order.
        ir_compile(self, vector_get(args, 1), st, tt);
        ir_compile(self, vector_get(args, 0), st, tt);
        ir_append(self, make_ir_ptr_write(size));
    else
        NYI_ERR(__FILE__, __LINE__, "unhandled ir_emit_pointer_op");
    end
end

def ir_emit_prefix_op self, ast, st, tt in
    check_ast_kind(AstK_Prefix, ast);
    var expr = ast_expr(ast);
    var op = ast_op(ast);
    if op == TK::Tilde then
        ir_compile(self, expr, st, tt);
        ir_append(self, make_ir_bit_not());
    elif op == TK::KW_not then
        ir_compile(self, expr, st, tt);
        ir_append(self, make_ir_logic_not());
    elif op == TK::Minus then
        if ast_kind(expr) == AstK_Integer then
            ir_append(self, make_ir_push_int(0 - ast_value(expr)));
        else
            ir_compile(self, expr, st, tt);
            ir_append(self, make_ir_negative());
        end
    else
        NYI_ERR(__FILE__, __LINE__, "unhandled ir_emit_prefix_op");
    end
end

def ir_emit_const self, ast, st, tt in
    check_ast_kind(AstK_Const, ast);
    var expr = ast_assign_expr(ast);
    var val = ir_comptime_eval(self, expr, st, tt, true, 0);
    var const_info = NULL;
    var k = ast_kind(val);
    if k == AstK_String then
        var string_label = ir_string_label(self, ast_value(val));
        const_info = make_const_info(CIK_String, string_label);
    elif k == AstK_Integer then
        const_info = make_const_info(CIK_Integer, ast_value(val));
    end
    if const_info then
        if ir_is_const(self, ast_ident(ast)) then
            var existing = ir_get_const(self, ast_ident(ast));
            if const_info_kind(existing) != const_info_kind(const_info) or
                const_info_value(existing) != const_info_value(const_info) then
                printf("ERROR: Cannot redefine a const `%s` to a new value.\n", ast_ident(ast));
                print_ast_src_loc(ast);
                exit(1);
            end
        else
            ir_add_const(self, ast_ident(ast), const_info);
        end
    else
        NYI_ERR(__FILE__, __LINE__, "ir_emit_const_comptime: unsupported constant");
    end
end

def ir_emit_extern self, ast, st, tt in
    check_ast_kind(AstK_Extern, ast);
    var ident = ast_ident(ast);
    var params = ast_params(ast);
    var is_varargs = ast_varargs(ast);
    ir_add_extern(self, ident, params, is_varargs);
end

def ir_emit_inline_asm self, ast, st, tt in
    // TODO: Check if asm name already defined.
    check_ast_kind(AstK_InlineAsm, ast);
    var asm_name = ast_ident(ast);
    var asm_code = ast_asm(ast);
    ir_append(self, make_ir_inline_asm(asm_name, asm_code));
    set_add(ir_labels(self), asm_name);
end

def ir_emit_global self, ast, st, tt in
    check_ast_kind(AstK_Global, ast);
    var ident = ast_ident(ast);
    if ir_is_global(self, ident) then
        printf("ERROR: global `%s` already defined.\n", ident);
        print_ast_src_loc(ast);
        exit(1);
    end

    var expr = ast_assign_expr(ast);
    var val = ir_comptime_eval(self, expr, st, tt, true, 0);
    var k = ast_kind(val);
    if k == AstK_String then
        ir_add_global_string(self, ident, ast_value(val));
    elif k == AstK_Integer then
        ir_add_global_int(self, ident, ast_value(val));
    else
        NYI_ERR(__FILE__, __LINE__, "ir_emit_global:comptime failed");
    end
end

def ir_emit_break self, ast, st, tt in
    check_ast_kind(AstK_Break, ast);
    var dest = ir_get_break_dest(self);
    if not dest then
        printf("ERROR: 'break' must be within a loop body.\n");
        print_ast_src_loc(ast);
        exit(1);
    end
    ir_append(self, make_ir_goto(dest));
end

def ir_emit_continue self, ast, st, tt in
    check_ast_kind(AstK_Continue, ast);
    var dest = ir_get_continue_dest(self);
    if not dest then
        printf("ERROR: 'continue' must be within a loop body.\n");
        print_ast_src_loc(ast);
        exit(1);
    end
    ir_append(self, make_ir_goto(dest));
end

def ir_emit_struct self, ast, st, tt in
    check_ast_kind(AstK_Struct, ast);
end

def ir_emit_enum self, ast, st, tt in
    check_ast_kind(AstK_Enum, ast);
end

def ir_emit_member_access self, ast, st, tt, deref: bool in
    check_ast_kind(AstK_MemberAccess, ast);

    // Member access is essentially a left-associative binary operator and when
    // they are chained together in the form of `a.b.c.d`, they act as a linked
    // list of more MemberAccess. We can utilize this by walking the list backwards
    // and calculating the exact offset.
    // At some point this will need to be adapted for dereferencing reference types.

    var offset = 0;
    var head = ast;
    var deref_stack = make_vector(0);
    while ast_kind(head) == AstK_MemberAccess do
        var member = ast_member(head);
        var type = tt_get_ast_type(tt, ast_expr(head));
        var struct_type = type;
        while type_is_reference(struct_type) do
            struct_type = type_deref_type(struct_type);
        end
        assert(type_is_struct(struct_type), "Error should have been reported in type checker\n");
        var fields = type_struct_fields(struct_type);
        var field = NULL;
        var i = 0; var len = fields.length;
        while i < len do
            field = vector_get(fields, i);
            if cstr_eq(field_name(field), member) then
                break;
            end
            i += 1;
        end
        // This assert is < and not <= because a successful find breaks early and
        // if i == len, this means we didn't find the field which is either a bug
        // in the type inference or we're trying to emit def lookup which
        // isn't implemented yet.
        assert(i < len, "TODO: update ir_emit_member_access for defs\n");
        assert(field, "Compiler bug: field should not be NULL\n");
        var offs = field_bit_offset(field);
        assert(offs >= 0, "Compiler bug: field offset should be >= 0\n");
        offset += offs;
        if type_is_reference(type) then
            vector_push(deref_stack, offset);
            offset = 0;
        end
        //assert(not type_is_reference(type), "TODO: implement auto-deref reference types\n");
        head = ast_expr(head);
    end
    
    var head_type = tt_get_ast_type(tt, head);
    assert(head_type);
    if type_is_struct(head_type) and ast_kind(head) == AstK_Ident then
        assert(false, "stack allocations not supported yet.\n");
        // var ident = ast_ident(head);
        // if ir_is_local(self, ident) then
        //     var n = ir_get_local(self, ident);
        //     var offs = ir_get_local_offset(self, ident);
        //     ir_append(self, make_ir_ref_local(ident, n, offs));
        // elif ir_is_global(self, ident) then
        //     var gi = ir_get_global(self, ident);
        //     ir_append(self, make_ir_ref_global(ident, global_info_label(gi)));
        // else
        //     assert(false, "TODO: `%s` is not a local nor global, how to get reference?\n", ident);
        // end
    else
        ir_compile(self, head, st, tt);
    end

    if offset != 0 then
        vector_push(deref_stack, offset);
    end
    var i = deref_stack.length - 1;
    while i >= 0 do
        ir_append(self, make_ir_ptr_offs(vector_get(deref_stack, i)));
        if i > 0 then
            ir_append(self, make_ir_ptr_read(PTR_BITS));
        end
        i -= 1;
    end
    free_vector(deref_stack);

    if deref then
        var type = tt_get_ast_type(tt, ast_expr(ast));
        if type_is_reference(type) then
            type = type_deref_type(type);
            assert(type, "TODO: Type is reference but has no ref type\n");
        end
        assert(type_is_struct(type), "TODO: catch this bug in type checker.\n");
        var fields = type_struct_fields(type);
        var i = 0; var len = fields.length;
        var member = ast_member(ast);
        var field;
        while i < len do
            field = vector_get(fields, i);
            if cstr_eq(field_name(field), member) then
                break;
            end
            i += 1;
        end
        var size = type_size(field_type(field));
        assert(size > 0, "Compiler bug: size cannot be zero for auto-deref\n");
        assert(size <= PTR_BITS, "TODO: support larger than memory read: %d\n", size);
        ir_append(self, make_ir_ptr_read(size));
    end
end

def ir_emit_scope_resolve self, ast, st, tt in
    var val = _comptime_scope_resolve_val(self, ast, st, tt, 0);
    ir_compile(self, val, st, tt);
end

def ir_compile self: ir_context, ast: ast, st: SymbolTable&, tt: TypeTable& in
    // comptime eval will just return back the ast node if it's not evaluable
    ast = ir_comptime_eval(self, ast, st, tt, false, 0);
    var k = ast_kind(ast);
    ir_push_src_loc(self, token_src_loc(ast_token(ast)));
    if k == AstK_Ident then ir_emit_ident(self, ast, st, tt);
    elif k == AstK_Integer then ir_emit_integer(self, ast, st, tt);
    elif k == AstK_String then ir_emit_string(self, ast, st, tt);
    elif k == AstK_Call then ir_emit_call(self, ast, st, tt);
    elif k == AstK_BinOp then ir_emit_binop(self, ast, st, tt);
    elif k == AstK_Return then ir_emit_return(self, ast, st, tt);
    elif k == AstK_VarDecl then ir_emit_var_decl(self, ast, st, tt);
    elif k == AstK_VarAssign then ir_emit_var_assign(self, ast, st, tt);
    elif k == AstK_Def then ir_emit_def(self, ast, st, tt);
    elif k == AstK_IfElse then ir_emit_if_else(self, ast, st, tt);
    elif k == AstK_While then ir_emit_while(self, ast, st, tt);
    elif k == AstK_PointerRead then ir_emit_pointer_op(self, ast, st, tt);
    elif k == AstK_PointerWrite then ir_emit_pointer_op(self, ast, st, tt);
    elif k == AstK_Prefix then ir_emit_prefix_op(self, ast, st, tt);
    elif k == AstK_Const then ir_emit_const(self, ast, st, tt);
    elif k == AstK_Extern then ir_emit_extern(self, ast, st, tt);
    elif k == AstK_InlineAsm then ir_emit_inline_asm(self, ast, st, tt);
    elif k == AstK_Global then ir_emit_global(self, ast, st, tt);
    elif k == AstK_Break then ir_emit_break(self, ast, st, tt);
    elif k == AstK_Continue then ir_emit_continue(self, ast, st, tt);
    elif k == AstK_AssignOp then ir_emit_assign_op(self, ast, st, tt);
    elif k == AstK_Struct then ir_emit_struct(self, ast, st, tt);
    elif k == AstK_MemberAccess then ir_emit_member_access(self, ast, st, tt, true);
    elif k == AstK_AssignMember then ir_emit_assign_member(self, ast, st, tt);
    elif k == AstK_Enum then ir_emit_enum(self, ast, st, tt);
    elif k == AstK_ScopeResolve then ir_emit_scope_resolve(self, ast, st, tt);
    else
        printf("`ir_compile` in File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %s (%d)\n", ast_kind_cstr(k), k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
    ir_pop_src_loc(self);
end

def ir_resolve_lazy_idents self in
    var instrs = ir_instructions(self);
    var i = 0; var len = instrs.length;
    var k; var ir; var token;
    var info = NULL;
    while i < len do
        ir = vector_get(instrs, i);
        k = ir_instr_kind(ir);
        if k == IRK_LazyIdent then
            token = ir_instr_ident(ir);
            var symbol = ir_instr_symbol(ir);
            var new_ir;
            if ir_is_const(self, symbol_name(symbol)) then
                info = ir_get_const(self, symbol_name(symbol));
                var cik = const_info_kind(info);
                if cik == CIK_String then
                    new_ir = make_ir_push_label(const_info_value(info));
                elif cik == CIK_Integer then
                    new_ir = make_ir_push_int(const_info_value(info));
                end
            elif ir_is_def(self, symbol_name(symbol)) then
                info = ir_get_def(self, symbol_name(symbol));
                new_ir = make_ir_push_label(def_info_label(info));
            elif ir_is_extern(self, symbol_name(symbol)) then
                info = ir_get_extern(self, symbol_name(symbol));
                new_ir = make_ir_push_label(def_info_label(info));
            elif ir_is_label(self, symbol_name(symbol)) then
                new_ir = make_ir_push_label(symbol_name(symbol));
            else
                printf("ERROR: Undeclared identifier: `%s`\n", symbol_name(symbol));
                print_src_loc(token_src_loc(token));
                exit(1);
            end
            u64!(new_ir + TIR_INSTR_src_loc, token_src_loc(token));
            vector_set(instrs, i, new_ir);
        elif k == IRK_CallLazyIdent then
            token = ir_instr_ident(ir);
            var symbol = ir_instr_symbol(ir);
            var nargs = ir_instr_nargs(ir);
            var call = NULL;
            if ir_is_def(self, symbol_name(symbol)) then
                info = ir_get_def(self, symbol_name(symbol));
                call = make_ir_call(def_info_label(info), def_info_varargs(info));
            elif ir_is_extern(self, symbol_name(symbol)) then
                info = ir_get_extern(self, symbol_name(symbol));
                call = make_ir_call(def_info_label(info), def_info_varargs(info));
            elif ir_is_label(self, symbol_name(symbol)) then
                call = make_ir_call(symbol_name(symbol), false);
            else
                printf("ERROR: Undeclared identifier: `%s`\n", symbol_name(symbol));
                print_src_loc(token_src_loc(token));
                exit(1);
            end
            u64!(call + TIR_INSTR_src_loc, token_src_loc(token));
            vector_set(instrs, i, call);
        end
        i += 1;
    end
end

def ir_compile_roots self: ir_context, roots: Vector&, symbol_table: SymbolTable&, type_table: TypeTable&, compile_order: Vector& in

    if false then
        // compile everything in order
        var i = 0; var len = roots.length;
        while i < len do
            ir_compile(self, vector_get(roots, i), symbol_table, type_table);
            i += 1;
        end
    else
        // or only compile the call/reference graph
        var i = 0; var len = compile_order.length;
        while i < len do
            ir_compile(self, vector_get(compile_order, i), symbol_table, type_table);
            i += 1;
        end
    end

    ir_resolve_lazy_idents(self);
end

def check_ir_kind expect, ir in
    var actual = ir_instr_kind(ir);
    if expect != actual then
        printf("check_ir_kind failed: expected %s, actual was %s\n",
            ir_instr_kind_cstr(expect),
            ir_instr_kind_cstr(actual));
        abort();
    end
end

def ir_print_whole_ir self: ir_context in
    var instrs = ir_instructions(self);
    var i = 0; var len = instrs.length;
    while i < len do
        print_ir(vector_get(instrs, i));
        i += 1;
    end
end
