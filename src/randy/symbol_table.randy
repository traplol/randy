
const SK_undef  = 0;
const SK_const  = 1;
const SK_global = 2;
const SK_proc   = 3;
const SK_extern = 4;
const SK_asm    = 5;
const SK_param  = 6;
const SK_local  = 7;

const TSYMBOL_kind   = 0;  // SK
const TSYMBOL_name   = 8;  // cstr
const TSYMBOL_token  = 16; // token
const TSYMBOL_type   = 24; // type
const sizeof_TSYMBOL = 32;

proc make_symbol kind: int, name: cstr, token: token -> symbol in
    var self = malloc(sizeof_TSYMBOL);
    u64!(self + TSYMBOL_kind, kind);
    u64!(self + TSYMBOL_name, name);
    u64!(self + TSYMBOL_token, token);
    u64!(self + TSYMBOL_type, NULL);
    return cast(self, symbol);
end

proc symbol_kind self: symbol -> int in return cast(u64@(self + TSYMBOL_kind), int); end
proc symbol_name self: symbol -> cstr in return cast(u64@(self + TSYMBOL_name), cstr); end
proc symbol_token self: symbol -> token in return cast(u64@(self + TSYMBOL_token), token); end
proc symbol_type self: symbol -> type in return cast(u64@(self + TSYMBOL_type), type); end

proc symbol_set_kind self: symbol, kind: int in u64!(self + TSYMBOL_kind, kind); end
proc symbol_set_type self: symbol, type: type in u64!(self + TSYMBOL_type, type); end

proc symbol_is_undef self: symbol in return symbol_kind(self) == SK_undef; end
proc symbol_is_const self: symbol in return symbol_kind(self) == SK_const; end
proc symbol_is_global self: symbol in return symbol_kind(self) == SK_global; end
proc symbol_is_proc self: symbol in return symbol_kind(self) == SK_proc; end
proc symbol_is_extern self: symbol in return symbol_kind(self) == SK_extern; end
proc symbol_is_asm self: symbol in return symbol_kind(self) == SK_asm; end
proc symbol_is_param self: symbol in return symbol_kind(self) == SK_param; end
proc symbol_is_local self: symbol in return symbol_kind(self) == SK_local; end

// This symbol table keeps track of identifiers relative to scope and internalizes
// those idents to a specific id. In this case the id happens to be the same cstr
// that was generated by the lexer for the first occurence of a symbol.
const TSYMBOL_TABLE_table = 0; // (id, symbol) map : all symbols
const TSYMBOL_TABLE_scope = 8; // (cstr, ptr) map Vector& : scope resolution for identifiers to symbols
const sizeof_TSYMBOL_TABLE = 16;

proc make_symbol_table -> symbol_table in
    var self = malloc(sizeof_TSYMBOL_TABLE);
    u64!(self + TSYMBOL_TABLE_table, make_map(0, NULL, NULL));
    u64!(self + TSYMBOL_TABLE_scope, make_vector(0));
    return cast(self, symbol_table);
end

proc symbol_table_table self: symbol_table in return cast(u64@(self + TSYMBOL_TABLE_table), map); end
proc symbol_table_scope self: symbol_table in return cast(u64@(self + TSYMBOL_TABLE_scope), Vector&); end

proc st_make_symbol self: symbol_table, kind: int, ident: cstr, token: token -> symbol in
    var table = symbol_table_table(self);
    var found = map_find(table, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a symbol that already exists: `%s`\n", ident);
    end

    var local_scope = vector_back(symbol_table_scope(self));
    found = map_find(local_scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a local symbol that already exists: `%s`\n", ident);
    end
    var symbol = make_symbol(kind, ident, token);
    map_set(table, ident, symbol);
    map_set(local_scope, ident, symbol);
    return symbol;
end

proc st_make_const self, ident, token in
    return st_make_symbol(self, SK_const, ident, token);
end
proc st_make_global self, ident, token in
    return st_make_symbol(self, SK_global, ident, token);
end
proc st_make_proc self, ident, token in
    return st_make_symbol(self, SK_proc, ident, token);
end
proc st_make_extern self, ident, token in
    return st_make_symbol(self, SK_extern, ident, token);
end
proc st_make_asm self, ident, token in
    return st_make_symbol(self, SK_asm, ident, token);
end
proc st_make_param self, ident, token in
    return st_make_symbol(self, SK_param, ident, token);
end
proc st_make_local self, ident, token in
    return st_make_symbol(self, SK_local, ident, token);
end

proc st_prepare_undef self, ident, token in
    var table = symbol_table_table(self);
    var found = map_find(table, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end

    var scope = vector_get(symbol_table_scope(self), 0);
    found = map_find(scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end
    var symbol = make_symbol(SK_undef, ident, token);
    map_set(table, ident, symbol);
    map_set(scope, ident, symbol);
    return symbol;
end

proc st_get_symbol self, ident in
    var scope = symbol_table_scope(self);
    var i = scope.length - 1;
    while i >= 0 do
        var found = map_find(vector_get(scope, i), ident);
        if found then
            return map_pair_val(found);
        end
        i -= 1;
    end
    var found = map_find(symbol_table_table(self), ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc st_get_symbol_here self, ident in
    var scope = vector_back(symbol_table_scope(self));
    var found = map_find(scope, ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc st_push_scope self in
    vector_push(symbol_table_scope(self), make_map(0, cstr_eq, cstr_hash));
end

proc st_pop_scope self in
    var scope = symbol_table_scope(self);
    var map = vector_back(scope);
    vector_pop(scope);
    free_map(map);
end

proc st_depth self in
    return symbol_table_scope(self).length;
end
