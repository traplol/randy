
enum SymbolKind in
    Undef;
    Const;
    Global;
    Def;
    Extern;
    Asm;
    Param;
    Local;
    Enum;
end

struct Symbol in
    kind: SymbolKind;
    name: cstr;
    token: Token&;
    type: Type&;
    owned_by: Type&;
    // symbols don't necessarily need a label but this makes it easier to generate
    // and lookup globals/externs/functions
    label: cstr;
    is_varargs: bool;
end

def make_symbol kind: SymbolKind, name: cstr, token: Token& -> Symbol& in
    var self = cast(malloc(__sizeof(Symbol)), Symbol&);
    self.kind = kind;
    self.name = name;
    self.token = token;
    self.type = NULL;
    self.owned_by = NULL;
    self.label = NULL;
    self.is_varargs = false;
    return self;
end

def symbol_kind self: Symbol& -> SymbolKind in return self.kind; end
def symbol_name self: Symbol& -> cstr in return self.name; end
def symbol_token self: Symbol& -> Token& in return self.token; end
def symbol_type self: Symbol& -> Type& in return self.type; end

def symbol_set_kind self: Symbol&, kind: SymbolKind in self.kind = kind; end
def symbol_set_type self: Symbol&, type: Type& in self.type = type; end

def symbol_is_undef self: Symbol& in return self.kind == SymbolKind::Undef; end
def symbol_is_const self: Symbol& in return self.kind == SymbolKind::Const; end
def symbol_is_global self: Symbol& in return self.kind == SymbolKind::Global; end
def symbol_is_def self: Symbol& in return self.kind == SymbolKind::Def; end
def symbol_is_extern self: Symbol& in return self.kind == SymbolKind::Extern; end
def symbol_is_asm self: Symbol& in return self.kind == SymbolKind::Asm; end
def symbol_is_param self: Symbol& in return self.kind == SymbolKind::Param; end
def symbol_is_local self: Symbol& in return self.kind == SymbolKind::Local; end
def symbol_is_enum self: Symbol& in return self.kind == SymbolKind::Enum; end

// This symbol table keeps track of identifiers relative to scope and internalizes
// those idents to a specific id. In this case the id happens to be the same cstr
// that was generated by the lexer for the first occurence of a symbol.
struct SymbolTable in
    all_symbols: map; // (id, symbol) map : all symbols
    scope: Vector[map]&; // (cstr, ptr) map Vector& : scope resolution for identifiers to symbols
end

def make_symbol_table -> SymbolTable& in
    var self = cast(malloc(__sizeof(SymbolTable)), SymbolTable&);
    self.all_symbols = make_map(0, NULL, NULL);
    self.scope = Vector[map]::new(0);
    return self;
end

def st_make_symbol self: SymbolTable&, kind: SymbolKind, ident: cstr, token: Token& -> Symbol& in
    var found = map_find(self.all_symbols, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a (%d) symbol that already exists: `%s`\n", kind, ident);
    end

    var local_scope = self.scope.back();
    found = map_find(local_scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a local (%d) symbol that already exists: `%s`\n", kind, ident);
    end
    var symbol = make_symbol(kind, ident, token);
    map_set(self.all_symbols, ident, symbol);
    map_set(local_scope, ident, symbol);
    return symbol;
end

def st_make_const self, ident, token in
    return st_make_symbol(self, SymbolKind::Const, ident, token);
end
def st_make_global self, ident, token in
    return st_make_symbol(self, SymbolKind::Global, ident, token);
end
def st_make_def self, ident, token in
    return st_make_symbol(self, SymbolKind::Def, ident, token);
end
def st_make_extern self, ident, token in
    return st_make_symbol(self, SymbolKind::Extern, ident, token);
end
def st_make_asm self, ident, token in
    return st_make_symbol(self, SymbolKind::Asm, ident, token);
end
def st_make_param self, ident, token in
    return st_make_symbol(self, SymbolKind::Param, ident, token);
end
def st_make_local self, ident, token in
    return st_make_symbol(self, SymbolKind::Local, ident, token);
end
def st_make_enum self, ident, token in
    return st_make_symbol(self, SymbolKind::Enum, ident, token);
end

def st_prepare_undef self, ident, token in
    var found = map_find(self.all_symbols, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end

    var top_scope = self.scope.front();
    found = map_find(top_scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end
    var symbol = make_symbol(SymbolKind::Undef, ident, token);
    map_set(self.all_symbols, ident, symbol);
    map_set(top_scope, ident, symbol);
    return symbol;
end

def st_get_symbol self, ident -> Symbol& in
    var i = self.scope.length - 1;
    while i >= 0 do
        var found = map_find(self.scope.get(i), ident);
        if found then
            return map_pair_val(found);
        end
        i -= 1;
    end
    var found = map_find(self.all_symbols, ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def st_get_symbol_here self, ident -> Symbol& in
    var found = map_find(self.scope.back(), ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def st_get_exact_symbol self, ident -> Symbol& in
    var found = map_find(self.all_symbols, ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

def st_push_scope self in
    self.scope.push(make_map(0, cstr_eq, cstr_hash));
end

def st_pop_scope self in
    var map = self.scope.back();
    self.scope.pop();
    free_map(map);
end

def st_depth self in
    return self.scope.length;
end
