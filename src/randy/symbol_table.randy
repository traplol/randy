
enum SymbolKind in
    Undef;
    Const;
    Global;
    Proc;
    Extern;
    Asm;
    Param;
    Local;
    Enum;
end

struct Symbol in
    kind: SymbolKind;
    name: cstr;
    token: Token&;
    type: type;
    owned_by: type;
end

proc make_symbol kind: SymbolKind, name: cstr, token: Token& -> Symbol& in
    var self = cast(malloc(__sizeof(Symbol)), Symbol&);
    self.kind = kind;
    self.name = name;
    self.token = token;
    self.type = NULL;
    self.owned_by = NULL;
    return self;
end

proc symbol_kind self: Symbol& -> SymbolKind in return self.kind; end
proc symbol_name self: Symbol& -> cstr in return self.name; end
proc symbol_token self: Symbol& -> Token& in return self.token; end
proc symbol_type self: Symbol& -> type in return self.type; end

proc symbol_set_kind self: Symbol&, kind: SymbolKind in self.kind = kind; end
proc symbol_set_type self: Symbol&, type: type in self.type = type; end

proc symbol_is_undef self: Symbol& in return self.kind == SymbolKind::Undef; end
proc symbol_is_const self: Symbol& in return self.kind == SymbolKind::Const; end
proc symbol_is_global self: Symbol& in return self.kind == SymbolKind::Global; end
proc symbol_is_proc self: Symbol& in return self.kind == SymbolKind::Proc; end
proc symbol_is_extern self: Symbol& in return self.kind == SymbolKind::Extern; end
proc symbol_is_asm self: Symbol& in return self.kind == SymbolKind::Asm; end
proc symbol_is_param self: Symbol& in return self.kind == SymbolKind::Param; end
proc symbol_is_local self: Symbol& in return self.kind == SymbolKind::Local; end
proc symbol_is_enum self: Symbol& in return self.kind == SymbolKind::Enum; end

// This symbol table keeps track of identifiers relative to scope and internalizes
// those idents to a specific id. In this case the id happens to be the same cstr
// that was generated by the lexer for the first occurence of a symbol.
struct SymbolTable in
    table: map; // (id, symbol) map : all symbols
    scope: Vector&; // (cstr, ptr) map Vector& : scope resolution for identifiers to symbols
end

proc make_symbol_table -> SymbolTable& in
    var self = cast(malloc(__sizeof(SymbolTable)), SymbolTable&);
    self.table = make_map(0, NULL, NULL);
    self.scope = make_vector(0);
    return self;
end

proc symbol_table_table self: SymbolTable& in return self.table; end
proc symbol_table_scope self: SymbolTable& in return self.scope; end

proc st_make_symbol self: SymbolTable&, kind: SymbolKind, ident: cstr, token: Token& -> Symbol& in
    var table = symbol_table_table(self);
    var found = map_find(table, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a symbol that already exists: `%s`\n", ident);
    end

    var local_scope = vector_back(symbol_table_scope(self));
    found = map_find(local_scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making a local symbol that already exists: `%s`\n", ident);
    end
    var symbol = make_symbol(kind, ident, token);
    map_set(table, ident, symbol);
    map_set(local_scope, ident, symbol);
    return symbol;
end

proc st_make_const self, ident, token in
    return st_make_symbol(self, SymbolKind::Const, ident, token);
end
proc st_make_global self, ident, token in
    return st_make_symbol(self, SymbolKind::Global, ident, token);
end
proc st_make_proc self, ident, token in
    return st_make_symbol(self, SymbolKind::Proc, ident, token);
end
proc st_make_extern self, ident, token in
    return st_make_symbol(self, SymbolKind::Extern, ident, token);
end
proc st_make_asm self, ident, token in
    return st_make_symbol(self, SymbolKind::Asm, ident, token);
end
proc st_make_param self, ident, token in
    return st_make_symbol(self, SymbolKind::Param, ident, token);
end
proc st_make_local self, ident, token in
    return st_make_symbol(self, SymbolKind::Local, ident, token);
end
proc st_make_enum self, ident, token in
    return st_make_symbol(self, SymbolKind::Enum, ident, token);
end

proc st_prepare_undef self, ident, token in
    var table = symbol_table_table(self);
    var found = map_find(table, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end

    var scope = vector_get(symbol_table_scope(self), 0);
    found = map_find(scope, ident);
    if found then
        print_token_loc(token);
        assert(false, "Compiler bug: making an undef symbol that already exists: `%s`\n", ident);
    end
    var symbol = make_symbol(SymbolKind::Undef, ident, token);
    map_set(table, ident, symbol);
    map_set(scope, ident, symbol);
    return symbol;
end

proc st_get_symbol self, ident in
    var scope = symbol_table_scope(self);
    var i = scope.length - 1;
    while i >= 0 do
        var found = map_find(vector_get(scope, i), ident);
        if found then
            return map_pair_val(found);
        end
        i -= 1;
    end
    var found = map_find(symbol_table_table(self), ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc st_get_symbol_here self, ident in
    var scope = vector_back(symbol_table_scope(self));
    var found = map_find(scope, ident);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc st_push_scope self in
    vector_push(symbol_table_scope(self), make_map(0, cstr_eq, cstr_hash));
end

proc st_pop_scope self in
    var scope = symbol_table_scope(self);
    var map = vector_back(scope);
    vector_pop(scope);
    free_map(map);
end

proc st_depth self in
    return symbol_table_scope(self).length;
end
