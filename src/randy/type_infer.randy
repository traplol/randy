// handle a minimal amount of errors here, defer most type errors to the type checker.

const TTYPE_INFER_cur_procs   = 0;  // stack of procs
const TTYPE_INFER_did_returns = 8;  // stack of bools
const TTYPE_INFER_again       = 16; // set of proc symbols
const sizeof_TTYPE_INFER = 24;

proc make_type_infer -> type_infer in
    var self = malloc(sizeof_TTYPE_INFER);
    u64!(self + TTYPE_INFER_cur_procs, make_vector(0));
    u64!(self + TTYPE_INFER_did_returns, make_string(0));
    u64!(self + TTYPE_INFER_again, make_set(0, NULL, NULL));
    return cast(self, type_infer);
end

proc type_infer_cur_procs self: type_infer in
    return cast(u64@(self + TTYPE_INFER_cur_procs), vector);
end
proc type_infer_did_returns self: type_infer in
    return cast(u64@(self + TTYPE_INFER_did_returns), string);
end
proc type_infer_again self: type_infer in
    return cast(u64@(self + TTYPE_INFER_again), set);
end
proc type_infer_set_again self: type_infer, set: set in
    u64!(self + TTYPE_INFER_again, set);
end

proc free_type_infer self: type_infer in
    if self then
        free_vector(type_infer_cur_procs(self));
        free_string(type_infer_did_returns(self));
        free_set(type_infer_again(self));
        free(self);
    end
end

proc ti_current_proc self in
    return vector_back(type_infer_cur_procs(self));
end

proc ti_did_return self in
    return string_back(type_infer_did_returns(self));
end

proc ti_set_did_return self, val in
    var str = type_infer_did_returns(self);
    var len = string_len(str);
    if len > 0 then
        string_set(str, len-1, val);
    end
end

proc ti_push_proc self, proc_symbol in
    vector_push(type_infer_cur_procs(self), proc_symbol);
    string_push(type_infer_did_returns(self), 0);
end

proc ti_pop_proc self in
    vector_pop(type_infer_cur_procs(self));
    string_pop(type_infer_did_returns(self));
end

proc ti_infer_body self, tt, st, body in
    var i = 0; var len = vector_len(body);
    while i < len do
        var ast = vector_get(body, i);
        ti_infer(self, tt, st, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc ti_infer_ident self, tt, st, ast -> type in
    check_ast_kind(AstK_Ident, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    var type = symbol_type(symbol);
    if type then
        return type;
    else
        symbol_set_type(symbol, tt_any_type(tt));
    end
    return tt_any_type(tt);
end

proc ti_infer_integer self, tt, st, ast -> type in
    check_ast_kind(AstK_Integer, ast);
    return tt_int_type(tt);
end

proc ti_infer_string self, tt, st, ast -> type in
    check_ast_kind(AstK_String, ast);
    return tt_cstr_type(tt);
end

proc ti_infer_call self, tt, st, ast -> type in
    check_ast_kind(AstK_Call, ast);
    var expr = ast_expr(ast);
    var call_type = ti_infer(self, tt, st, expr);
    var any = tt_any_type(tt);
    // TODO: put this check in type checker
    if not type_is_procedure(call_type) then
        // FIXME: call_type should not accept ptr when type system is more fleshed out.
        if call_type != any and call_type != tt_ptr_type(tt) then
            printf("WARN: type `");
            _ti_print_type_name(tt, call_type);
            printf("` is not a procedure.\n");
            printf("NOTE: The expression is: ");
            print_ast(ast);
            print_token_loc(ast_token(ast));
        end
        return tt_any_type(tt);
    end
    if ast_kind(expr) != AstK_Ident then
        return type_proc_return_type(call_type);
    end
    var call_symbol = st_get_symbol(st, ast_ident(expr));
    if not symbol_is_proc(call_symbol) then
        return type_proc_return_type(call_type);
    end
    call_type = symbol_type(call_symbol);
    assert(type_is_procedure(call_type), "call_type not procedure");

    // TODO: need to handle varargs at some point
    var ret_type = type_proc_return_type(call_type);
    var param_syms = type_proc_parameters(call_type);
    var args = ast_args(ast);
    var i = 0; var len = min(vector_len(param_syms), vector_len(args));
    var changed = false;
    while i < len do
        var arg_type = ti_infer(self, tt, st, vector_get(args, i));
        var par_sym = vector_get(param_syms, i);
        if symbol_type(par_sym) == any and arg_type != any then
            symbol_set_type(par_sym, arg_type);
            changed = true;
        end
        i += 1;
    end
    if changed then
        var proc_ast = type_ast(call_type);
        if proc_ast then
            set_add(type_infer_again(self), call_symbol);
        end
    end
    return ret_type;
end

proc ti_infer_binop self, tt, st, ast -> type in
    check_ast_kind(AstK_BinOp, ast);
    var lhs: type = ti_infer(self, tt, st, ast_lhs(ast));
    var rhs: type = ti_infer(self, tt, st, ast_rhs(ast));
    var any = tt_any_type(tt);
    var int = tt_int_type(tt);
    var cstr = tt_cstr_type(tt);
    var ptr = tt_ptr_type(tt);
    var char = tt_char_type(tt);

    var op = ast_op(ast);
    if op == TK_Less or op == TK_LessEq or op == TK_Greater or op == TK_GreaterEq or
        op == TK_EqEq or op == TK_NotEq then
        return tt_bool_type(tt);
    end

    if lhs == any and rhs == any then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    end

    if lhs == rhs then
        return lhs;
    end

    if lhs == any and rhs == int then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        return int;
    end

    if lhs == cstr and rhs == int then
        return cstr;
    end

    if lhs == int and rhs == cstr then
        return cstr;
    end

    if lhs == int and rhs == any then
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    end

    if lhs == ptr and rhs == int then
        return ptr;
    end

    if lhs == int and rhs == ptr then
        return ptr;
    end

    if lhs == char and rhs == int then
        return int;
    end

    if lhs == int and rhs == char then
        return int;
    end
        
    return tt_any_type(tt);
end

proc _ti_print_type_name tt, type in
    if type then
        if type_is_procedure(type) then
            var string = tt_get_proc_type_name(tt, type);
            printf("%s", string_cstr(string));
            free_string(string);
        else
            printf("%s", tt_get_type_name(tt, type));
        end
    else
        printf("{no type}");
    end
end

proc ti_infer_return self, tt, st, ast -> type in
    check_ast_kind(AstK_Return, ast);
    var type;
    if ast_expr(ast) then
        type = ti_infer(self, tt, st, ast_expr(ast));
    else
        type = tt_void_type(tt);
    end
    var cur_proc = ti_current_proc(self);
    var proc_type = symbol_type(cur_proc);
    assert(type_is_procedure(proc_type), "proc_type not procedure type");
    var ret_type = type_proc_return_type(proc_type);
    var any = tt_any_type(tt);
    if not ret_type or ret_type == any then
        type_set_proc_return_type(proc_type, type);
    elif not types_assignable(tt, type, ret_type) then
        printf("WARN: Return type for `%s` is `", symbol_name(cur_proc));
        _ti_print_type_name(tt, ret_type);
        printf("` cannot return `");
        _ti_print_type_name(tt, type);
        printf(".`\nNOTE: The expression is: ");
        print_ast(ast);
        print_token_loc(ast_token(ast));
        //exit(1);
    end
    ti_set_did_return(self, true);
    return tt_void_type(tt);
end

proc ti_infer_var_decl self, tt, st, ast -> type in
    check_ast_kind(AstK_VarDecl, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    if not symbol_type(symbol) then
        symbol_set_type(symbol, tt_any_type(tt));
    end
    return tt_void_type(tt);
end

proc _ti_infer_assignment tt, symbol, rhs_type, rhs_expr -> type in
    var sym_type = symbol_type(symbol);
    if not sym_type or sym_type == tt_any_type(tt) then
        symbol_set_type(symbol, rhs_type);
    elif rhs_type == tt_any_type(tt) then
        // @HACK This is most likely incorrect
        tt_set_ast_type(tt, rhs_expr, sym_type);
    elif not types_assignable(tt, sym_type, rhs_type) then
        printf("WARN: type of `%s` is `", symbol_name(symbol));
        _ti_print_type_name(tt, sym_type);
        printf("` cannot assign `");
        _ti_print_type_name(tt, rhs_type);
        printf(".`\nNOTE: The expression is: ");
        print_ast(rhs_expr);
        print_token_loc(ast_token(rhs_expr));
        //exit(1);
    end
end

proc ti_infer_var_assign self, tt, st, ast -> type in
    check_ast_kind(AstK_VarAssign, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

proc ti_infer_assign_op self, tt, st, ast -> type in
    check_ast_kind(AstK_AssignOp, ast);
    var op = ast_op(ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));

    if op != TK_Assign and not type_is_primitive(type) then
        printf("WARN: `");
        _ti_print_type_name(tt, type);
        printf("` is not a primitive type and cannot be used with TODO: get operator string\n");
        printf(".`\nNOTE: The expression is: ");
        print_ast(ast);
        print_token_loc(ast_token(ast));
        //exit(1);
        return tt_void_type(tt);
    end

    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    var sym_type = symbol_type(symbol);

    if op == TK_Assign then
        _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    end
    return tt_void_type(tt);
end

proc ti_infer_procedure self, tt, st, ast -> type in
    check_ast_kind(AstK_Procedure, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    ti_push_proc(self, symbol);
    ti_infer_body(self, tt, st, ast_body(ast));
    var proc_type = symbol_type(symbol);
    assert(type_is_procedure(proc_type),
           "Compiler bug: procedure type is not actually procedure type.\n");
    // don't handle the case where function is declared with a type but doesn't return here
    // because we'll let the IR compiler determine that.
    // it'just needless complexity to deal with checking every branch for returns here.
    if not ti_did_return(self) and type_proc_return_type(proc_type) == tt_any_type(tt) then
        type_set_proc_return_type(proc_type, tt_void_type(tt));
    end
    ti_pop_proc(self);
    return tt_void_type(tt);
end

proc ti_infer_if_else self, tt, st, ast -> type in
    check_ast_kind(AstK_IfElse, ast);
    // TODO: check test is bool compatible
    ti_infer(self, tt, st, ast_test(ast));
    ti_infer_body(self, tt, st, ast_consequence(ast));
    ti_infer_body(self, tt, st, ast_alternative(ast));
    return tt_void_type(tt);
end

proc ti_infer_while self, tt, st, ast -> type in
    check_ast_kind(AstK_While, ast);
    // TODO: check test is bool compatible
    ti_infer(self, tt, st, ast_test(ast));
    ti_infer_body(self, tt, st, ast_body(ast));
    return tt_void_type(tt);
end

proc ti_infer_pointer_read self, tt, st, ast -> type in
    check_ast_kind(AstK_PointerRead, ast);
    var args = ast_pop_args(ast);
    return ti_infer(self, tt, st, vector_get(args, 0));
end

proc ti_infer_pointer_write self, tt, st, ast -> type in
    check_ast_kind(AstK_PointerWrite, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        ti_infer(self, tt, st, vector_get(args, i));
        i += 1;
    end
    return tt_void_type(tt);
end

proc ti_infer_prefix_op self, tt, st, ast -> type in
    check_ast_kind(AstK_Prefix, ast);
    var t = ti_infer(self, tt, st, ast_expr(ast));
    if ast_op == TK_KW_not then
        // TODO: check t is "bool"-able: int variants, ptr, cstr, etc
        return tt_bool_type(tt);
    end
    return t;
end

proc ti_infer_const self, tt, st, ast -> type in
    check_ast_kind(AstK_Const, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

proc ti_infer_extern self, tt, st, ast -> type in
    check_ast_kind(AstK_Extern, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc ti_infer_inline_asm self, tt, st, ast -> type in
    check_ast_kind(AstK_InlineAsm, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc ti_infer_global self, tt, st, ast -> type in
    check_ast_kind(AstK_Global, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

proc ti_infer_cast self, tt, st, ast -> type in
    check_ast_kind(AstK_Cast, ast);
    ti_infer(self, tt, st, ast_expr(ast));
    return ast_type(ast);
end

proc ti_infer self, tt, st, ast -> type in
    var k = ast_kind(ast);
    var type: type;
    if k == AstK_Ident then type = ti_infer_ident(self, tt, st, ast);
    elif k == AstK_Integer then type = ti_infer_integer(self, tt, st, ast);
    elif k == AstK_String then type = ti_infer_string(self, tt, st, ast);
    elif k == AstK_Call then type = ti_infer_call(self, tt, st, ast);
    elif k == AstK_BinOp then type = ti_infer_binop(self, tt, st, ast);
    elif k == AstK_Return then type = ti_infer_return(self, tt, st, ast);
    elif k == AstK_VarDecl then type = ti_infer_var_decl(self, tt, st, ast);
    elif k == AstK_VarAssign then type = ti_infer_var_assign(self, tt, st, ast);
    elif k == AstK_Procedure then type = ti_infer_procedure(self, tt, st, ast);
    elif k == AstK_IfElse then type = ti_infer_if_else(self, tt, st, ast);
    elif k == AstK_While then type = ti_infer_while(self, tt, st, ast);
    elif k == AstK_PointerRead then type = ti_infer_pointer_read(self, tt, st, ast);
    elif k == AstK_PointerWrite then type = ti_infer_pointer_write(self, tt, st, ast);
    elif k == AstK_Prefix then type = ti_infer_prefix_op(self, tt, st, ast);
    elif k == AstK_Const then type = ti_infer_const(self, tt, st, ast);
    elif k == AstK_Extern then type = ti_infer_extern(self, tt, st, ast);
    elif k == AstK_InlineAsm then type = ti_infer_inline_asm(self, tt, st, ast);
    elif k == AstK_Global then type = ti_infer_global(self, tt, st, ast);
    elif k == AstK_Break then type = tt_void_type(tt);
    elif k == AstK_Continue then type = tt_void_type(tt);
    elif k == AstK_AssignOp then type = ti_infer_assign_op(self, tt, st, ast);
    elif k == AstK_Cast then type = ti_infer_cast(self, tt, st, ast);
    elif k == AstK_Struct then type = tt_void_type(tt);
    else
        printf("`ti_infer` in File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
    tt_set_ast_type(tt, ast, type);
    return type;
end

proc ti_indent indent in
    while indent > 0 do
        printf(" ");
        indent -= 1;
    end
end

proc ti_walk_1 self, tt, st, stmt, indent, seen, compile_order in
    if not stmt then
        return;
    end
    var k = ast_kind(stmt);
    if k == AstK_Call then
        ti_walk_vector(self, tt, st, ast_args(stmt), indent, seen, compile_order);

        var expr = ast_expr(stmt);
        if ast_kind(expr) == AstK_Ident then
            var sym = st_get_symbol(st, ast_ident(expr));
            if symbol_is_proc(sym) then
                if set_contains(seen, sym) then
                    return;
                end
                set_add(seen, sym);
                var type = symbol_type(sym);
                assert(type, "Type for %s was null.\n", symbol_name(sym));
                var proc_ = type_ast(type);
                assert(proc_, "AST for symbol %s was null\n", symbol_name(sym));
                ti_walk_proc(self, tt, st, proc_, indent + 1, seen, compile_order);
            end
        end
    elif k == AstK_BinOp then
        ti_walk_1(self, tt, st, ast_lhs(stmt), indent, seen, compile_order);
        ti_walk_1(self, tt, st, ast_rhs(stmt), indent, seen, compile_order);
    elif k == AstK_Return then
        ti_walk_1(self, tt, st, ast_expr(stmt), indent, seen, compile_order);
    elif k == AstK_VarAssign then
        ti_walk_1(self, tt, st, ast_assign_expr(stmt), indent, seen, compile_order);
    elif k == AstK_IfElse then
        ti_walk_vector(self, tt, st, ast_consequence(stmt), indent, seen, compile_order);
        ti_walk_vector(self, tt, st, ast_alternative(stmt), indent, seen, compile_order);
    elif k == AstK_While then
        ti_walk_vector(self, tt, st, ast_body(stmt), indent, seen, compile_order);
    elif k == AstK_PointerRead then
        ti_walk_1(self, tt, st, vector_get(ast_pop_args(stmt), 0), indent, seen, compile_order);
    elif k == AstK_PointerWrite then
        ti_walk_1(self, tt, st, vector_get(ast_pop_args(stmt), 0), indent, seen, compile_order);
        ti_walk_1(self, tt, st, vector_get(ast_pop_args(stmt), 1), indent, seen, compile_order);
    elif k == AstK_Prefix then
        ti_walk_1(self, tt, st, ast_expr(stmt), indent, seen, compile_order);
    elif k == AstK_AssignOp then
        ti_walk_1(self, tt, st, ast_assign_expr(stmt), indent, seen, compile_order);
    elif k == AstK_Cast then
        ti_walk_1(self, tt, st, ast_expr(stmt), indent, seen, compile_order);
    elif k == AstK_MemberAccess then
        ti_walk_1(self, tt, st, ast_expr(stmt), indent, seen, compile_order);
    end
end

proc ti_walk_vector self, tt, st, vector, indent, seen, compile_order in
    var i = 0; var len = vector_len(vector);
    while i < len do
        var stmt = vector_get(vector, i);
        ti_walk_1(self, tt, st, stmt, indent, seen, compile_order);
        i += 1;
    end
end

proc ti_walk_proc self, tt, st, proc_, indent, seen, compile_order in
    //ti_indent(indent);
    //printf("proc: %s ->\n", ast_ident(proc_));
    ti_walk_vector(self, tt, st, ast_body(proc_), indent + 1, seen, compile_order);
    vector_push(compile_order, proc_);
end

proc type_infer type_table, symbol_table, roots in
    var compile_order = make_vector(128);
    var self = make_type_infer();
    var i = 0; var len = vector_len(roots);
    var main_proc = NULL;
    while i < len do
        var ast = vector_get(roots, i);
        if ast_kind(ast) == AstK_Procedure and cstr_eq("main", ast_ident(ast)) then
            main_proc = ast;
            var seen = make_set(0, NULL, NULL);
            ti_walk_proc(self, type_table, symbol_table, ast, 0, seen, compile_order);
            free_set(seen);
            break;
        end
        i += 1;
    end

    i = 0; len = vector_len(roots);
    while i < len do
        var ast = vector_get(roots, i);
        if ast_kind(ast) != AstK_Procedure then
            ti_infer(self, type_table, symbol_table, vector_get(roots, i));
        end
        i += 1;
    end

    i = 0; len = vector_len(compile_order);
    while i < len do
        ti_infer(self, type_table, symbol_table, vector_get(compile_order, i));
        i += 1;
    end

    while true do
        var again = type_infer_again(self);
        if set_len(again) == 0 then
            break;
        end
        type_infer_set_again(self, make_set(0, NULL, NULL));
        var cur = set_begin(again);
        while cur != set_end(again) do
            var sym = u64@(cur);
            var typ = symbol_type(sym);
            var ast = type_ast(typ);
            assert(ast, "ast from type_infer_again should not be null");
            ti_infer(self, type_table, symbol_table, ast);
            cur = set_next(again, cur);
        end
        free_set(again);
    end

    if main_proc then
        ti_infer(self, type_table, symbol_table, main_proc);
    end

    // i = 0; len = vector_len(compile_order);
    // while i < len do
    //     var proc_ = vector_get(compile_order, i);
    //     var sym = st_get_symbol(symbol_table, ast_ident(proc_));
    //     var typ = symbol_type(sym);
    //     assert(typ);
    //     assert(type_is_procedure(typ));
    //     var name = tt_get_proc_type_name(type_table, typ);
    //     printf("%d: %s : %s\n", i, ast_ident(proc_), string_cstr(name));
    //     free_string(name);
    //     i += 1;
    // end

    free_type_infer(self);
end
