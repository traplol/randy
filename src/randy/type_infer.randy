// handle a minimal amount of errors here, defer most type errors to the type checker.

struct TypeInfer in
    cur_defs: Vector[Symbol&]&;
    did_returns: String&;
    again: set;
end

def make_type_infer -> TypeInfer& in
    var self: TypeInfer& = malloc(__sizeof(TypeInfer));
    self.cur_defs = Vector[Symbol&]::new(0);
    self.did_returns = String::new(0);
    self.again = make_set(0, NULL, NULL);
    return self;
end

def free_type_infer self: TypeInfer& in
    if self then
        self.cur_defs.delete();
        self.did_returns.delete();
        free_set(self.again);
        free(self);
    end
end

def ti_current_def self in
    return self.cur_defs.back();
end

def ti_did_return self in
    return self.did_returns.back();
end

def ti_set_did_return self, val in
    var str = self.did_returns;
    var len = str.length;
    if len > 0 then
        str.set(len - 1, val);
    end
end

def ti_push_def self, def_symbol in
    self.cur_defs.push(def_symbol);
    self.did_returns.push(0);
end

def ti_pop_def self in
    self.cur_defs.pop();
    self.did_returns.pop();
end

def ti_infer_vector self, tt, st, vector in
    var i = 0; var len = vector.length;
    while i < len do
        var ast = vector.get(i);
        ti_infer(self, tt, st, ast);
        i += 1;
    end
end

def ti_infer_ident self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Ident, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    var type = symbol_type(symbol);
    if type then
        return type;
    else
        symbol_set_type(symbol, tt_any_type(tt));
    end
    return tt_any_type(tt);
end

def ti_infer_integer self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Integer, ast);
    return tt_int_type(tt);
end

def ti_infer_string self, tt, st, ast -> Type& in
    check_ast_kind(AstK::String, ast);
    return tt_cstr_type(tt);
end

def ti_infer_call self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Call, ast);
    var expr = ast_expr(ast);
    var before_kind = ast_kind(expr);
    var object = NULL;
    if before_kind == AstK::MemberAccess then
        object = ast_expr(expr);
    end
    var call_type = ti_infer(self, tt, st, expr);
    var after_kind = ast_kind(expr);
    var any = tt_any_type(tt);
    // TODO: put this check in type checker
    if not type_is_def(call_type) then
        ti_infer_vector(self, tt, st, ast_args(ast));
        return tt_any_type(tt);
    end

    var call_symbol = NULL;
    if ast_kind(expr) == AstK::Ident then
        call_symbol = st_get_symbol(st, ast_ident(expr));
        call_type = symbol_type(call_symbol);
    elif ast_kind(expr) == AstK::ScopeResolve then
        call_type = scope_resolve_type(tt, expr, false);
        if not type_is_def(call_type) then
            ti_infer_vector(self, tt, st, ast_args(ast));
            return tt_any_type(tt);
        end
        var def_ = type_ast(call_type);
        assert(def_, "Compiler bug: call_type has no def ast\n");
        call_symbol = st_get_symbol(st, ast_ident(def_));
        assert(call_symbol, "Compiler bug: def has no symbol\n");
    end

    if not type_is_def(call_type) then
        ti_infer_vector(self, tt, st, ast_args(ast));
        return tt_any_type(tt);
    end

    var def_ast = type_ast(call_type);
    var def_params = NULL;
    if def_ast then
        def_params = ast_params(def_ast);
    end

    // TODO: need to handle varargs at some point
    var param_types = type_def_parameters(call_type);
    var args = ast_args(ast);

    if after_kind == AstK::ScopeResolve and before_kind == AstK::MemberAccess then
        if param_types.length != 0 then
            var obj_type = tt_get_ast_type(tt, object);
            var param_type = param_types.front();
            if not param_type then
                tt_print_type_name(tt, call_type);
                printf("<<<\n");
            end
            assert(obj_type);
            assert(param_type);
            if types_eq(obj_type, param_type) then
                args.insert_front(object);
            elif type_is_reference(param_type) and types_eq(tt_reference_to_type(tt, obj_type), param_type) then
                var obj_ref = make_ast_get_reference(ast_token(object), object);
                args.insert_front(obj_ref);
            end
        end
    end

    var i = 0; var len = min(param_types.length, args.length);
    var changed = false;
    while i < len do
        var arg_type = ti_infer(self, tt, st, args.get(i));
        assert(arg_type);
        var par_type = param_types.get(i);
        if not par_type then
            par_type = any;
        end
        if arg_type != any and par_type == any then
            param_types.set(i, arg_type);
            if def_params then
                var par_sym = st_get_symbol(st, def_params.get(i));
                symbol_set_type(par_sym, arg_type);
            end
            changed = true;
        end
        i += 1;
    end
    len = args.length;
    while i < len do
        ti_infer(self, tt, st, args.get(i));
        i += 1;
    end
    if changed then
        var def_ast = type_ast(call_type);
        if def_ast and not set_contains(self.again, call_symbol) then
            set_add(self.again, call_symbol);
            // FIXME: is there a better way to do this without recursion?
            ti_infer_def(self, tt, st, def_ast);
        end
    end
    return type_def_return_type(call_type);
end

def ti_infer_binop self, tt, st, ast -> Type& in
    check_ast_kind(AstK::BinOp, ast);
    var lhs = ti_infer(self, tt, st, ast_lhs(ast));
    var rhs = ti_infer(self, tt, st, ast_rhs(ast));
    var op = ast_op(ast);
    if op == TK::Less or op == TK::LessEq or op == TK::Greater or op == TK::GreaterEq or
        op == TK::EqEq or op == TK::NotEq or op == TK::KW_and or op == TK::KW_or then
        return tt_bool_type(tt);
    end

    var any = tt_any_type(tt);
    var int = tt_int_type(tt);
    var cstr = tt_cstr_type(tt);
    var ptr = tt_ptr_type(tt);
    var char = tt_char_type(tt);

    if lhs == rhs then
        // pointer - pointer => int.
        if lhs == ptr and op == TK::Minus then
            return int;
        end
        return lhs;
    end

    if lhs == any and rhs == any then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    end

    if lhs == any and rhs == int then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        return int;
    end

    if lhs == cstr and rhs == int then
        return cstr;
    end

    if lhs == int and rhs == cstr then
        return cstr;
    end

    if lhs == int and rhs == any then
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    end

    if lhs == ptr and rhs == int then
        return ptr;
    end

    if lhs == int and rhs == ptr then
        return ptr;
    end

    if type_is_int_like(lhs) and type_is_int_like(rhs) then
        if type_size(lhs) > type_size(rhs) then
            return lhs;
        else
            return rhs;
        end
    end

    return tt_any_type(tt);
end

def ti_infer_return self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Return, ast);
    var type;
    if ast_expr(ast) then
        type = ti_infer(self, tt, st, ast_expr(ast));
    else
        type = tt_void_type(tt);
    end
    var cur_def = ti_current_def(self);
    var def_type = symbol_type(cur_def);
    assert(type_is_def(def_type), "def_type not def type");
    var ret_type = type_def_return_type(def_type);
    var any = tt_any_type(tt);
    if not ret_type or ret_type == any then
        type_set_def_return_type(def_type, type);
    elif type_is_reference(ret_type) and type == any then
        // nothing
    elif not types_assignable(tt, type, ret_type) then
        // error message is handled in type checker
        return tt_void_type(tt);
    end
    ti_set_did_return(self, true);
    return tt_void_type(tt);
end

def ti_infer_var_decl self, tt, st, ast -> Type& in
    check_ast_kind(AstK::VarDecl, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    if not symbol_type(symbol) then
        symbol_set_type(symbol, tt_any_type(tt));
    end
    return tt_void_type(tt);
end

def _ti_infer_assignment tt, symbol, rhs_type, rhs_expr -> Type& in
    var sym_type = symbol_type(symbol);
    var any = tt_any_type(tt);
    if not sym_type or sym_type == any then
        symbol_set_type(symbol, rhs_type);
    elif type_is_reference(sym_type) and rhs_type == any then
        // nothing
    elif sym_type == tt_ptr_type(tt) and rhs_type != any then
        // this handles the case of `var x = NULL; x = Vector::new(0);`
        symbol_set_type(symbol, rhs_type);
    end
end

def ti_infer_var_assign self, tt, st, ast -> Type& in
    check_ast_kind(AstK::VarAssign, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

def ti_infer_assign_op self, tt, st, ast -> Type& in
    check_ast_kind(AstK::AssignOp, ast);
    var op = ast_op(ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));

    if op != TK::Assign and not type_is_int_like(type) then
        printf("WARN: `");
        tt_print_type_name(tt, type);
        printf("` is not a primitive type and cannot be used with TODO: get operator string\n");
        printf(".`\nNOTE: The expression is: ");
        print_ast(ast);
        print_token_loc(ast_token(ast));
        return tt_void_type(tt);
    end

    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    var sym_type = symbol_type(symbol);

    if op == TK::Assign then
        _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    end
    return tt_void_type(tt);
end

def ti_infer_def self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Def, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    ti_push_def(self, symbol);
    ti_infer_vector(self, tt, st, ast_body(ast));
    var def_type = symbol_type(symbol);
    assert(type_is_def(def_type),
           "Compiler bug: def type is not actually def type.\n");
    // don't handle the case where function is declared with a type but doesn't return here
    // because we'll let the IR compiler determine that.
    // it'just needless complexity to deal with checking every branch for returns here.
    if not ti_did_return(self) and type_def_return_type(def_type) == tt_any_type(tt) then
        type_set_def_return_type(def_type, tt_void_type(tt));
    end
    ti_pop_def(self);
    return tt_void_type(tt);
end

def ti_infer_if_else self, tt, st, ast -> Type& in
    check_ast_kind(AstK::IfElse, ast);
    ti_infer(self, tt, st, ast_test(ast));
    ti_infer_vector(self, tt, st, ast_consequence(ast));
    ti_infer_vector(self, tt, st, ast_alternative(ast));
    return tt_void_type(tt);
end

def ti_infer_while self, tt, st, ast -> Type& in
    check_ast_kind(AstK::While, ast);
    ti_infer(self, tt, st, ast_test(ast));
    ti_infer_vector(self, tt, st, ast_body(ast));
    return tt_void_type(tt);
end

def ti_infer_pointer_read self, tt, st, ast -> Type& in
    check_ast_kind(AstK::PointerRead, ast);
    var args = ast_pop_args(ast);
    ti_infer(self, tt, st, args.get(0));
    var size = ast_size(ast);
    var type = NULL;
    if size == 64 then
        type = tt_get_type_or_null(tt, "int64");
    elif size == 32 then
        type = tt_get_type_or_null(tt, "int32");
    elif size == 16 then
        type = tt_get_type_or_null(tt, "int16");
    elif size == 8 then
        type = tt_get_type_or_null(tt, "int8");
    elif size == 0 then
        var type_ast = args.back();
        assert(ast_kind(type_ast) == AstK::Type);
        type = ast_type(type_ast);
    else
        assert(false, "Compiler bug: pointer read where size outside valid range; size was %d\n", size);
    end
    assert(type, "Compiler bug: didn't find correct type for u%d@\n", size);
    return type;
end

def ti_infer_pointer_write self, tt, st, ast -> Type& in
    check_ast_kind(AstK::PointerWrite, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = args.length;
    while i < len do
        ti_infer(self, tt, st, args.get(i));
        i += 1;
    end
    return tt_void_type(tt);
end

def ti_infer_prefix_op self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Prefix, ast);
    var t = ti_infer(self, tt, st, ast_expr(ast));
    if ast_op == TK::KW_not then
        return tt_bool_type(tt);
    end
    return t;
end

def ti_infer_const self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Const, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

def ti_infer_extern self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Extern, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

def ti_infer_inline_asm self, tt, st, ast -> Type& in
    check_ast_kind(AstK::InlineAsm, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

def ti_infer_global self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Global, ast);
    var type = ti_infer(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    _ti_infer_assignment(tt, symbol, type, ast_assign_expr(ast));
    return tt_void_type(tt);
end

def ti_infer_cast self, tt, st, ast -> Type& in
    check_ast_kind(AstK::Cast, ast);
    ti_infer(self, tt, st, ast_expr(ast));
    return ast_type(ast);
end

def _ti_get_field_type_rewrite_if_def type, member, ast in
    assert(type_is_struct(type));
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        if cstr_eq(field.name, member) then
            return field.type;
        end
        i += 1;
    end
    var defs = type_struct_defs(type);
    i = 0; len = defs.length;
    while i < len do
        var def_ = defs.get(i);
        if cstr_eq(symbol_name(def_), member) then
            ast_change_member_access_to_scope_access(ast, type, def_);
            return symbol_type(def_);
        end
        i += 1;
    end
    return NULL;
end

def _ti_get_union_field_type type, member in
    var fields = type_union_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = fields.get(i);
        if cstr_eq(field.name, member) then
            return field.type;
        end
        i += 1;
    end
    return NULL;
end

def ti_infer_member_access self, tt, st, ast in
    check_ast_kind(AstK::MemberAccess, ast);
    var type = ti_infer(self, tt, st, ast_expr(ast));
    var member = ast_member(ast);
    var ftype = NULL;
    if type_is_struct(type) then
        ftype = _ti_get_field_type_rewrite_if_def(type, member, ast);
    elif type_is_reference(type) then
        var ref_type = type_deref_type(type);
        assert(ref_type, "reference type has no deref type");
        if not type_is_struct(ref_type) then
            printf("FIXME: this error message sucks! File \"%s\", line %d\n", __FILE__, __LINE__);
            printf("ERROR: type `");
            tt_print_type_name(tt, ref_type);
            printf("` is not a struct; it's a (%d). did you forget a cast?\n", type_kind(ref_type));
            printf("NOTE: the expression was: ");
            print_ast(ast);
            print_ast_src_loc(ast);
            exit(1);
        end
        ftype = _ti_get_field_type_rewrite_if_def(ref_type, member, ast);
    elif type_is_enum(type) then
        return type;
    elif type_is_union(type) then
        return _ti_get_union_field_type(type, member);
    else
        ftype = tt_any_type(tt); // let it get resolved again later
    end
    if not ftype then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` has no member `%s.` (ti_infer_member_access)\n", ast_member(ast));
        print_ast_src_loc(ast);
        exit(1);
    end
    return ftype;
end

def ti_infer_assign_member self, tt, st, ast in
    // nothing really to infer, members are required type declarations.
    check_ast_kind(AstK::AssignMember, ast);
    ti_infer(self, tt, st, ast_lhs(ast));
    ti_infer(self, tt, st, ast_rhs(ast));
    return tt_void_type(tt);
end

def ti_infer_sizeof_expr self, tt, st, ast in
    check_ast_kind(AstK::SizeofExpr, ast);
    var expr = ast_expr(ast);
    var type = ti_infer(self, tt, st, ast_expr(ast));
    if ast_kind(expr) == AstK::Ident then
        var sym = st_get_symbol(st, ast_ident(expr));
        type = symbol_type(sym);
        if type == tt_any_type(tt) then
            // This is the case of __sizeof(SomeType) and not __sizeof(some_var);
            type = tt_get_type_or_null(tt, ast_ident(ast_expr(ast)));
        end
    end
    ast_change_sizeof_expr_to_type(ast, type);
    return tt_int_type(tt);
end

def ti_infer_scope_resolve self, tt, st, ast in
    check_ast_kind(AstK::ScopeResolve, ast);
    return scope_resolve_type(tt, ast, false);
end

def ti_infer_get_reference self, tt, st, ast in
    check_ast_kind(AstK::GetReference, ast);
    var type = ti_infer(self, tt, st, ast_expr(ast));
    return tt_reference_to_type(tt, type);
end

def ti_infer_static_assert self, tt, st, ast in
    check_ast_kind(AstK::StaticAssert, ast);
    ti_infer_vector(self, tt, st, ast_args(ast));
    return tt_void_type(tt);
end

def ti_infer self, tt, st, ast -> Type& in
    var k = ast_kind(ast);
    var type: Type&;
    if k == AstK::Ident then type = ti_infer_ident(self, tt, st, ast);
    elif k == AstK::Integer then type = ti_infer_integer(self, tt, st, ast);
    elif k == AstK::String then type = ti_infer_string(self, tt, st, ast);
    elif k == AstK::Call then type = ti_infer_call(self, tt, st, ast);
    elif k == AstK::BinOp then type = ti_infer_binop(self, tt, st, ast);
    elif k == AstK::Return then type = ti_infer_return(self, tt, st, ast);
    elif k == AstK::VarDecl then type = ti_infer_var_decl(self, tt, st, ast);
    elif k == AstK::VarAssign then type = ti_infer_var_assign(self, tt, st, ast);
    elif k == AstK::Def then type = ti_infer_def(self, tt, st, ast);
    elif k == AstK::IfElse then type = ti_infer_if_else(self, tt, st, ast);
    elif k == AstK::While then type = ti_infer_while(self, tt, st, ast);
    elif k == AstK::PointerRead then type = ti_infer_pointer_read(self, tt, st, ast);
    elif k == AstK::PointerWrite then type = ti_infer_pointer_write(self, tt, st, ast);
    elif k == AstK::Prefix then type = ti_infer_prefix_op(self, tt, st, ast);
    elif k == AstK::Const then type = ti_infer_const(self, tt, st, ast);
    elif k == AstK::Extern then type = ti_infer_extern(self, tt, st, ast);
    elif k == AstK::InlineAsm then type = ti_infer_inline_asm(self, tt, st, ast);
    elif k == AstK::Global then type = ti_infer_global(self, tt, st, ast);
    elif k == AstK::Break then type = tt_void_type(tt);
    elif k == AstK::Continue then type = tt_void_type(tt);
    elif k == AstK::AssignOp then type = ti_infer_assign_op(self, tt, st, ast);
    elif k == AstK::Cast then type = ti_infer_cast(self, tt, st, ast);
    elif k == AstK::Struct then type = tt_void_type(tt);
    elif k == AstK::MemberAccess then type = ti_infer_member_access(self, tt, st, ast);
    elif k == AstK::AssignMember then type = ti_infer_assign_member(self, tt, st, ast);
        // This seems like a bug but sizeof isn't supposed to evaluate its arguments.
    elif k == AstK::SizeofExpr then type = ti_infer_sizeof_expr(self, tt, st, ast);
    elif k == AstK::SizeofType then type = tt_int_type(tt);
    elif k == AstK::Enum then type = tt_void_type(tt);
    elif k == AstK::Type then type = tt_void_type(tt);
    elif k == AstK::ScopeResolve then type = ti_infer_scope_resolve(self, tt, st, ast);
    elif k == AstK::GetReference then type = ti_infer_get_reference(self, tt, st, ast);
    elif k == AstK::Union then type = tt_void_type(tt);
    elif k == AstK::StaticAssert then type = ti_infer_static_assert(self, tt, st, ast);
    else
        printf("`ti_infer` in File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        print_ast(ast);
        print_ast_src_loc(ast);
        exit(1);
    end
    tt_set_ast_type(tt, ast, type);
    return type;
end

def _type_infer_impl self, type_table, symbol_table, ast_nodes in
    var i = 0; var len = ast_nodes.length;
    while i < len do
        ti_infer(self, type_table, symbol_table, ast_nodes.get(i));
        i += 1;
    end

    // TODO: prove this terminates or design an alternate solution.
    while true do
        var again = self.again;
        if set_len(again) == 0 then
            break;
        end
        self.again = make_set(0, NULL, NULL);
        var cur = set_begin(again);
        while cur != set_end(again) do
            var sym = cast(u64@(cur), Symbol&);
            var type = symbol_type(sym);
            var ast = type_ast(type);
            assert(ast, "ast from type_infer_again should not be null");
            ti_infer(self, type_table, symbol_table, ast);
            cur = set_next(again, cur);
        end
        free_set(again);
    end
end

def type_infer type_table, symbol_table, ast_nodes, repeat in
    var self = make_type_infer();

    _type_infer_impl(self, type_table, symbol_table, ast_nodes);

    // there has got to be a better way to do type inference than this...
    while repeat and type_table.made_change do
        type_table.made_change = false;
        _type_infer_impl(self, type_table, symbol_table, ast_nodes);
    end

    free_type_infer(self);
end
