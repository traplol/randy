
proc is_digit c: char -> bool in
    return '0' <= c and c <= '9';
end

proc is_whitespace c: char -> bool in
    return c == ' ' or c == '\t' or c == '\n' or c == 0;
end

proc is_ident_start c: char -> bool in
    return c == '_' or ('a' <= c and c <= 'z') or ('A' <= c and c <= 'Z');
end

proc is_ident_char c: char -> bool in
    return is_ident_start(c) or is_digit(c) or c == '@' or c == '!';
end

proc get_escaped_char c: char -> char in
    if c == 't' then
        return 9; // \t tab
    elif c == 'n' then
        return 10; // \n newline
    elif c == 'r' then
        return 13; // \r carriage return
    elif c == '0' then
        return 0; // \0 null character
    end
    return c;
end

proc get_ident_kind string: String& in
    var cstr = string_cstr(string);
    var first = u8@(cstr);
    if 'a' == first then
        if cstr_eq("and", cstr) then return TK_KW_and; end
        if cstr_eq("asm", cstr) then return TK_KW_asm; end
        if cstr_eq("assert", cstr) then return TK_KW_assert; end
    elif 'b' == first then
        if cstr_eq("break", cstr) then return TK_KW_break; end
    elif 'c' == first then
        if cstr_eq("cast", cstr) then return TK_KW_cast; end
        if cstr_eq("const", cstr) then return TK_KW_const; end
        if cstr_eq("continue", cstr) then return TK_KW_continue; end
    elif 'd' == first then
        if cstr_eq("do", cstr) then return TK_KW_do; end
    elif 'e' == first then
        if cstr_eq("else", cstr) then return TK_KW_else; end
        if cstr_eq("elif", cstr) then return TK_KW_elif; end
        if cstr_eq("end", cstr) then return TK_KW_end; end
        if cstr_eq("enum", cstr) then return TK_KW_enum; end
        if cstr_eq("extern", cstr) then return TK_KW_extern; end
    elif 'g' == first then
        if cstr_eq("global", cstr) then return TK_KW_global; end
    elif 'i' == first then
        if cstr_eq("if", cstr) then return TK_KW_if; end
        if cstr_eq("in", cstr) then return TK_KW_in; end
        if cstr_eq("inline", cstr) then return TK_KW_inline; end
    elif 'n' == first then
        if cstr_eq("not", cstr) then return TK_KW_not; end
    elif 'o' == first then
        if cstr_eq("or", cstr) then return TK_KW_or; end
    elif 'p' == first then
        if cstr_eq("proc", cstr) then return TK_KW_proc; end
    elif 'r' == first then
        if cstr_eq("return", cstr) then return TK_KW_return; end
    elif 's' == first then
        if cstr_eq("struct", cstr) then return TK_KW_struct; end
    elif 't' == first then
        if cstr_eq("then", cstr) then return TK_KW_then; end
    elif 'u' == first then
        if cstr_eq("u8@", cstr) then return TK_KW_u8@; end
        if cstr_eq("u16@", cstr) then return TK_KW_u16@; end
        if cstr_eq("u32@", cstr) then return TK_KW_u32@; end
        if cstr_eq("u64@", cstr) then return TK_KW_u64@; end

        if cstr_eq("u8!", cstr) then return TK_KW_u8!; end
        if cstr_eq("u16!", cstr) then return TK_KW_u16!; end
        if cstr_eq("u32!", cstr) then return TK_KW_u32!; end
        if cstr_eq("u64!", cstr) then return TK_KW_u64!; end
        if cstr_eq("union", cstr) then return TK_KW_union; end
    elif 'v' == first then
        if cstr_eq("var", cstr) then return TK_KW_var; end
    elif 'w' == first then
        if cstr_eq("while", cstr) then return TK_KW_while; end
    elif '_' == first then
        if cstr_eq("__FILE__", cstr) then return TK_KW__FILE__; end
        if cstr_eq("__LINE__", cstr) then return TK_KW__LINE__; end
        if cstr_eq("__offsetof", cstr) then return TK_KW__offsetof; end
        if cstr_eq("__sizeof", cstr) then return TK_KW__sizeof; end
    end
    return TK_Ident;
end

proc _unrecognized_char filename, line_no, c in
    printf("Unrecognized character: '%c' (%d)\n", c, c);
    printf("  File \"%s\", line %d\n", filename, line_no);
    exit(1);
end

proc _lex_code filename, code, include_paths, included_already -> Vector& in
    var i = 0;
    var tokens = make_vector(0);
    var length = code.length;
    // pad the ending so we don't have to check that every memory access is valid.
    string_push(code, 0);
    string_push(code, 0);
    string_push(code, 0);
    string_set_len(code, length);
    var line_no = 1;
    var temp; var c; var val;
    while i < length do
        // Consume whitespace
        while i < length and is_whitespace(string_get(code, i)) do
            if string_get(code, i) == '\n' then
                line_no = line_no + 1;
            end
            i += 1;
        end

        if i < length then
            c = string_get(code, i);
            if c == '/' and string_get(code, i + 1) == '/' then
                while i < length and string_get(code, i) != '\n' do
                    i += 1;
                end
            elif is_ident_start(c) then
                temp = make_string(2);
                string_push(temp, c);
                while i < length and is_ident_char(c) do
                   i += 1;
                   c = string_get(code, i);
                   if is_ident_char(c) then
                       string_push(temp, c);
                   end
                end
                vector_push(tokens, make_token(get_ident_kind(temp), string_cstr(temp), string_cstr(temp), line_no, filename));
            elif is_digit(c) then
                temp = make_string(2);
                string_push(temp, c);
                while i < length and is_digit(c) do
                   i += 1;
                   c = string_get(code, i);
                   if is_digit(c) then
                       string_push(temp, c);
                   end
                end
                val = int_from_string(temp);
                vector_push(tokens, make_token(TK_Integer, string_cstr(temp), cast(val, ptr), line_no, filename));
            elif c == '"' then
                temp = make_string(2);
                i += 1; // skip open quote
                while i < length and string_get(code, i) != '"' do
                    c = string_get(code, i);
                    if c == '\\' then
                        i += 1; // skip \
                        c = string_get(code, i);
                        c = get_escaped_char(c);
                    elif c == '\n' then
                        line_no = line_no + 1;
                    end
                    string_push(temp, c);
                    i += 1;
                end
                i += 1; // skip close quote
                vector_push(tokens, make_token(TK_String, string_cstr(temp), temp, line_no, filename));
            elif c == '\'' then
                temp = make_string(2);
                i += 1; // skip open quote
                c = string_get(code, i);
                if c == '\\' then
                    i += 1; // skip \
                    c = string_get(code, i);
                    c = get_escaped_char(c);
                elif c == '\n' then
                    line_no = line_no + 1;
                end
                string_push(temp, c);
                i += 2; // skip char and close quote
                vector_push(tokens, make_token(TK_Char, string_cstr(temp), cast(c, ptr), line_no, filename));
            elif c == '#' then
                var directive = make_string(2);
                var arg = make_string(2);
                // gather #directive chars up to next space
                while i < length do
                    c = string_get(code, i);
                    if is_whitespace(c) then
                        break;
                    else
                        string_push(directive, c);
                        i += 1;
                    end
                end
                // consume all whitespace up to newline or non-whitespace
                while i < length do
                    c = string_get(code, i);
                    if c == '\n' then
                        break;
                    elif is_whitespace(c) then
                        i += 1;
                    else
                        break;
                    end
                end
                // gather the rest of the line into arg
                while i < length and c != '\n' do
                    c = string_get(code, i);
                    if c != '\n' then
                        string_push(arg, c);
                        i += 1;
                    end
                end
                // trim whitespace off end of arg
                while arg.length > 0 and is_whitespace(string_back(arg)) do
                    string_pop(arg);
                end
                handle_directive(filename, line_no, tokens, include_paths, included_already, directive, arg);
                free_string(directive);
                free_string(arg);
            elif c == ';' then
                vector_push(tokens, make_token(TK_Semicolon, ";", ";", line_no, filename));
                i += 1;
            elif c == ':' then
                vector_push(tokens, make_token(TK_Colon, ":", ":", line_no, filename));
                i += 1;
            elif c == ',' then
                vector_push(tokens, make_token(TK_Comma, ",", ",", line_no, filename));
                i += 1;
            elif c == '(' then
                vector_push(tokens, make_token(TK_LParen, "(", "(", line_no, filename));
                i += 1;
            elif c == ')' then
                vector_push(tokens, make_token(TK_RParen, ")", ")", line_no, filename));
                i += 1;
            elif c == '[' then
                vector_push(tokens, make_token(TK_LSquare, "[", "[", line_no, filename));
                i += 1;
            elif c == ']' then
                vector_push(tokens, make_token(TK_RSquare, "]", "]", line_no, filename));
                i += 1;
            elif c == '+' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_PlusEq, "+=", "+=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Plus, "+", "+", line_no, filename));
                    i += 1;
                end
            elif c == '-' then
                if string_get(code, i + 1) == '>' then
                    vector_push(tokens, make_token(TK_RightArrow, "->", "->", line_no, filename));
                    i += 2;
                elif string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_MinusEq, "-=", "-=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Minus, "-", "-", line_no, filename));
                    i += 1;
                end
            elif c == '*' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_StarEq, "*=", "*=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Star, "*", "*", line_no, filename));
                    i += 1;
                end
            elif c == '/' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_SlashEq, "/=", "/=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Slash, "/", "/", line_no, filename));
                    i += 1;
                end
            elif c == '%' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_PercentEq, "%=", "%=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Percent, "%", "%", line_no, filename));
                    i += 1;
                end
            elif c == '|' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_BarEq, "|=", "|=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Bar, "|", "|", line_no, filename));
                    i += 1;
                end
            elif c == '&' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_AmperEq, "&=", "&=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Amper, "&", "&", line_no, filename));
                    i += 1;
                end
            elif c == '^' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_CaretEq, "^=", "^=", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Caret, "^", "^", line_no, filename));
                    i += 1;
                end
            elif c == '~' then
                vector_push(tokens, make_token(TK_Tilde, "~", "~", line_no, filename));
                i += 1;
            elif c == '.' then
                if string_get(code, i + 1) == '.' and string_get(code, i + 2) == '.' then
                    vector_push(tokens, make_token(TK_Ellipsis, "...", "...", line_no, filename));
                    i += 3;
                else
                    vector_push(tokens, make_token(TK_Dot, ".", ".", line_no, filename));
                    i += 1;
                end
            elif c == '!' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_NotEq, "!=", "!=", line_no, filename));
                    i += 2;
                else
                    _unrecognized_char(filename, line_no, c);
                end
            elif c == '<' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_LessEq, "<=", "<=", line_no, filename));
                    i += 2;
                elif string_get(code, i + 1) == '<' then
                    if string_get(code, i + 2) == '=' then
                        vector_push(tokens, make_token(TK_LShiftEq, "<<=", "<<=", line_no, filename));
                        i += 3;
                    else
                        vector_push(tokens, make_token(TK_LShift, "<<", "<<", line_no, filename));
                        i += 2;
                    end
                else
                    vector_push(tokens, make_token(TK_Less, "<", "<", line_no, filename));
                    i += 1;
                end
            elif c == '>' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_GreaterEq, ">=", ">=", line_no, filename));
                    i += 2;
                elif string_get(code, i + 1) == '>' then
                    if string_get(code, i + 2) == '=' then
                        vector_push(tokens, make_token(TK_RShiftEq, ">>=", ">>=", line_no, filename));
                        i += 3;
                    else
                        vector_push(tokens, make_token(TK_RShift, ">>", ">>", line_no, filename));
                        i += 2;
                    end
                else
                    vector_push(tokens, make_token(TK_Greater, ">", ">", line_no, filename));
                    i += 1;
                end
            elif c == '=' then
                if string_get(code, i + 1) == '=' then
                    vector_push(tokens, make_token(TK_EqEq, "==", "==", line_no, filename));
                    i += 2;
                else
                    vector_push(tokens, make_token(TK_Assign, "=", "=", line_no, filename));
                    i += 1;
                end
            else
                _unrecognized_char(filename, line_no, c);
            end
        end
    end
    return tokens;
end

proc _lex_file_aux path: cstr, include_paths: Vector&, included_already: set -> Vector& in
    var code = read_file_to_string(path);
    if not code then
        return cast(NULL, Vector&);
    end
    return _lex_code(path, code, include_paths, included_already);
end

proc lex_file path: cstr, include_paths: Vector& in
    var included_already = make_set(0, string_eq, string_hash);
    var res = _lex_file_aux(path, include_paths, included_already);
    free_set(included_already);
    return res;
end

proc handle_include src_file: cstr, line_no: int, tokens: Vector&, include_paths: Vector&, included_already: set, arg: String& in
    string_append_cstr(arg, ".randy");

    var i = 0;
    var cur_dir = string_from_cstr(src_file);
    while cur_dir.length > 0 and string_back(cur_dir) != '/' do
        string_pop(cur_dir);
    end
    var found = cur_dir;
    string_append_string(found, arg);
    if not file_is_readable(string_cstr(found)) then
        found = NULL;
        free_string(cur_dir);
    end

    if not found then
        i = include_paths.length - 1;
        while i >= 0 do
            cur_dir = vector_get(include_paths, i);
            found = string_duplicate(cur_dir);
            string_push(found, '/');
            string_append_string(found, arg);
            if file_is_readable(string_cstr(found)) then
                i = 0;
            else
                free_string(found);
                found = NULL;
            end
            i -= 1;
        end
    end

    if found then
        if not set_contains(included_already, found) then
            set_add(included_already, found);
            var included = _lex_file_aux(string_cstr(found), include_paths, included_already);
            i = 0;
            var len = included.length;
            while i < len do
                vector_push(tokens, vector_get(included, i));
                i += 1;
            end
        else
            free_string(found);
        end
    else
        printf("ERROR: Included file is not readable or does not exist\n");
        printf("NOTE: The included file was '%s'\n", string_cstr(arg));
        printf("  File \"%s\", line %d\n", src_file, line_no);
        exit(1);
    end
end

proc handle_directive src_file, line_no, tokens, include_paths, included_already, directive, arg in
    if cstr_eq("#include", string_cstr(directive)) then
        handle_include(src_file, line_no, tokens, include_paths, included_already, arg);
    end
end
