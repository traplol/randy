
const TTOKEN_STREAM_tokens = 0;  // token Vector&
const TTOKEN_STREAM_idx = 8;     // int
const sizeof_TTOKEN_STREAM = 16;

def make_token_stream tokens: Vector& -> token_stream in
    var self = malloc(sizeof_TTOKEN_STREAM);
    u64!(self + TTOKEN_STREAM_tokens, tokens);
    u64!(self + TTOKEN_STREAM_idx, 0);
    return cast(self, token_stream);
end

def ts_tokens self: token_stream in return cast(u64@(self + TTOKEN_STREAM_tokens), Vector&); end
def ts_idx self: token_stream in return cast(u64@(self + TTOKEN_STREAM_idx), int); end
def ts_revert self: token_stream, idx: int in u64!(self + TTOKEN_STREAM_idx, idx); end

def ts_peek self: token_stream -> Token& in
    var tks = ts_tokens(self);
    var idx = ts_idx(self);
    if idx >= tks.length then
        return cast(NULL, Token&);
    end
    return cast(vector_get(tks, idx), Token&);
end

def ts_peekk self: token_stream, kind: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end

    return token_kind(peek) == kind;
end

def ts_peekk_one_of_2 self: token_stream, k1: TK, k2: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2;
end

def ts_peekk_one_of_3 self: token_stream, k1: TK, k2: TK, k3: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3;
end

def ts_peekk_one_of_4 self: token_stream, k1: TK, k2: TK, k3: TK, k4: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3 or tk == k4;
end

def ts_peekk_one_of_5 self: token_stream, k1: TK, k2: TK, k3: TK, k4: TK, k5: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end
    var tk = token_kind(peek);
    return tk == k1 or tk == k2 or tk == k3 or tk == k4 or tk == k5;
end

def ts_next self: token_stream -> Token& in
    var peek = ts_peek(self);
    u64!(self + TTOKEN_STREAM_idx, u64@(self + TTOKEN_STREAM_idx) + 1);
    return peek;
end

def ts_accept self: token_stream, kind: TK -> Token& in
    var tmp = ts_peek(self);
    if tmp and token_kind(tmp) == kind then
        return ts_next(self);
    end
    return cast(NULL, Token&);
end

def ts_expect self: token_stream, kind: TK -> Token& in
    var tmp = ts_peek(self);
    if not tmp then
        printf("ERROR: Expected token kind %s but ran out of tokens.\n", token_kind_cstr(kind));
        exit(1);
    end
    var tmp_k = token_kind(tmp);
    if tmp_k != kind then
        printf("ERROR: Expected token kind %s (%d), got %s\n",
            token_kind_cstr(kind),
            kind,
            token_kind_cstr(tmp_k));
        print_token_loc(tmp);
        exit(1);
    end
    ts_next(self);
    return tmp;
end

def ts_peekk2 self: token_stream, kind1: TK, kind2: TK -> bool in
    var peek = ts_peek(self);
    if not peek then
        return false;
    end

    var idx = ts_idx(self);
    var good = false;
    if ts_accept(self, kind1) then
        if ts_accept(self, kind2) then
            good = true;
        end
    end
    ts_revert(self, idx);
    return good;
end
