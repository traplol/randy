const REG_SIZE = 8;
const SYSV_REGISTERS = 6;

proc systemv_arg n in
    if n >= SYSV_REGISTERS then return NULL;
    elif n == 0 then return "%rdi";
    elif n == 1 then return "%rsi";
    elif n == 2 then return "%rdx";
    elif n == 3 then return "%rcx";
    elif n == 4 then return "%r8";
    elif n == 5 then return "%r9";
    end
end

proc x86_64_emit_get_local cc, ir in
    check_ir_kind(IRK_GetLocal, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var offs = (ir_instr_n(ir) + 1) * REG_SIZE;
    var str = make_string(20);
    string_append_cstr(str, "    movq -");
    string_append_int(str, offs);
    string_append_cstr(str, "(%rbp), %rax");
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_push_label cc, ir in
    check_ir_kind(IRK_PushLabel, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var str = make_string(20);
    string_append_cstr(str, "    leaq ");
    string_append_cstr(str, ir_instr_label(ir));
    string_append_cstr(str, ", %rax");
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_push_int cc, ir in
    check_ir_kind(IRK_PushInt, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var str = make_string(20);
    var val = ir_instr_value(ir);
    if (0-2147483649) < val and val < 4294967296 then
        string_append_cstr(str, "    movq $");
    else
        string_append_cstr(str, "    movabsq $");
    end
    string_append_int(str, val);
    string_append_cstr(str, ", %rax");
    cc_out(cc, string_cstr(str));
    cc_out(cc, "    pushq %rax");
    free_string(str);
end

proc x86_64_emit_alloc_temps cc, ir in
    check_ir_kind(IRK_AllocTemps, ir);
    //print_ir(ir);
    var n = ir_instr_n(ir);
    if n > 0 then
        cc_out_src_loc(cc, ir_instr_src_loc(ir));
        var offs = (n+1) * REG_SIZE;
        var str = make_string(20);
        string_append_cstr(str, "    subq $");
        string_append_int(str, offs);
        string_append_cstr(str, ", %rsp");
        cc_out(cc, string_cstr(str));
        free_string(str);
    end
end

proc x86_64_emit_free_temps cc, ir in
    check_ir_kind(IRK_FreeTemps, ir);
    //print_ir(ir);
    var n = ir_instr_n(ir);
    if n > 0 then
        cc_out_src_loc(cc, ir_instr_src_loc(ir));
        var offs = (n+1) * REG_SIZE;
        var str = make_string(20);
        string_append_cstr(str, "    addq $");
        string_append_int(str, offs);
        string_append_cstr(str, ", %rsp");
        cc_out(cc, string_cstr(str));
        free_string(str);
    end
end

proc x86_64_emit_store_temp cc, ir in
    check_ir_kind(IRK_StoreTemp, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var offs = (ir_instr_n(ir) + 1) * REG_SIZE;
    cc_out(cc, "    popq %rax");
    var str = make_string(20);
    string_append_cstr(str, "    movq %rax, ");
    string_append_int(str, offs);
    string_append_cstr(str, "(%rsp)");
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_set_arg_temp cc, ir in
    check_ir_kind(IRK_SetArgTemp, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var n = ir_instr_n(ir);
    var offs = (n + 1) * REG_SIZE;
    var str = make_string(20);
    if n < SYSV_REGISTERS then
        string_append_cstr(str, "    movq ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rsp), ");
        string_append_cstr(str, systemv_arg(n));
    else
        string_append_cstr(str, "    pushq ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rsp)");
    end
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_call cc, ir in
    check_ir_kind(IRK_Call, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    if ir_instr_varargs(ir) then
        cc_out(cc, "    xor %al, %al");
    end
    var str = make_string(20);
    string_append_cstr(str, "    call ");
    string_append_cstr(str, ir_instr_label(ir));
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_pop_call cc, ir in
    check_ir_kind(IRK_PopCall, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rcx");
    cc_out(cc, "    xor %al, %al");
    cc_out(cc, "    call *%rcx");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_add cc, ir in
    check_ir_kind(IRK_OpAdd, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    addq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_sub cc, ir in
    check_ir_kind(IRK_OpSub, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    subq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_mul cc, ir in
    check_ir_kind(IRK_OpMul, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    imulq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_div cc, ir in
    check_ir_kind(IRK_OpDiv, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rcx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    cqto");
    cc_out(cc, "    idivq %rcx");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_mod cc, ir in
    check_ir_kind(IRK_OpMod, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rcx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    cqto");
    cc_out(cc, "    idivq %rcx");
    cc_out(cc, "    pushq %rdx");
end

proc x86_64_emit_op_bit_xor cc, ir in
    check_ir_kind(IRK_OpBitXOR, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    xorq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_bit_and cc, ir in
    check_ir_kind(IRK_OpBitAND, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    andq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_bit_or cc, ir in
    check_ir_kind(IRK_OpBitOR, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rdx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    orq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_bit_shift_l cc, ir in
    check_ir_kind(IRK_OpBitShiftL, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rcx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    salq %cl, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_bit_shift_r cc, ir in
    check_ir_kind(IRK_OpBitShiftR, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rcx"); // -- b
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    sarq %cl, %rax");
    cc_out(cc, "    pushq %rax");
end

proc _x86_64_emit_compare cc, op in
    cc_out(cc, "    popq %r10"); // -- a
    cc_out(cc, "    popq %r11"); // -- a
    cc_out(cc, "    xorl %eax, %eax");
    cc_out(cc, "    cmpq %r10, %r11");
    var str = make_string(20);
    string_append_cstr(str, "    ");
    string_append_cstr(str, op);
    string_append_cstr(str, " %al");
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_op_eq cc, ir in
    check_ir_kind(IRK_OpEq, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "sete");
end

proc x86_64_emit_op_not_eq cc, ir in
    check_ir_kind(IRK_OpNotEq, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "setne");
end

proc x86_64_emit_op_less cc, ir in
    check_ir_kind(IRK_OpLess, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "setl");
end

proc x86_64_emit_op_less_eq cc, ir in
    check_ir_kind(IRK_OpLessEq, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "setle");
end

proc x86_64_emit_op_greater cc, ir in
    check_ir_kind(IRK_OpGreater, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "setg");
end

proc x86_64_emit_op_greater_eq cc, ir in
    check_ir_kind(IRK_OpGreaterEq, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    _x86_64_emit_compare(cc, "setge");
end

proc x86_64_emit_pop_return cc, ir in
    check_ir_kind(IRK_PopReturn, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax");
    cc_out(cc, "    leave");
    cc_out(cc, "    ret");
end

proc x86_64_emit_return_void cc, ir in
    check_ir_kind(IRK_ReturnVoid, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    xorq %rax, %rax");
    cc_out(cc, "    leave");
    cc_out(cc, "    ret");
end

proc x86_64_emit_set_local cc, ir in
    check_ir_kind(IRK_SetLocal, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax");
    var str = make_string(20);
    var offs = (ir_instr_n(ir) + 1) * REG_SIZE;
    string_append_cstr(str, "    movq %rax, -");
    string_append_int(str, offs);
    string_append_cstr(str, "(%rbp)");
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_new_proc cc, ir in
    check_ir_kind(IRK_NewProc, ir);
    //print_ir(ir);
    var label = ir_instr_label(ir);
    cc_out_global(cc, label);
    cc_out(cc, "    .align 16");
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out_label(cc, label);
    cc_out(cc, "    pushq %rbp");
    cc_out(cc, "    movq %rsp, %rbp");
    var n = ir_instr_nlocals(ir);
    if n > 0 then
        var str = make_string(20);
        string_append_cstr(str, "    subq $");
        string_append_int(str, n * REG_SIZE);
        string_append_cstr(str, ", %rsp");
        cc_out(cc, string_cstr(str));
        free_string(str);
    end
end

proc x86_64_emit_set_local_arg cc, ir in
    check_ir_kind(IRK_SetLocalArg, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var local_n = ir_instr_n(ir);
    var offs = REG_SIZE * (local_n+1);
    var arg_n = ir_instr_arg(ir);
    var str = make_string(20);
    if arg_n < SYSV_REGISTERS then
        string_append_cstr(str, "    movq ");
        string_append_cstr(str, systemv_arg(arg_n));
        string_append_cstr(str, ", -");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rbp)");
        cc_out(cc, string_cstr(str));
        free_string(str);
    else
        var n = (local_n - SYSV_REGISTERS + 2) * REG_SIZE;
        string_append_cstr(str, "    movq ");
        string_append_int(str, n);
        string_append_cstr(str, "(%rbp), %rax");
        cc_out(cc, string_cstr(str));
        string_reset(str);
        string_append_cstr(str, "    movq %rax, -");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rbp)");
        cc_out(cc, string_cstr(str));
        free_string(str);
    end
end

proc x86_64_emit_close_proc cc, ir in
    check_ir_kind(IRK_CloseProc, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    movq %rbp, %rsp");
    cc_out(cc, "    popq %rbp");
    cc_out(cc, "    ret");
end

proc x86_64_emit_goto_top_false cc, ir in
    check_ir_kind(IRK_GotoTopFalse, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    cmpq $0, (%rsp)");
    var str = make_string(20);
    string_append_cstr(str, "    je ");
    string_append_cstr(str, ir_instr_label(ir));
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    addq $8, %rsp");
end

proc x86_64_emit_goto_top_true cc, ir in
    check_ir_kind(IRK_GotoTopTrue, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    cmpq $0, (%rsp)");
    var str = make_string(20);
    string_append_cstr(str, "    jne ");
    string_append_cstr(str, ir_instr_label(ir));
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    addq $8, %rsp");
end

proc x86_64_emit_goto_false cc, ir in
    check_ir_kind(IRK_GotoFalse, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax");
    cc_out(cc, "    cmpq $0, %rax");
    var str = make_string(20);
    string_append_cstr(str, "    je ");
    string_append_cstr(str, ir_instr_label(ir));
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_goto cc, ir in
    check_ir_kind(IRK_Goto, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var str = make_string(20);
    string_append_cstr(str, "    jmp ");
    string_append_cstr(str, ir_instr_label(ir));
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_label cc, ir in
    check_ir_kind(IRK_Label, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out_label(cc, ir_instr_label(ir));
end

proc x86_64_emit_ptr_read cc, ir in
    check_ir_kind(IRK_PtrRead, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var size = ir_instr_size(ir);
    cc_out(cc, "    popq %rax");
    cc_out(cc, "    xorl %edx, %edx");
    var str = make_string(20);
    var reg; 
    string_append_cstr(str, "    mov");
    if size == 8 then
        string_push(str, 'b');
        reg = "%dl";
    elif size == 16 then
        string_push(str, 'w');
        reg = "%dx";
    elif size == 32 then
        string_push(str, 'l');
        reg = "%edx";
    elif size == 64 then
        string_push(str, 'q');
        reg = "%rdx";
    end
    string_append_cstr(str, " (%rax), ");
    string_append_cstr(str, reg);
    cc_out(cc, string_cstr(str));
    free_string(str);
    cc_out(cc, "    movq %rdx, %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_ptr_write cc, ir in
    check_ir_kind(IRK_PtrWrite, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    var size = ir_instr_size(ir);
    cc_out(cc, "    popq %rax"); // -- ptr
    cc_out(cc, "    popq %rdx"); // -- value
    var str = make_string(20);
    var reg; 
    string_append_cstr(str, "    mov");
    if size == 8 then
        string_push(str, 'b');
        reg = "%dl";
    elif size == 16 then
        string_push(str, 'w');
        reg = "%dx";
    elif size == 32 then
        string_push(str, 'l');
        reg = "%edx";
    elif size == 64 then
        string_push(str, 'q');
        reg = "%rdx";
    end
    string_push(str, ' ');
    string_append_cstr(str, reg);
    string_append_cstr(str, ", (%rax)");
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_ptr_copy cc, ir in
    check_ir_kind(IRK_PtrCopy, ir);
    //print_ir(ir);
    var bits = ir_instr_size(ir);
    if bits <= 0 then
        return;
    end
    var size = (bits + 7) / 8; // num of bytes to copy
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax"); // -- dest
    cc_out(cc, "    popq %rdx"); // -- src

    var sse = size / 16;
    size -= sse * 16;
    var movq = size / 8;
    size -= movq * 8;
    var movl = size / 4;
    size -= movl * 4;
    var movw = size / 2;
    size -= movw * 2;
    var movb = size;
    size -= movb * 1;
    assert(size == 0, "x86_64_emit_ptr_copy: didn't resolve size to 0, it was %d\n", size);

    var i = 0; var offs = 0;
    var str = make_string(20);
    while i < sse do
        // load src+offs into xmm0
        string_reset(str);
        string_append_cstr(str, "    movdqu ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rdx), %xmm0");
        cc_out(cc, string_cstr(str));

        // store xmm0 into dest+offs
        string_reset(str);
        string_append_cstr(str, "    movups %xmm0, ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rax)");
        cc_out(cc, string_cstr(str));

        i += 1;
        offs += 16;
    end

    while i < movq do
        // load src+offs into rcx
        string_reset(str);
        string_append_cstr(str, "    movq ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rdx), %rcx");
        cc_out(cc, string_cstr(str));

        // store rcx into dest+offs
        string_reset(str);
        string_append_cstr(str, "    movq %rcx, ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rax)");
        cc_out(cc, string_cstr(str));

        i += 1;
        offs += 8;
    end

    i = 0;
    while i < movl do
        // load src+offs into ecx
        string_reset(str);
        string_append_cstr(str, "    movl ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rdx), %ecx");
        cc_out(cc, string_cstr(str));

        // store ecx into dest+offs
        string_reset(str);
        string_append_cstr(str, "    movl %ecx, ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rax)");
        cc_out(cc, string_cstr(str));

        i += 1;
        offs += 4;
    end

    i = 0;
    while i < movw do
        // load src+offs into cx
        string_reset(str);
        string_append_cstr(str, "    movw ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rdx), %cx");
        cc_out(cc, string_cstr(str));

        // store cx into dest+offs
        string_reset(str);
        string_append_cstr(str, "    movw %cx, ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rax)");
        cc_out(cc, string_cstr(str));

        i += 1;
        offs += 2;
    end

    i = 0;
    while i < movb do
        // load src+offs into ecx
        string_reset(str);
        string_append_cstr(str, "    movzbl ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rdx), %ecx");
        cc_out(cc, string_cstr(str));

        // store cl into dest+offs
        string_reset(str);
        string_append_cstr(str, "    movb %cl, ");
        string_append_int(str, offs);
        string_append_cstr(str, "(%rax)");
        cc_out(cc, string_cstr(str));

        i += 1;
        offs += 1;
    end
    free_string(str);
end

proc x86_64_emit_bit_not cc, ir in
    check_ir_kind(IRK_BitNot, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    not %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_logic_not cc, ir in
    check_ir_kind(IRK_LogicNot, ir);
    //print_ir(ir);
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, "    popq %rax"); // -- a
    cc_out(cc, "    cmpq $0, %rax");
    cc_out(cc, "    sete %al");
    cc_out(cc, "    movzbl %al, %eax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_inline_asm cc, ir in
    check_ir_kind(IRK_InlineAsm, ir);
    cc_out(cc, "    .align 16");
    cc_out_label(cc, ir_instr_name(ir));
    cc_out_src_loc(cc, ir_instr_src_loc(ir));
    cc_out(cc, ir_instr_asm(ir));
end

proc x86_64_emit_lazy_ident cc, ir in
    check_ir_kind(IRK_LazyIdent, ir);
    NYI_ERR(__FILE__, __LINE__, "IRK_LazyIdent should have been handled in ir_context.randy");
end

proc x86_64_emit_call_lazy_ident cc, ir in
    check_ir_kind(IRK_CallLazyIdent, ir);
    NYI_ERR(__FILE__, __LINE__, "IRK_CallLazyIdent should have been handled in ir_context.randy");
end

proc x86_64_emit_drop_top cc, ir in
    check_ir_kind(IRK_DropTop, ir);
    //print_ir(ir);
    cc_out(cc, "    addq $8, %rsp");
end

proc x86_64_emit_set_global cc, ir in
    check_ir_kind(IRK_SetGlobal, ir);
    //print_ir(ir);
    cc_out(cc, "    popq %rax");
    var str = make_string(20);
    string_append_cstr(str, "    movq %rax, (");
    string_append_cstr(str, ir_instr_label(ir));
    string_append_cstr(str, ")");
    cc_out(cc, string_cstr(str));
    free_string(str);
end

proc x86_64_emit_get_global cc, ir in
    check_ir_kind(IRK_GetGlobal, ir);
    //print_ir(ir);
    var str = make_string(20);
    string_append_cstr(str, "    movq (");
    string_append_cstr(str, ir_instr_label(ir));
    string_append_cstr(str, "), %rax");
    cc_out(cc, string_cstr(str));
    cc_out(cc, "    pushq %rax");
    free_string(str);
end

proc x86_64_emit_negative cc, ir in
    check_ir_kind(IRK_Negative, ir);
    //print_ir(ir);
    cc_out(cc, "    popq %rax");
    cc_out(cc, "    neg %rax");
    cc_out(cc, "    pushq %rax");
end

proc x86_64_emit_instruction cc, ir in
    var k = ir_instr_kind(ir);
    if k == IRK_GetLocal then x86_64_emit_get_local(cc, ir);
    elif k == IRK_PushLabel then x86_64_emit_push_label(cc, ir);
    elif k == IRK_PushInt then x86_64_emit_push_int(cc, ir);
    elif k == IRK_AllocTemps then x86_64_emit_alloc_temps(cc, ir);
    elif k == IRK_FreeTemps then x86_64_emit_free_temps(cc, ir);
    elif k == IRK_StoreTemp then x86_64_emit_store_temp(cc, ir);
    elif k == IRK_SetArgTemp then x86_64_emit_set_arg_temp(cc, ir);
    elif k == IRK_Call then x86_64_emit_call(cc, ir);
    elif k == IRK_PopCall then x86_64_emit_pop_call(cc, ir);
    elif k == IRK_OpAdd then x86_64_emit_op_add(cc, ir);
    elif k == IRK_OpSub then x86_64_emit_op_sub(cc, ir);
    elif k == IRK_OpMul then x86_64_emit_op_mul(cc, ir);
    elif k == IRK_OpDiv then x86_64_emit_op_div(cc, ir);
    elif k == IRK_OpMod then x86_64_emit_op_mod(cc, ir);
    elif k == IRK_OpEq then x86_64_emit_op_eq(cc, ir);
    elif k == IRK_OpNotEq then x86_64_emit_op_not_eq(cc, ir);
    elif k == IRK_OpLess then x86_64_emit_op_less(cc, ir);
    elif k == IRK_OpLessEq then x86_64_emit_op_less_eq(cc, ir);
    elif k == IRK_OpGreater then x86_64_emit_op_greater(cc, ir);
    elif k == IRK_OpGreaterEq then x86_64_emit_op_greater_eq(cc, ir);
    elif k == IRK_PopReturn then x86_64_emit_pop_return(cc, ir);
    elif k == IRK_ReturnVoid then x86_64_emit_return_void(cc, ir);
    elif k == IRK_SetLocal then x86_64_emit_set_local(cc, ir);
    elif k == IRK_NewProc then x86_64_emit_new_proc(cc, ir);
    elif k == IRK_SetLocalArg then x86_64_emit_set_local_arg(cc, ir);
    elif k == IRK_CloseProc then x86_64_emit_close_proc(cc, ir);
    elif k == IRK_GotoTopFalse then x86_64_emit_goto_top_false(cc, ir);
    elif k == IRK_GotoTopTrue then x86_64_emit_goto_top_true(cc, ir);
    elif k == IRK_GotoFalse then x86_64_emit_goto_false(cc, ir);
    elif k == IRK_Goto then x86_64_emit_goto(cc, ir);
    elif k == IRK_Label then x86_64_emit_label(cc, ir);
    elif k == IRK_PtrRead then x86_64_emit_ptr_read(cc, ir);
    elif k == IRK_PtrWrite then x86_64_emit_ptr_write(cc, ir);
    elif k == IRK_BitNot then x86_64_emit_bit_not(cc, ir);
    elif k == IRK_LogicNot then x86_64_emit_logic_not(cc, ir);
    elif k == IRK_InlineAsm then x86_64_emit_inline_asm(cc, ir);
    elif k == IRK_LazyIdent then x86_64_emit_lazy_ident(cc, ir);
    elif k == IRK_CallLazyIdent then x86_64_emit_call_lazy_ident(cc, ir);
    elif k == IRK_DropTop then x86_64_emit_drop_top(cc, ir);
    elif k == IRK_SetGlobal then x86_64_emit_set_global(cc, ir);
    elif k == IRK_GetGlobal then x86_64_emit_get_global(cc, ir);
    elif k == IRK_Negative then x86_64_emit_negative(cc, ir);
    elif k == IRK_OpBitXOR then x86_64_emit_op_bit_xor(cc, ir);
    elif k == IRK_OpBitAND then x86_64_emit_op_bit_and(cc, ir);
    elif k == IRK_OpBitOR then x86_64_emit_op_bit_or(cc, ir);
    elif k == IRK_OpBitShiftL then x86_64_emit_op_bit_shift_l(cc, ir);
    elif k == IRK_OpBitShiftR then x86_64_emit_op_bit_shift_r(cc, ir);
    elif k == IRK_ScopeOpen then // nothing to do
    elif k == IRK_ScopeClose then // nothing to do
    elif k == IRK_PtrCopy then x86_64_emit_ptr_copy(cc, ir);
    else
        printf("`x86_64_emit_instruction` in x86_64_backend.randy\n");
        printf("Unhandled IRK: %d\n", k);
        print_ir(ir);
        exit(1);
    end
end

proc x86_64_emit_start cctx, main_proc, exit_proc in
    cc_out(cctx, "    .global _start");
    cc_out(cctx, "    .align 16");
    cc_out(cctx, "_start:");
    cc_out(cctx, "    movq (%rsp), %rdi");
    cc_out(cctx, "    movq %rsp, %rsi");
    cc_out(cctx, "    addq $8, %rsi");
    cc_out(cctx, "    movq %rdi, (__argc__)");
    cc_out(cctx, "    movq %rsi, (__argv__)");
    var str = make_string(0);
    string_append_cstr(str, "    call ");
    string_append_cstr(str, main_proc);
    cc_out(cctx, string_cstr(str));
    cc_out(cctx, "    movq %rax, %rdi");
    if exit_proc then
        string_reset(str);
        string_append_cstr(str, "    call ");
        string_append_cstr(str, exit_proc);
        cc_out(cctx, string_cstr(str));
    end
    cc_out(cctx, "    movq $60, %rax");
    cc_out(cctx, "    syscall");
    cc_out(cctx, "    int3");
end
