
const TTYPE_name     = 0;  // cstr
const TTYPE_size     = 8;  // int
const TTYPE_ref_type = 16; // bool
const sizeof_TTYPE   = 32;

proc make_type name, size, ref_type in
    var self = malloc(sizeof_TTYPE);
    u64!(self + TTYPE_name, name);
    u64!(self + TTYPE_size, size);
    u64!(self + TTYPE_ref_type, ref_type);
    return self;
end

proc type_name self in return u64@(self + TTYPE_name); end
proc type_size self in return u64@(self + TTYPE_size); end
proc type_ref_type self in return u64@(self + TTYPE_ref_type); end

proc print_type self in
    var name = type_name(self);
    var size = type_size(self);
    var ref_type = type_ref_type(self);
    printf("type=%s, size=%d, ref_type=%d\n", name, size, ref_type);
end

const TPROC_TYPE_INFO_return_type = 0; // type
const TPROC_TYPE_INFO_param_types = 8; // type vector
const sizeof_TPROC_TYPE_INFO = 16;

proc make_proc_type_info return_type, param_types in
    var self = malloc(sizeof_TPROC_TYPE_INFO);
    u64!(self + TPROC_TYPE_INFO_return_type, return_type);
    u64!(self + TPROC_TYPE_INFO_param_types, param_types);
    return self;
end

proc proc_type_info_return_type self in return u64@(self + TPROC_TYPE_INFO_return_type); end
proc proc_type_info_param_types self in return u64@(self + TPROC_TYPE_INFO_param_types); end

proc proc_type_info_set_return_type self, type in
    u64!(self + TPROC_TYPE_INFO_return_type, type);
end

proc proc_type_info_set_param_type self, idx, type in
    var ptypes = proc_type_info_param_types(self);
    vector_set(ptypes, idx, type);
end

proc print_proc_type_info self in
    var ptypes = proc_type_info_param_types(self);
    printf("(");
    var i = 0; var len = vector_len(ptypes);
    while i < len do
        printf("%s", type_name(vector_get(ptypes, i)));
        i += 1;
        if i < len then
            printf(", ");
        end
    end
    var ret_type = proc_type_info_return_type(self);
    printf(") -> %s\n", type_name(ret_type));
end

const TTYPE_CHECK_types         = 0;  // (cstr, type) map : type_name -> type
const TTYPE_CHECK_ast_types     = 8;  // (ast, type) map : ast -> type
const TTYPE_CHECK_src_locs      = 16; // src_loc vector
const TTYPE_CHECK_any_type      = 24; // fast ref to `any` type
const TTYPE_CHECK_void_type     = 32; // fast ref to `void` type
const TTYPE_CHECK_int_type      = 40; // fast ref to `int` type
const TTYPE_CHECK_ptr_type      = 48; // fast ref to `ptr` type
const TTYPE_CHECK_cstr_type     = 56; // fast ref to `cstr` type
const TTYPE_CHECK_procs         = 64; // (cstr, proc_type_info)
const TTYPE_CHECK_scoped_idents = 72; // (cstr, type) map vector : ident -> type
const TTYPE_CHECK_resolve_later = 80; // ast set
const TTYPE_CHECK_cur_proc      = 88; // the current proc_type_info
const TTYPE_CHECK_did_return    = 96; // whether or not a return was encountered
const sizeof_TTYPE_CHECK        = 104;

proc make_type_check in
    var self = malloc(sizeof_TTYPE_CHECK);
    u64!(self + TTYPE_CHECK_types, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TTYPE_CHECK_ast_types, make_map(0, NULL, NULL));
    u64!(self + TTYPE_CHECK_src_locs, make_vector(0));
    u64!(self + TTYPE_CHECK_any_type, NULL);
    u64!(self + TTYPE_CHECK_void_type, NULL);
    u64!(self + TTYPE_CHECK_int_type, NULL);
    u64!(self + TTYPE_CHECK_ptr_type, NULL);
    u64!(self + TTYPE_CHECK_cstr_type, NULL);
    u64!(self + TTYPE_CHECK_procs, make_map(0, cstr_eq, cstr_hash));
    u64!(self + TTYPE_CHECK_scoped_idents, make_vector(0));
    u64!(self + TTYPE_CHECK_resolve_later, make_set(0, NULL, NULL));
    u64!(self + TTYPE_CHECK_cur_proc, NULL);
    u64!(self + TTYPE_CHECK_did_return, false);
    return self;
end

proc tc_types self in return u64@(self + TTYPE_CHECK_types); end
proc tc_ast_types self in return u64@(self + TTYPE_CHECK_ast_types); end
proc tc_src_locs self in return u64@(self + TTYPE_CHECK_src_locs); end
proc tc_any_type self in return u64@(self + TTYPE_CHECK_any_type); end
proc tc_void_type self in return u64@(self + TTYPE_CHECK_void_type); end
proc tc_int_type self in return u64@(self + TTYPE_CHECK_int_type); end
proc tc_ptr_type self in return u64@(self + TTYPE_CHECK_ptr_type); end
proc tc_cstr_type self in return u64@(self + TTYPE_CHECK_cstr_type); end
proc tc_procs self in return u64@(self + TTYPE_CHECK_procs); end
proc tc_scoped_idents self in return u64@(self + TTYPE_CHECK_scoped_idents); end
proc tc_resolve_later self in return u64@(self + TTYPE_CHECK_resolve_later); end
proc tc_cur_proc self in return u64@(self + TTYPE_CHECK_cur_proc); end
proc tc_did_return self in return u64@(self + TTYPE_CHECK_did_return); end

proc tc_set_cur_proc self, val in u64!(self + TTYPE_CHECK_cur_proc, val); end
proc tc_set_did_return self, val in u64!(self + TTYPE_CHECK_did_return, val); end

proc tc_get_ast_type self, ast in
    var found = map_find(tc_ast_types(self), ast);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc tc_set_ast_type self, ast, type in
    var map = tc_ast_types(self);
    var found = map_find(map, ast);
    if found then
        var otype = map_pair_val(found);
        if otype != tc_any_type(self) and otype != type then
            printf("WARN: Changing expression's type.\n");
            printf("NOTE: The expression is: ");
            print_ast(ast);
            printf("NOTE: The old type was: ");
            print_type(otype);
            printf("NOTE: The new type is: ");
            print_type(type);
            tc_print_src_loc(self);
        end
    end
    if ast_kind(ast) == AstK_Ident then
        tc_set_ident_type(self, ast_ident(ast), type);
    end
    map_set(map, ast, type);
end

proc tc_add_type self, type in
    var name = type_name(type);
    var types = tc_types(self);
    if map_find(types, name) then
        printf("ERROR: A type named `%s` already exists.\n", name);
        tc_print_src_loc(self);
        exit(1);
    end
    map_set(types, name, type);
end

proc tc_get_type self, name in
    var found = map_find(tc_types(self), name);
    if found then
        return map_pair_val(found);
    end
    return NULL;
end

proc tc_push_scope self in
    vector_push(tc_scoped_idents(self), make_map(0, cstr_eq, cstr_hash));
end

proc tc_pop_scope self in
    vector_pop(tc_scoped_idents(self)); // @LEAK
end

proc tc_find_ident self, ident in
    var vec = tc_scoped_idents(self);
    var i = vector_len(vec) - 1;
    while i >= 0 do
        var found = map_find(vector_get(vec, i), ident);
        if found then
            return found;
        end
        i -= 1;
    end
    return NULL;
end

proc tc_set_ident_type self, ident, type in
    // First check if an ident resolves all of the way to top-level;
    // if it doesn't then define it in the local scope.
    var vec = tc_scoped_idents(self);
    var i = vector_len(vec) - 1;
    var map = NULL;
    var found = NULL;
    while i >= 0 do
        map = vector_get(vec, i);
        found = map_find(map, ident);
        if not found then
            map = NULL;
        else
            break;
        end
        i -= 1;
    end
    if not map then
        map = vector_back(vec);
    else
        var otype = map_pair_val(found);
        if otype != tc_any_type(self) and otype != type then
            printf("WARN: Changing type of `%s`\n", ident);
            printf("NOTE: The old type was: ");
            print_type(otype);
            printf("NOTE: The new type is: ");
            print_type(type);
            tc_print_src_loc(self);
        end
    end
    map_set(map, ident, type);
end

proc tc_set_local_ident_type self, ident, type in
    var map = vector_back(tc_scoped_idents(self));
    map_set(map, ident, type);
end

proc tc_add_resolve_later self, ast in
    set_add(tc_resolve_later(self), ast);
end

proc tc_current_src_loc self in
    return vector_back(tc_src_locs(self));
end

proc tc_print_src_loc self in
    print_src_loc(tc_current_src_loc(self));
end

proc tc_add_proc self, ident, proc_type_info in
    var procs = tc_procs(self);
    var found = map_find(procs, ident);
    if found then
        printf("WARN: Redefinition of procedure.\n");
        tc_print_src_loc(self);
    end
    map_set(procs, ident, proc_type_info);
end

proc tc_check_body self, body in
    var i = 0; var len = vector_len(body);
    while i < len do
        var ast = vector_get(body, i);
        tc_check(self, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc tc_check_ident self, ast in
    check_ast_kind(AstK_Ident, ast);
    var found = tc_find_ident(self, ast_ident(ast));
    if found then
        return map_pair_val(found);
    else
        tc_add_resolve_later(self, ast);
        return tc_any_type(self);
    end
end

proc tc_check_integer self, ast in
    check_ast_kind(AstK_Integer, ast);
    return tc_get_type(self, "int");
end

proc tc_check_string self, ast in
    check_ast_kind(AstK_String, ast);
    return tc_get_type(self, "cstr");
end

proc tc_check_call self, ast in
    check_ast_kind(AstK_Call, ast);
    var args = ast_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, vector_get(args, i));
        i += 1;
    end
    tc_check(self, ast_expr(ast));
    return tc_any_type(self);
end

proc tc_check_binop self, ast in
    check_ast_kind(AstK_BinOp, ast);
    var lhs = tc_check(self, ast_lhs(ast));
    var rhs = tc_check(self, ast_rhs(ast));
    var any = tc_any_type(self);
    var int = tc_int_type(self);
    // var ptr = tc_ptr_type(self);
    if lhs == any and rhs == any then
        tc_set_ast_type(self, ast_lhs(ast), int);
        tc_set_ast_type(self, ast_rhs(ast), int);
        return int;
    else if lhs == rhs then
        return lhs;
    else if lhs == any and rhs == int then
        tc_set_ast_type(self, ast_lhs(ast), int);
        return int;
    else if lhs == int and rhs == any then
        tc_set_ast_type(self, ast_rhs(ast), int);
        return int;
    end
    return tc_any_type(self);
end

proc tc_check_return self, ast in
    check_ast_kind(AstK_Return, ast);
    var type;
    if ast_expr(ast) then
        type = tc_check(self, ast_expr(ast));
    else
        type = tc_void_type(self);
    end
    var cur_proc = tc_cur_proc(self);
    var otype = proc_type_info_return_type(cur_proc);
    if otype != tc_any_type(self) and otype != type then
        printf("WARN: Changing procedure return type.\n");
        printf("NOTE: The expression is: ");
        print_ast(ast);
        printf("NOTE: The old type was: ");
        print_type(otype);
        printf("NOTE: The new type is: ");
        print_type(type);
        tc_print_src_loc(self);
    end
    tc_set_did_return(self, true);
    proc_type_info_set_return_type(cur_proc, type);
    return tc_void_type(self);
end

proc tc_check_var_decl self, ast in
    check_ast_kind(AstK_VarDecl, ast);
    tc_set_local_ident_type(self, ast_ident(ast), tc_any_type(self));
    return tc_void_type(self);
end

proc tc_check_var_assign self, ast in
    check_ast_kind(AstK_VarAssign, ast);
    var type = tc_check(self, ast_assign_expr(ast));
    tc_set_local_ident_type(self, ast_ident(ast), type);
    return tc_void_type(self);
end

proc tc_check_assign self, ast in
    check_ast_kind(AstK_Assign, ast);
    var type = tc_check(self, ast_assign_expr(ast));
    tc_set_ident_type(self, ast_ident(ast), type);
    return tc_void_type(self);
end

proc tc_check_procedure self, ast in
    check_ast_kind(AstK_Procedure, ast);
    tc_push_scope(self);
    var params = ast_params(ast);
    var len = vector_len(params);
    var param_types = make_vector(len);
    var i = 0;
    var any = tc_any_type(self);
    while i < len do
        vector_push(param_types, any);
        tc_set_local_ident_type(self, vector_get(params, i), any);
        i += 1;
    end
    var proc_type_info = make_proc_type_info(any, param_types);
    tc_set_cur_proc(self, proc_type_info);
    tc_set_did_return(self, false);
    tc_add_proc(self, ast_ident(ast), proc_type_info);

    tc_check_body(self, ast_body(ast));

    if not tc_did_return(self) then
        proc_type_info_set_return_type(proc_type_info, tc_void_type(self));
    end

    tc_pop_scope(self);
    return tc_void_type(self);
end

proc tc_check_if_else self, ast in
    check_ast_kind(AstK_IfElse, ast);
    tc_check(self, ast_test(ast));
    tc_check_body(self, ast_consequence(ast));
    tc_check_body(self, ast_alternative(ast));
    return tc_void_type(self);
end

proc tc_check_while self, ast in
    check_ast_kind(AstK_While, ast);
    tc_check(self, ast_test(ast));
    tc_check_body(self, ast_body(ast));
    return tc_void_type(self);
end

proc tc_check_pointer_read self, ast in
    check_ast_kind(AstK_PointerRead, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, vector_get(args, i));
        i += 1;
    end
    return tc_any_type(self);
end

proc tc_check_pointer_write self, ast in
    check_ast_kind(AstK_PointerWrite, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, vector_get(args, i));
        i += 1;
    end
    return tc_void_type(self);
end

proc tc_check_prefix_op self, ast in
    check_ast_kind(AstK_Prefix, ast);
    return tc_check(self, ast_expr(ast));
end

proc tc_check_const self, ast in
    check_ast_kind(AstK_Const, ast);
    var type = tc_check(self, ast_assign_expr(ast));
    tc_set_ident_type(self, ast_ident(ast), type);
    return tc_void_type(self);
end

proc tc_check_extern self, ast in
    check_ast_kind(AstK_Extern, ast);
    return tc_void_type(self);
end

proc tc_check_inline_asm self, ast in
    check_ast_kind(AstK_InlineAsm, ast);
    return tc_void_type(self);
end

proc tc_check_global self, ast in
    check_ast_kind(AstK_Global, ast);
    var type = tc_check(self, ast_assign_expr(ast));
    tc_set_ident_type(self, ast_ident(ast), type);
    return tc_void_type(self);
end

proc tc_check self, ast in
    var k = ast_kind(ast);
    vector_push(tc_src_locs(self), token_src_loc(ast_token(ast)));
    var type;
    if k == AstK_Ident then type = tc_check_ident(self, ast);
    else if k == AstK_Integer then type = tc_check_integer(self, ast);
    else if k == AstK_String then type = tc_check_string(self, ast);
    else if k == AstK_Call then type = tc_check_call(self, ast);
    else if k == AstK_BinOp then type = tc_check_binop(self, ast);
    else if k == AstK_Return then type = tc_check_return(self, ast);
    else if k == AstK_VarDecl then type = tc_check_var_decl(self, ast);
    else if k == AstK_VarAssign then type = tc_check_var_assign(self, ast);
    else if k == AstK_Assign then type = tc_check_assign(self, ast);
    else if k == AstK_Procedure then type = tc_check_procedure(self, ast);
    else if k == AstK_IfElse then type = tc_check_if_else(self, ast);
    else if k == AstK_While then type = tc_check_while(self, ast);
    else if k == AstK_PointerRead then type = tc_check_pointer_read(self, ast);
    else if k == AstK_PointerWrite then type = tc_check_pointer_write(self, ast);
    else if k == AstK_Prefix then type = tc_check_prefix_op(self, ast);
    else if k == AstK_Const then type = tc_check_const(self, ast);
    else if k == AstK_Extern then type = tc_check_extern(self, ast);
    else if k == AstK_InlineAsm then type = tc_check_inline_asm(self, ast);
    else if k == AstK_Global then type = tc_check_global(self, ast);
    else if k == AstK_Break then type = tc_void_type(self);
    else if k == AstK_Continue then type = tc_void_type(self);
    else
        printf("`tc_check` in typechecking.randy");
        printf("Unhandled AstK: %d\n", k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
    tc_set_ast_type(self, ast, type);
    vector_pop(tc_src_locs(self));
    return type;
end

proc typecheck self, roots in
    var t;
    tc_push_scope(self);

    t = make_type("any", 0, false); // temporary "black hole" type, matches anything
    u64!(self + TTYPE_CHECK_any_type, t);
    tc_add_type(self, t);

    t = make_type("void", 0, false); // only usable for proc return types
    u64!(self + TTYPE_CHECK_void_type, t);
    tc_add_type(self, t);

    t = make_type("int", 8, false);
    u64!(self + TTYPE_CHECK_int_type, t);
    tc_add_type(self, t);

    t = make_type("ptr", 8, true);
    u64!(self + TTYPE_CHECK_ptr_type, t);
    tc_add_type(self, t);

    t = make_type("cstr", 8, true);
    u64!(self + TTYPE_CHECK_cstr_type, t);
    tc_add_type(self, t);

    var i = 0; var len = vector_len(roots);
    while i < len do
        tc_check(self, vector_get(roots, i));
        i += 1;
    end

    // var set = tc_resolve_later(self);
    // var cur = set_begin(set);
    // while cur != set_end(set) do
    //     printf(">>> %p: ", u64@(cur)); print_ast(u64@(cur));
    //     cur = set_next(set, cur);
    // end
end

proc tc_print_types self in
    // var cur; var map;

    // map = tc_ast_types(self);
    // cur = map_begin(map);
    // while cur != map_end(map) do
    //     printf("===========\n");
    //     printf("%p: ", map_pair_key(cur)); print_ast(map_pair_key(cur));
    //     print_type(map_pair_val(cur));
    //     cur = map_next(map, cur);
    // end

    // printf("~~~~~~~~~~~~\n");

    // map = tc_procs(self);
    // cur = map_begin(map);
    // while cur != map_end(map) do
    //     printf("%s: ", map_pair_key(cur));
    //     print_proc_type_info(map_pair_val(cur));
    //     cur = map_next(map, cur);
    // end
        
end
