
struct TypeCheck in
    current_proc_name: cstr;
    current_proc_type: type;
end

proc make_type_check -> TypeCheck& in
    var self = cast(calloc(1, __sizeof(TypeCheck)), TypeCheck&);
    return self;
end

proc free_type_check self: TypeCheck& in
    free(self);
end

proc _tc_check_ident_type tt, lhs_sym, rhs_expr, ast in
    var sym_type = symbol_type(lhs_sym);
    if not sym_type or sym_type == tt_any_type(tt) then
        printf("ERROR: Type of `%s` could not be inferred.\n", symbol_name(lhs_sym));
        print_ast_src_loc(ast);
        g_Errors += 1;
    end

    var rhs_type = tt_get_ast_type(tt, rhs_expr);
    if not rhs_type or rhs_type == tt_any_type(tt) then
        printf("ERROR: Type of assignment to `%s` could not be inferred.\n", symbol_name(lhs_sym));
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
        
    if not types_assignable(tt, sym_type, rhs_type) then
        printf("ERROR: The type of `%s` is `", symbol_name(lhs_sym));
        tt_print_type_name(tt, sym_type);
        printf("` which is not assignable by `");
        tt_print_type_name(tt, rhs_type);
        printf(".`\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc _tc_check_is_scalar_type tt, ast, type in
    if type_is_scalar(type) then
        return;
    end
    printf("ERROR: used type `");
    tt_print_type_name(tt, type);
    printf("` where scalar is required.\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc _tc_check_ident_has_type st, ident, ast in
    var sym = st_get_symbol(st, ident);
    var type = symbol_type(sym);
    if not type or type_size(type) == 0 then
        printf("ERROR: type of `%s` is undefined.\n", ident);
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc _tc_check_is_int_like tt, ast, type in
    if type_is_int_like(type) then
        return;
    end
    printf("ERROR: used type `");
    tt_print_type_name(tt, type);
    printf("` where `int`-like is required.\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc tc_check_body self, tt, st, body in
    var i = 0; var len = body.length;
    while i < len do
        var ast = vector_get(body, i);
        tc_check(self, tt, st, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc tc_check_ident self, tt, st, ast in
    check_ast_kind(AstK_Ident, ast);
    _tc_check_ident_has_type(st, ast_ident(ast), ast);
end

proc tc_check_call self, tt, st, ast in
    check_ast_kind(AstK_Call, ast);
    tc_check(self, tt, st, ast_expr(ast));
    var call_type = tt_get_ast_type(tt, ast_expr(ast));
    assert(call_type);
    if not type_is_procedure(call_type) then
        printf("ERROR: type `");
        tt_print_type_name(tt, call_type);
        printf("` is not a callable object.\n");
        printf("NOTE: The expression is: ");
        print_ast(ast);
        print_ast_src_loc(ast);
        g_Errors += 1;
        return;
    end

    var param_types = type_proc_parameters(call_type);
    var args = ast_args(ast);
    var i = 0; var len = min(param_types.length, args.length);
    while i < len do
        var arg = vector_get(args, i);
        tc_check(self, tt, st, arg);
        var param_type = vector_get(param_types, i);
        assert(param_type);
        var arg_type = tt_get_ast_type(tt, arg);
        if not arg_type then
            print_ast(arg);
            print_ast_src_loc(ast);
        end
        assert(arg_type);
        if not types_assignable(tt, param_type, arg_type) then
            printf("ERROR: Type mismatch for argument %d: ", i);
            print_ast(ast);
            printf("NOTE: The expected type is `");
            tt_print_type_name(tt, param_type);
            printf("` but got `");
            tt_print_type_name(tt, arg_type);
            printf(".`\n");
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        i += 1;
    end

    len = args.length;
    while i < len do
        tc_check(self, tt, st, vector_get(args, i));
        i += 1;
    end

    if (i < param_types.length) or (i > param_types.length and not type_proc_varargs(call_type)) then
        var expr = ast_expr(ast);
        if ast_kind(expr) == AstK_Ident then
            printf("ERROR: call to `%s` expects %d arguments but got %d.\n",
                ast_ident(expr),
                param_types.length,
                args.length);
        elif ast_kind(expr) == AstK_ScopeResolve then
            printf("ERROR: call to `");
            _print_ast_scope_resolve(expr, 0);
            printf("` expects %d arguments but got %d.\n", param_types.length, args.length);
        else
            printf("ERROR: call expects %d arguments but got %d.\n",
                param_types.length,
                args.length);
        end
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc tc_check_binop self, tt, st, ast in
    check_ast_kind(AstK_BinOp, ast);
    tc_check(self, tt, st, ast_lhs(ast));
    tc_check(self, tt, st, ast_rhs(ast));
end

proc tc_check_return self, tt, st, ast in
    check_ast_kind(AstK_Return, ast);
    assert(self.current_proc_type);
    var return_type = type_proc_return_type(self.current_proc_type);
    var expr = ast_expr(ast);
    if expr then
        tc_check(self, tt, st, expr);
        var expr_type = tt_get_ast_type(tt, expr);
        assert(expr_type);
        if not types_assignable(tt, return_type, expr_type) then
            printf("ERROR: Return type for `%s` is `", self.current_proc_name);
            tt_print_type_name(tt, return_type);
            printf("` cannot return `");
            tt_print_type_name(tt, expr_type);
            printf(".`\nNOTE: The expression is: ");
            print_ast(ast);
            print_token_loc(ast_token(ast));
            g_Errors += 1;
        end
    elif return_type != tt_void_type(tt) then
        printf("ERROR: Return type for `%s` is `", self.current_proc_name);
        tt_print_type_name(tt, return_type);
        printf("` cannot return `void.`\n");
        printf("NOTE: The expression is: ");
        print_ast(ast);
        print_token_loc(ast_token(ast));
        g_Errors += 1;
    end
end

proc tc_check_var_decl self, tt, st, ast in
    check_ast_kind(AstK_VarDecl, ast);
    _tc_check_ident_has_type(st, ast_ident(ast), ast);
end

proc tc_check_var_assign self, tt, st, ast in
    check_ast_kind(AstK_VarAssign, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_assign_op self, tt, st, ast in
    check_ast_kind(AstK_AssignOp, ast);
    var lhs_sym = st_get_symbol(st, ast_ident(ast));
    assert(lhs_sym);

    var op = ast_op(ast);
    if op == TK_Assign then
        var expr = ast_assign_expr(ast);
        tc_check(self, tt, st, expr);
        _tc_check_ident_type(tt, lhs_sym, expr, ast);
    else
        var lhs_type = symbol_type(lhs_sym);
        if not lhs_type or lhs_type == tt_any_type(tt) then
            printf("ERROR: Type of `%s` could not be inferred.\n", symbol_name(lhs_sym));
            print_ast_src_loc(ast);
            g_Errors += 1;
        end

        var rhs_type = tt_get_ast_type(tt, ast_assign_expr(ast));
        if not rhs_type or rhs_type == tt_any_type(tt) then
            printf("ERROR: Type of assignment to `%s` could not be inferred.\n", symbol_name(lhs_sym));
            print_ast_src_loc(ast);
            g_Errors += 1;
        end

        if op == TK_PlusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
            return; // reference += int_like
        elif op == TK_MinusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
            return; // reference -= int_like
        elif types_assignable(tt, lhs_type, rhs_type) then
            return; // TODO: Verify this is correct behaviour.
        end

        printf("ERROR: The type of `%s` is `", symbol_name(lhs_sym));
        tt_print_type_name(tt, lhs_type);
        printf("` which is not assignable by `");
        tt_print_type_name(tt, rhs_type);
        printf(".`\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc tc_check_procedure self, tt, st, ast in
    check_ast_kind(AstK_Procedure, ast);
    var params = ast_params(ast);
    var i = 0; var len = params.length;
    var any = tt_any_type(tt);
    var errors = make_vector(0);
    while i < len do
        var param = vector_get(params, i);
        var param_sym = st_get_symbol(st, param);
        assert(param_sym);
        var param_type = symbol_type(param_sym);
        if not param_type or type_size(param_type) == 0 then
            vector_push(errors, param_sym);
        end
        i += 1;
    end
    if errors.length > 0 then
        printf("ERROR: in proc `%s`: \n", ast_ident(ast));
        i = 0; len = errors.length;
        while i < len do
            var sym = vector_get(errors, i);
            var type = symbol_type(sym);
            printf("ERROR: `%s` has type `", symbol_name(sym));
            tt_print_type_name(tt, type);
            printf(".`\n");
            i += 1;
        end
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);

    self.current_proc_name = symbol_name(sym);
    self.current_proc_type = symbol_type(sym);

    tc_check_body(self, tt, st, ast_body(ast));

    self.current_proc_type = NULL;
    self.current_proc_name = NULL;
end

proc tc_check_if_else self, tt, st, ast in
    check_ast_kind(AstK_IfElse, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_consequence(ast));
    tc_check_body(self, tt, st, ast_alternative(ast));

    var test_type = tt_get_ast_type(tt, ast_test(ast));
    assert(test_type);
    _tc_check_is_scalar_type(tt, ast_test(ast), test_type);
end

proc tc_check_while self, tt, st, ast in
    check_ast_kind(AstK_While, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_body(ast));

    var test_type = tt_get_ast_type(tt, ast_test(ast));
    assert(test_type);
    _tc_check_is_scalar_type(tt, ast_test(ast), test_type);
end

proc tc_check_pointer_read self, tt, st, ast in
    check_ast_kind(AstK_PointerRead, ast);
    tc_check(self, tt, st, vector_get(ast_pop_args(ast), 0));
end

proc tc_check_pointer_write self, tt, st, ast in
    check_ast_kind(AstK_PointerWrite, ast);
    var pop_args = ast_pop_args(ast);
    tc_check(self, tt, st, vector_get(pop_args, 0));
    tc_check(self, tt, st, vector_get(pop_args, 1));
end

proc tc_check_prefix_op self, tt, st, ast in
    check_ast_kind(AstK_Prefix, ast);
    tc_check(self, tt, st, ast_expr(ast));

    var expr_type = tt_get_ast_type(tt, ast_expr(ast));
    assert(expr_type);

    var op = ast_op(ast);
    if op == TK_KW_not then
        _tc_check_is_scalar_type(tt, ast, expr_type);
    else
        _tc_check_is_int_like(tt, ast, expr_type);
    end
end

proc tc_check_const self, tt, st, ast in
    check_ast_kind(AstK_Const, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_global self, tt, st, ast in
    check_ast_kind(AstK_Global, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_cast self, tt, st, ast in
    check_ast_kind(AstK_Cast, ast);
    tc_check(self, tt, st, ast_expr(ast));
end

proc tc_check_member_access self, tt, st, ast in
    // field resolution happened in type inference so not much needed to check here
    check_ast_kind(AstK_MemberAccess, ast);
    var expr = ast_expr(ast);
    var member = ast_member(ast);
    tc_check(self, tt, st, expr);
    var type = tt_get_ast_type(tt, expr);
    if not type or type_size(type) == 0 then
        printf("ERROR: attempting to access member `%s` on undefined type.\n", member);
        printf("NOTE: the expression is:");
        print_ast(ast);
        print_ast_src_loc(ast);
        g_Errors += 1;
        return;
    end

    while type_is_reference(type) do
        type = type_deref_type(type);
    end

    if not type_is_struct(type) then
        printf("ERROR: attempting to access member `%s` with '.' operator on non-struct type.\n", member);
        printf("NOTE: the expression is:");
        print_ast(ast);
        print_ast_src_loc(ast);
        g_Errors += 1;
        return;
    end

    var found = false;
    var fields = type_struct_fields(type);
    var i = 0; var len = fields.length;
    while i < len do
        var field = vector_get(fields, i);
        if cstr_eq(field_name(field), member) then
            found = true;
            break;
        end
        i += 1;
    end
    if not found then
        var procs = type_struct_procs(type);
        i = 0; len = procs.length;
        while i < len do
            var proc_ = vector_get(procs, i);
            if cstr_eq(symbol_name(proc_), member) then
                found = true;
                break;
            end
            i += 1;
        end
    end

    if not found then
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` has no type named `%s`.\n", member);
        printf("NOTE: the expression is:");
        print_ast(ast);
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc tc_check_assign_member self, tt, st, ast in
    check_ast_kind(AstK_AssignMember, ast);

    var lhs = ast_lhs(ast);
    var rhs = ast_rhs(ast);
    tc_check(self, tt, st, lhs);
    tc_check(self, tt, st, rhs);

    var op = ast_op(ast);
    var lhs_type = tt_get_ast_type(tt, lhs);
    var rhs_type = tt_get_ast_type(tt, rhs);

    if op == TK_Assign then
        if types_assignable(tt, lhs_type, rhs_type) then
            return;
        end
    elif op == TK_PlusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
        return; // reference += int_like
    elif op == TK_MinusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
        return; // reference -= int_like
    elif types_assignable(tt, lhs_type, rhs_type) then
        return; // TODO: Verify this is correct behaviour.
    end

    printf("ERROR: the type of `%s` is `", ast_member(lhs));
    tt_print_type_name(tt, lhs_type);
    printf("` which is not assignable by `");
    tt_print_type_name(tt, rhs_type);
    printf(".`\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc tc_check_scope_resolve self, tt, st, ast in
    assert(ast_kind(ast_lhs(ast)) == AstK_Type, "Nested resolution not supported yet.\n");
    assert(ast_kind(ast_rhs(ast)) == AstK_Ident, "Nested resolution not supported yet.\n");

    var type = ast_type(ast_lhs(ast));
    var member = ast_ident(ast_rhs(ast));
    if type_is_enum(type) then
        var enum_vals = type_enum_values(type);
        var i = 0; var len = enum_vals.length;
        while i < len do
            var ev = cast(vector_get(enum_vals, i), EnumValue&);
            if cstr_eq(ev.name, member) then
                return; // OK.
            end
            i += 1;
        end
        printf("ERROR: enum `");
        tt_print_type_name(tt, type);
        printf("` has no value `%s.`\n", member);
        print_ast_src_loc(ast);
        g_Errors += 1;
    elif type_is_struct(type) then
        assert(false, "TODO: scope resolution operator for structs\n");
    elif type_is_union(type) then
        assert(false, "TODO: scope resolution operator for unions\n");
    else
        printf("ERROR: type `");
        tt_print_type_name(tt, type);
        printf("` is not a struct, enum, or union.\n", member);
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc tc_check self, tt, st, ast in
    var k = ast_kind(ast);
    if k == AstK_Ident then tc_check_ident(self, tt, st, ast);
    elif k == AstK_Integer then // nothing
    elif k == AstK_String then //nothing
    elif k == AstK_Call then tc_check_call(self, tt, st, ast);
    elif k == AstK_BinOp then tc_check_binop(self, tt, st, ast);
    elif k == AstK_Return then tc_check_return(self, tt, st, ast);
    elif k == AstK_VarDecl then tc_check_var_decl(self, tt, st, ast);
    elif k == AstK_VarAssign then tc_check_var_assign(self, tt, st, ast);
    elif k == AstK_Procedure then tc_check_procedure(self, tt, st, ast);
    elif k == AstK_IfElse then tc_check_if_else(self, tt, st, ast);
    elif k == AstK_While then tc_check_while(self, tt, st, ast);
    elif k == AstK_PointerRead then tc_check_pointer_read(self, tt, st, ast);
    elif k == AstK_PointerWrite then tc_check_pointer_write(self, tt, st, ast);
    elif k == AstK_Prefix then tc_check_prefix_op(self, tt, st, ast);
    elif k == AstK_Const then tc_check_const(self, tt, st, ast);
    elif k == AstK_Extern then // nothing
    elif k == AstK_InlineAsm then // nothing
    elif k == AstK_Global then tc_check_global(self, tt, st, ast);
    elif k == AstK_Break then // nothing
    elif k == AstK_Continue then // nothing
    elif k == AstK_AssignOp then tc_check_assign_op(self, tt, st, ast);
    elif k == AstK_Struct then // nothing
    elif k == AstK_Cast then tc_check_cast(self, tt, st, ast);
    elif k == AstK_MemberAccess then tc_check_member_access(self, tt, st, ast);
    elif k == AstK_AssignMember then tc_check_assign_member(self, tt, st, ast);
    elif k == AstK_SizeofExpr then // nothing
    elif k == AstK_SizeofType then // nothing
    elif k == AstK_Enum then // nothing
    elif k == AstK_Type then // nothing
    elif k == AstK_ScopeResolve then // nothing
    else
        printf("  File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %s (%d)\n", ast_kind_cstr(k), k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
end

proc type_check type_table, symbol_table, compile_order: Vector& in
    var type_checker = make_type_check();
    var i = 0; var len = compile_order.length;
    while i < len do
        tc_check(type_checker, type_table, symbol_table, vector_get(compile_order, i));
        i += 1;
    end
    free_type_check(type_checker);
end
