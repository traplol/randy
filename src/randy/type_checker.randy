
proc tc_check_body tt, st, body in
    var i = 0; var len = vector_len(body);
    while i < len do
        var ast = vector_get(body, i);
        tc_check(tt, st, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc tc_check_ident tt, st, ast in
    check_ast_kind(AstK_Ident, ast);
end

proc tc_check_call tt, st, ast in
    check_ast_kind(AstK_Call, ast);
end

proc tc_check_binop tt, st, ast in
    check_ast_kind(AstK_BinOp, ast);
end

proc tc_check_return tt, st, ast in
    check_ast_kind(AstK_Return, ast);
end

proc tc_check_var_decl tt, st, ast in
    check_ast_kind(AstK_VarDecl, ast);
end

proc tc_check_var_assign tt, st, ast in
    check_ast_kind(AstK_VarAssign, ast);
end

proc tc_check_assign_op tt, st, ast in
    check_ast_kind(AstK_AssignOp, ast);
end

proc tc_check_procedure tt, st, ast in
    check_ast_kind(AstK_Procedure, ast);
end

proc tc_check_if_else tt, st, ast in
    check_ast_kind(AstK_IfElse, ast);
    // tc_check(tt, st, ast_test(ast));
    // tc_check_body(tt, st, ast_consequence(ast));
    // tc_check_body(tt, st, ast_alternative(ast));
end

proc tc_check_while tt, st, ast in
    check_ast_kind(AstK_While, ast);
    // tc_check(tt, st, ast_test(ast));
    // tc_check_body(tt, st, ast_body(ast));
end

proc tc_check_pointer_read tt, st, ast in
    check_ast_kind(AstK_PointerRead, ast);
end

proc tc_check_pointer_write tt, st, ast in
    check_ast_kind(AstK_PointerWrite, ast);
end

proc tc_check_prefix_op tt, st, ast in
    check_ast_kind(AstK_Prefix, ast);
    tc_check(tt, st, ast_expr(ast));
end

proc tc_check_const tt, st, ast in
    check_ast_kind(AstK_Const, ast);
end

proc tc_check_global tt, st, ast in
    check_ast_kind(AstK_Global, ast);
end

proc tc_check tt, st, ast in
    var k = ast_kind(ast);
    if k == AstK_Ident then tc_check_ident(tt, st, ast);
    elif k == AstK_Integer then // nothing
    elif k == AstK_String then //nothing
    elif k == AstK_Call then tc_check_call(tt, st, ast);
    elif k == AstK_BinOp then tc_check_binop(tt, st, ast);
    elif k == AstK_Return then tc_check_return(tt, st, ast);
    elif k == AstK_VarDecl then tc_check_var_decl(tt, st, ast);
    elif k == AstK_VarAssign then tc_check_var_assign(tt, st, ast);
    elif k == AstK_Procedure then tc_check_procedure(tt, st, ast);
    elif k == AstK_IfElse then tc_check_if_else(tt, st, ast);
    elif k == AstK_While then tc_check_while(tt, st, ast);
    elif k == AstK_PointerRead then tc_check_pointer_read(tt, st, ast);
    elif k == AstK_PointerWrite then tc_check_pointer_write(tt, st, ast);
    elif k == AstK_Prefix then tc_check_prefix_op(tt, st, ast);
    elif k == AstK_Const then tc_check_const(tt, st, ast);
    elif k == AstK_Extern then //
    elif k == AstK_InlineAsm then // nothing
    elif k == AstK_Global then tc_check_global(tt, st, ast);
    elif k == AstK_Break then // nothing
    elif k == AstK_Continue then // nothing
    elif k == AstK_AssignOp then tc_check_assign_op(tt, st, ast);
    elif k == AstK_Struct then // nothing
    else
        printf("  File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %d\n", k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
end

proc type_check type_table, sym_table, roots, compile_order in
    var i = 0; var len = vector_len(roots);
    while i < len do
        tc_check(type_table, sym_table, vector_get(roots, i));
        i += 1;
    end
end

proc tc_print_types type_table in
    var ast_types = type_table_ast_types(type_table);
    var cur = map_begin(ast_types);
    while cur != map_end(ast_types) do
        var ast = map_pair_key(cur);
        var type = map_pair_val(cur);
        var type_name = tt_get_type_name(type_table, type);
        printf("===============\n");
        print_ast(ast);
        print_type(type);
        printf("type name: %s\n", type_name);
        cur = map_next(ast_types, cur);
    end
end

proc tc_print_symbols type_table, symbol_table in
    printf("~~~~~~\n");
    var symbols = symbol_table_table(symbol_table);
    var cur = map_begin(symbols);
    while cur != map_end(symbols) do
        var symbol = map_pair_val(cur);
        var sym_name = symbol_name(symbol);
        var sym_type = symbol_type(symbol);
        printf("[%p]%s: ", sym_name, sym_name);
        if sym_type then
            if type_is_procedure(sym_type) then
                var string = tt_get_proc_type_name(type_table, sym_type);
                printf("%s\n", string_cstr(string));
                free_string(string);
            else
                printf("%s\n", tt_get_type_name(type_table, sym_type));
            end
        else
            printf("{no type}\n");
        end
        cur = map_next(symbols, cur);
    end
end
