// var map = tt_ast_types(self);
// var found = map_find(map, ast);
// if found then
//     var otype = map_pair_val(found);
//     if otype != tt_any_type(self) and otype != type then
//         printf("WARN: Changing expression's type.\n");
//         printf("NOTE: The expression is: ");
//         print_ast(ast);
//         printf("NOTE: The old type was: ");
//         print_type(otype);
//         printf("NOTE: The new type is: ");
//         print_type(type);
//         tt_print_src_loc(self);
//     end
// end

const TTYPE_CHECKER_cur_procs = 0;   // stack of procs
const TTYPE_CHECKER_did_returns = 8; // stack of bools
const TTYPE_CHECKER_src_locs = 16;  // stack of src_locs
const sizeof_TTYPE_CHECKER = 24;

proc make_type_checker in
    var self = malloc(sizeof_TTYPE_CHECKER);
    u64!(self + TTYPE_CHECKER_cur_procs, make_vector(0));
    u64!(self + TTYPE_CHECKER_did_returns, make_string(0));
    u64!(self + TTYPE_CHECKER_src_locs, make_vector(0));
    return self;
end

proc type_checker_cur_procs self in return u64@(self + TTYPE_CHECKER_cur_procs); end
proc type_checker_did_returns self in return u64@(self + TTYPE_CHECKER_did_returns); end
proc type_checker_src_locs self in return u64@(self + TTYPE_CHECKER_src_locs); end

proc free_type_checker self in
    if self then
        free_vector(type_checker_cur_procs(self));
        free_string(type_checker_did_returns(self));
        free_vector(type_checker_src_locs(self));
        free(self);
    end
end

proc tc_current_proc self in
    return vector_back(type_checker_cur_procs(self));
end

proc tc_did_return self in
    return string_back(type_checker_did_returns(self));
end

proc tc_set_did_return self, val in
    var str = type_checker_did_returns(self);
    var len = string_len(str);
    if len > 0 then
        string_set(str, len-1, val);
    end
end

proc tc_push_src_loc self, src_loc in
    vector_push(type_checker_src_locs(self), src_loc);
end

proc tc_pop_src_loc self in
    vector_pop(type_checker_src_locs(self));
end

proc tc_current_src_loc self in
    return vector_back(type_checker_src_locs(self));
end

proc tc_print_src_loc self in
    print_src_loc(tc_current_src_loc(self));
end

proc tc_push_proc self in
    vector_push(type_checker_cur_procs(self), NULL);
    string_push(type_checker_did_returns(self), 0);
end

proc tc_pop_proc self in
    vector_pop(type_checker_cur_procs(self));
    string_pop(type_checker_did_returns(self));
end

proc tc_check_body self, tt, st, body in
    var i = 0; var len = vector_len(body);
    while i < len do
        var ast = vector_get(body, i);
        tc_check(self, tt, st, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc tc_check_ident self, tt, st, ast in
    check_ast_kind(AstK_Ident, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_any_type(tt);
end

proc tc_check_integer self, tt, st, ast in
    check_ast_kind(AstK_Integer, ast);
    return tt_int_type(tt);
end

proc tc_check_string self, tt, st, ast in
    check_ast_kind(AstK_String, ast);
    return tt_cstr_type(tt);
end

proc tc_check_call self, tt, st, ast in
    check_ast_kind(AstK_Call, ast);
    var args = ast_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, tt, st, vector_get(args, i));
        i += 1;
    end
    tc_check(self, tt, st, ast_expr(ast));
    return tt_any_type(tt);
end

proc tc_check_binop self, tt, st, ast in
    check_ast_kind(AstK_BinOp, ast);
    var lhs = tc_check(self, tt, st, ast_lhs(ast));
    var rhs = tc_check(self, tt, st, ast_rhs(ast));
    var any = tt_any_type(tt);
    var int = tt_int_type(tt);
    if lhs == any and rhs == any then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    else if lhs == rhs then
        return lhs;
    else if lhs == any and rhs == int then
        tt_set_ast_type(tt, ast_lhs(ast), int);
        return int;
    else if lhs == int and rhs == any then
        tt_set_ast_type(tt, ast_rhs(ast), int);
        return int;
    end
    return tt_any_type(tt);
end

proc tc_check_return self, tt, st, ast in
    check_ast_kind(AstK_Return, ast);
    var type;
    if ast_expr(ast) then
        type = tc_check(self, tt, st, ast_expr(ast));
    else
        type = tt_void_type(tt);
    end
    tc_set_did_return(self, true);
    return tt_void_type(tt);
end

proc tc_check_var_decl self, tt, st, ast in
    check_ast_kind(AstK_VarDecl, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_var_assign self, tt, st, ast in
    check_ast_kind(AstK_VarAssign, ast);
    var type = tc_check(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_assign self, tt, st, ast in
    check_ast_kind(AstK_Assign, ast);
    var type = tc_check(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_assign_op self, tt, st, ast in
    check_ast_kind(AstK_AssignOp, ast);
    var type = tc_check(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_procedure self, tt, st, ast in
    check_ast_kind(AstK_Procedure, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);

    var params = ast_params(ast);
    var len = vector_len(params);
    var param_types = make_vector(len);
    var i = 0;
    var any = tt_any_type(tt);
    while i < len do
        var param = vector_get(params, i);
        symbol = st_get_symbol(st, param);
        vector_push(param_types, any);
        i += 1;
    end
    //var proc_type_info = make_proc_type_info(any, param_types);
    tc_push_proc(self);//, proc_type_info);

    tc_check_body(self, tt, st, ast_body(ast));

    if not tc_did_return(self) then
        // TODO: set return type to void...
    end

    tc_pop_proc(self);

    return tt_void_type(tt);
end

proc tc_check_if_else self, tt, st, ast in
    check_ast_kind(AstK_IfElse, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_consequence(ast));
    tc_check_body(self, tt, st, ast_alternative(ast));
    return tt_void_type(tt);
end

proc tc_check_while self, tt, st, ast in
    check_ast_kind(AstK_While, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_body(ast));
    return tt_void_type(tt);
end

proc tc_check_pointer_read self, tt, st, ast in
    check_ast_kind(AstK_PointerRead, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, tt, st, vector_get(args, i));
        i += 1;
    end
    return tt_any_type(tt);
end

proc tc_check_pointer_write self, tt, st, ast in
    check_ast_kind(AstK_PointerWrite, ast);
    var args = ast_pop_args(ast);
    var i = 0; var len = vector_len(args);
    while i < len do
        tc_check(self, tt, st, vector_get(args, i));
        i += 1;
    end
    return tt_void_type(tt);
end

proc tc_check_prefix_op self, tt, st, ast in
    check_ast_kind(AstK_Prefix, ast);
    return tc_check(self, tt, st, ast_expr(ast));
end

proc tc_check_const self, tt, st, ast in
    check_ast_kind(AstK_Const, ast);
    var type = tc_check(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_extern self, tt, st, ast in
    check_ast_kind(AstK_Extern, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_inline_asm self, tt, st, ast in
    check_ast_kind(AstK_InlineAsm, ast);
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check_global self, tt, st, ast in
    check_ast_kind(AstK_Global, ast);
    var type = tc_check(self, tt, st, ast_assign_expr(ast));
    var ident = ast_ident(ast);
    var symbol = st_get_symbol(st, ident);
    return tt_void_type(tt);
end

proc tc_check self, tt, st, ast in
    var k = ast_kind(ast);
    tc_push_src_loc(self, token_src_loc(ast_token(ast)));
    var type;
    if k == AstK_Ident then type = tc_check_ident(self, tt, st, ast);
    else if k == AstK_Integer then type = tc_check_integer(self, tt, st, ast);
    else if k == AstK_String then type = tc_check_string(self, tt, st, ast);
    else if k == AstK_Call then type = tc_check_call(self, tt, st, ast);
    else if k == AstK_BinOp then type = tc_check_binop(self, tt, st, ast);
    else if k == AstK_Return then type = tc_check_return(self, tt, st, ast);
    else if k == AstK_VarDecl then type = tc_check_var_decl(self, tt, st, ast);
    else if k == AstK_VarAssign then type = tc_check_var_assign(self, tt, st, ast);
    else if k == AstK_Assign then type = tc_check_assign(self, tt, st, ast);
    else if k == AstK_Procedure then type = tc_check_procedure(self, tt, st, ast);
    else if k == AstK_IfElse then type = tc_check_if_else(self, tt, st, ast);
    else if k == AstK_While then type = tc_check_while(self, tt, st, ast);
    else if k == AstK_PointerRead then type = tc_check_pointer_read(self, tt, st, ast);
    else if k == AstK_PointerWrite then type = tc_check_pointer_write(self, tt, st, ast);
    else if k == AstK_Prefix then type = tc_check_prefix_op(self, tt, st, ast);
    else if k == AstK_Const then type = tc_check_const(self, tt, st, ast);
    else if k == AstK_Extern then type = tc_check_extern(self, tt, st, ast);
    else if k == AstK_InlineAsm then type = tc_check_inline_asm(self, tt, st, ast);
    else if k == AstK_Global then type = tc_check_global(self, tt, st, ast);
    else if k == AstK_Break then type = tt_void_type(tt);
    else if k == AstK_Continue then type = tt_void_type(tt);
    else if k == AstK_AssignOp then type = tc_check_assign_op(self, tt, st, ast);
    else
        printf("`tc_check` in typechecking.randy");
        printf("Unhandled AstK: %d\n", k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
    tt_set_ast_type(tt, ast, type);
    tc_pop_src_loc(self);
    return type;
end

proc typecheck type_table, sym_table, roots in
    var type_checker = make_type_checker();
    var i = 0; var len = vector_len(roots);
    while i < len do
        tc_check(type_checker, type_table, sym_table, vector_get(roots, i));
        i += 1;
    end
    free_type_checker(type_checker);
end

proc tc_print_types tt in
    printf("TODO: tc_print_types\n");
end
