
struct TypeCheck in
    current_proc_name: cstr;
    current_proc_type: type;
end

proc make_type_check -> TypeCheck& in
    var self = cast(calloc(1, __sizeof(TypeCheck)), TypeCheck&);
    return self;
end

proc free_type_check self: TypeCheck& in
    free(self);
end

proc _tc_check_ident_type tt, lhs_sym, rhs_expr, ast in
    var sym_type = symbol_type(lhs_sym);
    if not sym_type or sym_type == tt_any_type(tt) then
        printf("ERROR: Type of `%s` could not be inferred.\n", symbol_name(lhs_sym));
        print_ast_src_loc(ast);
        g_Errors += 1;
    end

    var rhs_type = tt_get_ast_type(tt, rhs_expr);
    if not rhs_type or rhs_type == tt_any_type(tt) then
        printf("ERROR: Type of assignment to `%s` could not be inferred.\n", symbol_name(lhs_sym));
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
        
    if not types_assignable(tt, sym_type, rhs_type) then
        printf("ERROR: The type of `%s` is `", symbol_name(lhs_sym));
        tt_print_type_name(tt, sym_type);
        printf("` which is not assignable by `");
        tt_print_type_name(tt, rhs_type);
        printf(".`\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc _tc_check_is_scalar_type tt, ast, type in
    if type_is_scalar(type) then
        return;
    end
    printf("ERROR: used type `");
    tt_print_type_name(tt, type);
    printf("` where scalar is required.\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc _tc_check_is_int_like tt, ast, type in
    if type_is_int_like(type) then
        return;
    end
    printf("ERROR: used type `");
    tt_print_type_name(tt, type);
    printf("` where `int`-like is required.\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc tc_check_body self, tt, st, body in
    var i = 0; var len = body.length;
    while i < len do
        var ast = vector_get(body, i);
        tc_check(self, tt, st, ast);
        if ast_kind(ast) == AstK_Return then
            break;
        end
        i += 1;
    end
end

proc tc_check_call self, tt, st, ast in
    check_ast_kind(AstK_Call, ast);
    tc_check(self, tt, st, ast_expr(ast));
    var call_type = tt_get_ast_type(tt, ast_expr(ast));
    assert(call_type);
    if not type_is_procedure(call_type) and call_type != tt_ptr_type(tt) then
        printf("ERROR: This is not a callable object.\n");
        printf("The expression is: ");
        print_ast(ast);
        print_ast_src_loc(ast);
        g_Errors += 1;
    end

    // TODO: remove this when function types have a first class representation.
    if call_type == tt_ptr_type(tt) then
        return;
    end

    var param_types = type_proc_parameters(call_type);
    var args = ast_args(ast);
    var i = 0; var len = min(param_types.length, args.length);
    while i < len do
        var arg = vector_get(args, i);
        tc_check(self, tt, st, arg);
        var param_type = vector_get(param_types, i);
        assert(param_type);
        var arg_type = tt_get_ast_type(tt, arg);
        if not arg_type then
            print_ast(ast);
            print_ast_src_loc(ast);
        end
        assert(arg_type);
        if not types_assignable(tt, param_type, arg_type) then
            printf("\nERROR: Type mismatch for argument %d: ", i);
            print_ast(ast);
            printf("NOTE: The expected type is `");
            tt_print_type_name(tt, param_type);
            printf("` but got `");
            tt_print_type_name(tt, arg_type);
            printf(".`\n");
            print_ast_src_loc(ast);
            g_Errors += 1;
        end
        i += 1;
    end
    if i < len and not type_proc_varargs(call_type) then

    end
end

proc tc_check_binop self, tt, st, ast in
    check_ast_kind(AstK_BinOp, ast);
    tc_check(self, tt, st, ast_lhs(ast));
    tc_check(self, tt, st, ast_rhs(ast));
end

proc tc_check_return self, tt, st, ast in
    check_ast_kind(AstK_Return, ast);
    assert(self.current_proc_type);
    var return_type = type_proc_return_type(self.current_proc_type);
    var expr = ast_expr(ast);
    if expr then
        tc_check(self, tt, st, expr);
        var expr_type = tt_get_ast_type(tt, expr);
        assert(expr_type);
        if not types_assignable(tt, return_type, expr_type) then
            printf("ERROR: Return type for `%s` is `", self.current_proc_name);
            tt_print_type_name(tt, return_type);
            printf("` cannot return `");
            tt_print_type_name(tt, expr_type);
            printf(".`\nNOTE: The expression is: ");
            print_ast(ast);
            print_token_loc(ast_token(ast));
            g_Errors += 1;
        end
    elif return_type != tt_void_type(tt) then
        printf("ERROR: Return type for `%s` is `", self.current_proc_name);
        tt_print_type_name(tt, return_type);
        printf("` cannot return `void.`\n");
        printf("NOTE: The expression is: ");
        print_ast(ast);
        print_token_loc(ast_token(ast));
        g_Errors += 1;
    end
end

proc tc_check_var_decl self, tt, st, ast in
    check_ast_kind(AstK_VarDecl, ast);
end

proc tc_check_var_assign self, tt, st, ast in
    check_ast_kind(AstK_VarAssign, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_assign_op self, tt, st, ast in
    check_ast_kind(AstK_AssignOp, ast);
    var lhs_sym = st_get_symbol(st, ast_ident(ast));
    assert(lhs_sym);

    var op = ast_op(ast);
    if op == TK_Assign then
        var expr = ast_assign_expr(ast);
        tc_check(self, tt, st, expr);
        _tc_check_ident_type(tt, lhs_sym, expr, ast);
    else
        var lhs_type = symbol_type(lhs_sym);
        if not lhs_type or lhs_type == tt_any_type(tt) then
            printf("ERROR: Type of `%s` could not be inferred.\n", symbol_name(lhs_sym));
            print_ast_src_loc(ast);
            g_Errors += 1;
        end

        var rhs_type = tt_get_ast_type(tt, ast_assign_expr(ast));
        if not rhs_type or rhs_type == tt_any_type(tt) then
            printf("ERROR: Type of assignment to `%s` could not be inferred.\n", symbol_name(lhs_sym));
            print_ast_src_loc(ast);
            g_Errors += 1;
        end

        if op == TK_PlusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
            return; // reference += int_like
        elif op == TK_MinusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
            return; // reference -= int_like
        elif types_assignable(tt, lhs_type, rhs_type) then
            return; // TODO: Verify this is correct behaviour.
        end

        printf("ERROR: The type of `%s` is `", symbol_name(lhs_sym));
        tt_print_type_name(tt, lhs_type);
        printf("` which is not assignable by `");
        tt_print_type_name(tt, rhs_type);
        printf(".`\n");
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
end

proc tc_check_procedure self, tt, st, ast in
    check_ast_kind(AstK_Procedure, ast);
    var params = ast_params(ast);
    var i = 0; var len = params.length;
    var any = tt_any_type(tt);
    var errors = make_vector(0);
    while i < len do
        var param = vector_get(params, i);
        var param_sym = st_get_symbol(st, param);
        assert(param_sym);
        var param_type = symbol_type(param_sym);
        if not param_type or param_type == any then
            vector_push(errors, param_sym);
        end
        i += 1;
    end
    if errors.length > 0 then
        printf("ERROR: in proc `%s`: \n", ast_ident(ast));
        i = 0; len = errors.length;
        while i < len do
            var sym = vector_get(errors, i);
            var type = symbol_type(sym);
            printf("ERROR: `%s`", symbol_name(sym));
            if not type then
                printf(" has no type.\n");
            elif type == any then
                printf(" has type `any.`\n");
            end
            i += 1;
        end
        print_ast_src_loc(ast);
        g_Errors += 1;
    end
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);

    self.current_proc_name = symbol_name(sym);
    self.current_proc_type = symbol_type(sym);

    tc_check_body(self, tt, st, ast_body(ast));

    self.current_proc_type = NULL;
    self.current_proc_name = NULL;
end

proc tc_check_if_else self, tt, st, ast in
    check_ast_kind(AstK_IfElse, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_consequence(ast));
    tc_check_body(self, tt, st, ast_alternative(ast));

    var test_type = tt_get_ast_type(tt, ast_test(ast));
    assert(test_type);
    _tc_check_is_scalar_type(tt, ast_test(ast), test_type);
end

proc tc_check_while self, tt, st, ast in
    check_ast_kind(AstK_While, ast);
    tc_check(self, tt, st, ast_test(ast));
    tc_check_body(self, tt, st, ast_body(ast));

    var test_type = tt_get_ast_type(tt, ast_test(ast));
    assert(test_type);
    _tc_check_is_scalar_type(tt, ast_test(ast), test_type);
end

proc tc_check_pointer_read self, tt, st, ast in
    check_ast_kind(AstK_PointerRead, ast);
    tc_check(self, tt, st, vector_get(ast_pop_args(ast), 0));
end

proc tc_check_pointer_write self, tt, st, ast in
    check_ast_kind(AstK_PointerWrite, ast);
    var pop_args = ast_pop_args(ast);
    tc_check(self, tt, st, vector_get(pop_args, 0));
    tc_check(self, tt, st, vector_get(pop_args, 1));
end

proc tc_check_prefix_op self, tt, st, ast in
    check_ast_kind(AstK_Prefix, ast);
    tc_check(self, tt, st, ast_expr(ast));

    var expr_type = tt_get_ast_type(tt, ast_expr(ast));
    assert(expr_type);

    var op = ast_op(ast);
    if op == TK_KW_not then
        _tc_check_is_scalar_type(tt, ast, expr_type);
    else
        _tc_check_is_int_like(tt, ast, expr_type);
    end
end

proc tc_check_const self, tt, st, ast in
    check_ast_kind(AstK_Const, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_global self, tt, st, ast in
    check_ast_kind(AstK_Global, ast);
    var expr = ast_assign_expr(ast);
    tc_check(self, tt, st, expr);
    var sym = st_get_symbol(st, ast_ident(ast));
    assert(sym);
    _tc_check_ident_type(tt, sym, expr, ast);
end

proc tc_check_cast self, tt, st, ast in
    check_ast_kind(AstK_Cast, ast);
    tc_check(self, tt, st, ast_expr(ast));
end

proc tc_check_member_access self, tt, st, ast in
    // field resolution happened in type inference so not much needed to check here
    check_ast_kind(AstK_MemberAccess, ast);
    tc_check(self, tt, st, ast_expr(ast));
end

proc tc_check_assign_member self, tt, st, ast in
    check_ast_kind(AstK_AssignMember, ast);

    var lhs = ast_lhs(ast);
    var rhs = ast_rhs(ast);
    tc_check(self, tt, st, lhs);
    tc_check(self, tt, st, rhs);

    var op = ast_op(ast);
    var lhs_type = tt_get_ast_type(tt, lhs);
    var rhs_type = tt_get_ast_type(tt, rhs);

    if op == TK_Assign then
        if types_assignable(tt, lhs_type, rhs_type) then
            return;
        end
    elif op == TK_PlusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
        return; // reference += int_like
    elif op == TK_MinusEq and type_is_reference(lhs_type) and type_is_int_like(rhs_type) then
        return; // reference -= int_like
    elif types_assignable(tt, lhs_type, rhs_type) then
        return; // TODO: Verify this is correct behaviour.
    end

    printf("ERROR: The type of `%s` is `", ast_member(lhs));
    tt_print_type_name(tt, lhs_type);
    printf("` which is not assignable by `");
    tt_print_type_name(tt, rhs_type);
    printf(".`\n");
    print_ast_src_loc(ast);
    g_Errors += 1;
end

proc tc_check self, tt, st, ast in
    var k = ast_kind(ast);
    if k == AstK_Ident then // nothing
    elif k == AstK_Integer then // nothing
    elif k == AstK_String then //nothing
    elif k == AstK_Call then tc_check_call(self, tt, st, ast);
    elif k == AstK_BinOp then tc_check_binop(self, tt, st, ast);
    elif k == AstK_Return then tc_check_return(self, tt, st, ast);
    elif k == AstK_VarDecl then tc_check_var_decl(self, tt, st, ast);
    elif k == AstK_VarAssign then tc_check_var_assign(self, tt, st, ast);
    elif k == AstK_Procedure then tc_check_procedure(self, tt, st, ast);
    elif k == AstK_IfElse then tc_check_if_else(self, tt, st, ast);
    elif k == AstK_While then tc_check_while(self, tt, st, ast);
    elif k == AstK_PointerRead then tc_check_pointer_read(self, tt, st, ast);
    elif k == AstK_PointerWrite then tc_check_pointer_write(self, tt, st, ast);
    elif k == AstK_Prefix then tc_check_prefix_op(self, tt, st, ast);
    elif k == AstK_Const then tc_check_const(self, tt, st, ast);
    elif k == AstK_Extern then // nothing
    elif k == AstK_InlineAsm then // nothing
    elif k == AstK_Global then tc_check_global(self, tt, st, ast);
    elif k == AstK_Break then // nothing
    elif k == AstK_Continue then // nothing
    elif k == AstK_AssignOp then tc_check_assign_op(self, tt, st, ast);
    elif k == AstK_Struct then // nothing
    elif k == AstK_Cast then tc_check_cast(self, tt, st, ast);
    elif k == AstK_MemberAccess then tc_check_member_access(self, tt, st, ast);
    elif k == AstK_AssignMember then tc_check_assign_member(self, tt, st, ast);
    elif k == AstK_SizeofExpr then // nothing
    elif k == AstK_SizeofType then // nothing
    else
        printf("  File \"%s\", line %d\n", __FILE__, __LINE__);
        printf("Unhandled AstK: %s (%d)\n", ast_kind_cstr(k), k);
        print_token(ast_token(ast));
        print_token_loc(ast_token(ast));
        exit(1);
    end
end

proc type_check type_table, symbol_table, compile_order: Vector& in
    var type_checker = make_type_check();
    var i = 0; var len = compile_order.length;
    while i < len do
        tc_check(type_checker, type_table, symbol_table, vector_get(compile_order, i));
        i += 1;
    end
    free_type_check(type_checker);
end
